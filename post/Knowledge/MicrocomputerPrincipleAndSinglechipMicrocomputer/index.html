

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="https://murphyimg.oss-cn-beijing.aliyuncs.com/img/202505301726222.png">
  <link rel="icon" href="https://murphyimg.oss-cn-beijing.aliyuncs.com/img/202505301728148.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Murphy">
  <meta name="keywords" content="Murphy,CosmicDusty,murphy,cosmicdusty,cn">
  
    <meta name="description" content="微机原理是我第一次用网络博客的形式学习整理课本知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="微机原理与单片机">
<meta property="og:url" content="https://blog.cosmicdusty.cc/post/Knowledge/MicrocomputerPrincipleAndSinglechipMicrocomputer/index.html">
<meta property="og:site_name" content="Murphy Hou - Blog">
<meta property="og:description" content="微机原理是我第一次用网络博客的形式学习整理课本知识。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/mother-board-581597_1920.jpg">
<meta property="article:published_time" content="2021-06-03T13:52:52.000Z">
<meta property="article:modified_time" content="2023-05-05T14:18:49.000Z">
<meta property="article:author" content="Murphy">
<meta property="article:tag" content="电子信息">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/mother-board-581597_1920.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>微机原理与单片机 - Murphy Hou - Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"blog.cosmicdusty.cc","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"16d93d5abbd7ea15ec53daed5459ebf7","google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"JijHNKemeVNog4wF7g9I5TR3","app_key":"FvsKdxHOP2aG5rHrHby5aV0b","server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?16d93d5abbd7ea15ec53daed5459ebf7";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>CosmicDusty</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/mother-board-581597_1920.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="微机原理与单片机"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Murphy
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-06-03 21:52" pubdate>
          2021年6月3日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          29k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          245 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">微机原理与单片机</h1>
            
            
              <div class="markdown-body">
                
                <p>微机原理是我第一次用网络博客的形式学习整理课本知识。<br>微机原理的需要记忆的东西太多了，并且需要多做题目。<br>期末的时候微机原理学的很不好，临近期末做了一些课后的章节练习，根据做的题目总结了一下知识点，考试的结果还算很不错！</p>
<h1 id="8086"><a href="#8086" class="headerlink" title="8086"></a>8086</h1><h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">8086 ——16位处理器<br>数据总线DB——16位<br>地址总线AB——20位<br></code></pre></td></tr></table></figure>

<h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><p><strong>内存的读步骤</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1.CPU把要读的内存单元的地址放到AB上<br><span class="hljs-bullet">2.</span> CPU发出读命令<br><span class="hljs-bullet">3.</span> 内存将数据从指定单元读到DB上<br><span class="hljs-bullet">4.</span> CPU从DB上取回数据<br></code></pre></td></tr></table></figure>

<p><strong>内存的写操作</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> CPU把要写的内存单元的地址放到AB上<br><span class="hljs-bullet">2.</span> CPU把要写的数据放到DB上<br><span class="hljs-bullet">3.</span> CPU发出写的命令<br><span class="hljs-bullet">4.</span> 数据被内存写到指定的单元<br></code></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">外存中的数据使用前必须先读到内存中，然后CPU才能访问<br></code></pre></td></tr></table></figure>


<h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">总线宽度：一次可以同时传输的数据位数<br>8086，数据总线宽度为16位，地址总线宽度位20位<br></code></pre></td></tr></table></figure>

<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h2 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">异号相加不会溢出<br>同号相加可能溢出<br></code></pre></td></tr></table></figure>

<h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><h2 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">用二进制编码表示十进制数<br>一位十进制数需要用四位二进制编码表示<br>压缩BCD码——一个字节表示两位十进制数<br>非压缩BCD码——一个字节表示一位十进制数（使用低四位）<br></code></pre></td></tr></table></figure>



<h1 id="第二章-8086"><a href="#第二章-8086" class="headerlink" title="第二章 8086"></a>第二章 8086</h1><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">字长——CPU能够同时处理的数据的位数，也称为数据位宽<br>8086——16位<br>主频——时钟频率<br></code></pre></td></tr></table></figure>



<h2 id="8086的编程结构"><a href="#8086的编程结构" class="headerlink" title="8086的编程结构"></a>8086的编程结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdwon">16位数据线；<br>20位地址线——寻址空间:1MB（2^20）<br>寄存器：数值逻辑部件，用来暂存数码和信息；由触发器和门电路阻成；<br></code></pre></td></tr></table></figure>



<h2 id="总线接口部件BIU"><a href="#总线接口部件BIU" class="headerlink" title="总线接口部件BIU"></a><strong>总线接口部件BIU</strong></h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 从内存取指令到指令队列<br><span class="hljs-bullet">2.</span> CPU执行指令时，BIU配合执行部件从指定内存单元或外设端口中取数据，将数据传送给执行部件<br><span class="hljs-bullet">3.</span> BIU配合执行部件把操作结果传送到指定的内存单元或外设接口<br></code></pre></td></tr></table></figure>

<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown">a) 16位段地址寄存器（sgement）——4个<br><span class="hljs-code">    i) CS CODE</span><br><span class="hljs-code">    ii) DS DATA</span><br><span class="hljs-code">    iii) ES EXTRA	</span><br><span class="hljs-code">    iv) SS STACK</span><br><span class="hljs-code">b) 16位指令指针寄存器——IP（instruction pointer）</span><br><span class="hljs-code">c) 20位地址加法器</span><br><span class="hljs-code">    i) 用来产生20位的地址</span><br><span class="hljs-code">        One. 8086用20位地址寻址1MB的内存，但是8086内部的寄存器都是16位的</span><br><span class="hljs-code">        Two. 地址加法器就是根据16位寄存器提供的信息计算出20位的物理地址</span><br><span class="hljs-code">            First. CS左移四位再与IP相加</span><br><span class="hljs-code">d) 6字节的指令队列缓冲器</span><br><span class="hljs-code">    i) 指令队列缓冲器——CPU在执行指令的同时，从内存中取下面一条指令或几条指令放在指令队列中</span><br><span class="hljs-code"></span><br><br></code></pre></td></tr></table></figure>
<h3 id="BIU的执行方式"><a href="#BIU的执行方式" class="headerlink" title="BIU的执行方式"></a>BIU的执行方式</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">| 顺序执行方式：功能部件交替工作，按顺序完成指令的执行过程<br>| 并行流水线方式：各功能部件并行工<br></code></pre></td></tr></table></figure>
<h2 id="执行部件EU"><a href="#执行部件EU" class="headerlink" title="执行部件EU"></a><strong>执行部件EU</strong></h2><h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs markdown">算数逻辑部件ALU<br><br>16位的通用寄存器——4个<br><br><span class="hljs-code">    AX——累加器</span><br><span class="hljs-code"></span><br><span class="hljs-code">    BX</span><br><span class="hljs-code"></span><br><span class="hljs-code">    CX</span><br><span class="hljs-code"></span><br><span class="hljs-code">    DX</span><br><span class="hljs-code"></span><br><span class="hljs-code">		16位通用寄存器可以当作8位来使用，高八位和低八位</span><br><span class="hljs-code"></span><br>16位的专用寄存器——4个<br><br><span class="hljs-code">    BP——BASE POINTER基数指针寄存器</span><br><span class="hljs-code">    SP——STACK POINTER堆栈指针寄存器</span><br><span class="hljs-code">    SI——SOURCE INDEX源变址寄存器</span><br><span class="hljs-code">    DI——DESTINATION           INDEX目的变址寄存器。</span><br><span class="hljs-code"></span><br>16位标志寄存器——九个使用，七个未用<br><br>状态标志位——6个<br><br><span class="hljs-code">    | SF   | Sign flag            | 符号标志       | 与运算结果的最高位相同，运算结果为正数SF=0,运算结果为负数，SF=1</span><br><span class="hljs-code">    | ZF   | Zero flag            | 零标志         | 运算结果为0，ZF=1，运算结果为非零，ZF=0 </span><br><span class="hljs-code">    | PF   | Parity flag          | 奇/偶标志位    | 运算结果中，低八位中所含1的个数为偶数，PF=1；低八位中所含1的个数为奇数，PF=0</span><br><span class="hljs-code">    | CF   | Carry flag           | 进位标志位     | 加法运算——最高位产生进位，CF=1；减法运算——最高位产生借位,CF=1</span><br><span class="hljs-code">    | AF   | Auxiliary carry flag | 辅助进位标志位 | 加法运算——第三位往第四位进位，AF=1；减法运算——第三位从第四位借位，AF=1</span><br><span class="hljs-code">    | OF   | Overflow flage       | 溢出标志位     | 产生溢出——OF=1</span><br><span class="hljs-code"></span><br>控制标志位——3个<br><br><span class="hljs-code">    | DF   | Direction flag        | 方向标志     | 控制串操作指令用的标志：DF=0，串操作过程中地址会不断增值；DF=1，串操作过程中，地址会不断减值</span><br><span class="hljs-code">    | IF   | Interrupt enable flag | 中断允许标志 | 控制可屏蔽中断用的标志：IF=0，CPU不能相应可屏蔽中断的中断请求；IF=1，CPU可接受可屏蔽中断的中断请求</span><br><span class="hljs-code">    | TF   | Trap flag             | 跟踪标志     | TF=1，CPU按跟踪方式，执行指令</span><br></code></pre></td></tr></table></figure>

<h2 id="总线周期（机器周期）"><a href="#总线周期（机器周期）" class="headerlink" title="总线周期（机器周期）"></a><strong>总线周期（机器周期）</strong></h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">CPU通过总线与存储器或IO接口进行一次数据传输所需的时间<br><span class="hljs-code">    | T1 | CPU往多路复用总线上发出地址信息，以指出寻址的存储单元或外设端口的地址</span><br><span class="hljs-code">    | T2 | CPU从总线上撤销地址，使总线的低十六位为高阻态，为数据传输准备</span><br><span class="hljs-code">    | T3 | 总线低十六位上出现由CPU写出的数据或者CPU从存储器或端口读入的数据</span><br><span class="hljs-code">    | Tw | 一个或者多个，等待状态，等待外设或存储器的READY信号</span><br><span class="hljs-code">    | T4 | 总线周期结束</span><br><span class="hljs-code">空闲周期Ti，在一个总线周期结束后，若不执行下一个总线周期，则总线周期处于空闲状态</span><br></code></pre></td></tr></table></figure>



<h2 id="引脚信号与工作模式"><a href="#引脚信号与工作模式" class="headerlink" title="引脚信号与工作模式"></a><strong>引脚信号与工作模式</strong></h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">| 最小工作模式 | 一个8086,总线控制信号都是8086发出<br>| 最大工作模式 | 多个处理器，主处理器：8086，协处理器：8087，8089等<br></code></pre></td></tr></table></figure>
<h3 id="引脚和信号"><a href="#引脚和信号" class="headerlink" title="引脚和信号"></a>引脚和信号</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs markdown">引脚总数：20，双列直插封装<br><br>A,D复用——AD0..AD15<br><br>数据线——16位<br><br><span class="hljs-code">    可用高八位传送一个字节</span><br><span class="hljs-code">    可用低八位传送一个字节</span><br><span class="hljs-code">    也可以用16位数据线传送一个字</span><br><span class="hljs-code">    通过/BHE（BUS HIGH ENABLE）信号区分</span><br><span class="hljs-code"></span><br>RESET系统复位信号<br><br>READY<br><br>/RD：读<br><br>/WR：写<br><br>M//IO：区分CPU与内存之间传输数据还是CPU与IO接口传送数据<br><br>A/S：高四位地址和状态线复用<br><br>VCC:+5V<br><br>GND：地<br><br>AD[0..15]<br><br><span class="hljs-code">    AD0信号可以作为低八位数据的选通信号</span><br><span class="hljs-code">    CPU的传输特性决定了只要是和偶地址单元或偶地址端口交换数据，那么，CPU必定通过总线低八位传输数据</span><br><span class="hljs-code"></span><br>A19/S6A16/S3（输出）<br><br><span class="hljs-code">    地址/状态复用引脚</span><br><span class="hljs-code">    S6=0：8086当前与总线相连</span><br><span class="hljs-code">    S5=1：允许可屏蔽中断请求</span><br><span class="hljs-code">    S4与S3：指出当前正在使用哪个段寄存器</span><br><span class="hljs-code"></span><br>/BHE/S7：高八位数据允许总线/状态复用引脚（输出）<br><br>NMI:非屏蔽中断引脚（输入）<br><br>INTR:可屏蔽中断请求信号（输入）<br><br><span class="hljs-code">    可屏蔽中断请求信号位高电平有效</span><br><span class="hljs-code">    CPU在执行每条指令的最后一个时钟周期会对INTR信号进行采样，如果CPU的中断允许标志位（IF）为1，并且又接收到INTR信号，那么，CPU就会在结束当前指令后，响应中断请求，执行一个中断处理子程序。</span><br><span class="hljs-code"></span><br>/RD: 读信号（输出）<br><br><span class="hljs-code">    指出将要执行对内存或IO端口的读操作</span><br><span class="hljs-code">    与M/IO引脚信号配合，决定读取哪个设备</span><br><span class="hljs-code"></span><br>CLK：时钟（输入）<br><br><span class="hljs-code">    8086要求：1/3周期为高电平（33%占空比）</span><br><span class="hljs-code"></span><br>RESET:复位信号（输入）<br><br><span class="hljs-code">    至少维持四个时钟周期的高电平才有效</span><br><span class="hljs-code"></span><br><span class="hljs-code">    复位执行的操作是</span><br><span class="hljs-code"></span><br><span class="hljs-code">        CS：设置为FFFFH</span><br><span class="hljs-code">        其他：清零</span><br><span class="hljs-code"></span><br>READY：准备好，输入<br><br>/TEST:输入<br><br>MN//MX:最小和最大模式控制信号，（输入）<br></code></pre></td></tr></table></figure>

<h3 id="最小工作模式"><a href="#最小工作模式" class="headerlink" title="最小工作模式"></a>最小工作模式</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs markdown">/INTA:中断响应信号，输出<br><br>对外设的中断请求做出回应<br><br>ALE:地址锁存信号，输出<br><br>在任何一个总线周期的T1状态，ALE输出有效电平，以表示当前在地址/数据复用总线上输出的是地址信息，地址锁存器将ALE作为锁存信号，对地址进行锁存。<br><br>/DEN：数据允许信号，输出<br><br>表示CPU当前准备发送/接收一个数据<br><br>DT//R：数据收发信号，输出<br><br>M//IO<br><br>/WR：写，输出<br><br>HOLD:hold          request，总线保持请求信号<br><br>HLDA:hold          acknowledge 总线保持响应信号<br><br></code></pre></td></tr></table></figure>

<h3 id="最小工作模式下的典型配置"><a href="#最小工作模式下的典型配置" class="headerlink" title="最小工作模式下的典型配置"></a>最小工作模式下的典型配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mark"><br><br>锁存芯片——8282或者74ls373<br>数据总线驱动芯片——8286<br></code></pre></td></tr></table></figure>



<h2 id="8086的操作和时序"><a href="#8086的操作和时序" class="headerlink" title="8086的操作和时序"></a><strong>8086的操作和时序</strong></h2><h3 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">RESET：CPU将CS设置为初值为0FFFFH，其他内部寄存器设置为0<br>CS被初始化为FFFFH，IP被初始化为0000F，那么复位之后，8086从FFF0H开始执行程序<br></code></pre></td></tr></table></figure>

<h3 id="总线操作"><a href="#总线操作" class="headerlink" title="总线操作"></a>总线操作</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">总线读操作和总线写操作<br></code></pre></td></tr></table></figure>
<h3 id="中断操作和中断系统"><a href="#中断操作和中断系统" class="headerlink" title="中断操作和中断系统"></a>中断操作和中断系统</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br>8086可以处理256种不同的中断，中断类型号（0255）<br></code></pre></td></tr></table></figure>

<h4 id="硬件中断——外部中断"><a href="#硬件中断——外部中断" class="headerlink" title="硬件中断——外部中断"></a>硬件中断——外部中断</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">非屏蔽中断<br><br><span class="hljs-code">    通过CPU的NMI引脚进入，不受中断允许标志IF的屏蔽</span><br><span class="hljs-code">    整个系统种只能有一个非屏蔽中断</span><br><span class="hljs-code"></span><br>可屏蔽中断<br><br><span class="hljs-code">    通过CPU的INTR引脚进入的，当IF=1时，可屏蔽中断才可以进入</span><br></code></pre></td></tr></table></figure>

<h4 id="软件中断"><a href="#软件中断" class="headerlink" title="软件中断"></a>软件中断</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">CPU根据某条指令或者软件对标志寄存器中某个标志的设置而产生的<br></code></pre></td></tr></table></figure>
<h4 id="中断向量和中断向量表"><a href="#中断向量和中断向量表" class="headerlink" title="中断向量和中断向量表"></a>中断向量和中断向量表</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br>中断系统以位于内存0段的03FFH（01023D）区域中的中断向量表为基础，中断向量表中最多可以容纳256个中断向量<br><br>中断向量就是中断处理子程序的入口地址，每一个中断类型对应一个中断向量<br><br>一个中断向量占4个存储单元<br><br><span class="hljs-code">    前(低位)</span><br><span class="hljs-code">    </span><br><span class="hljs-code">    | IPL |</span><br><span class="hljs-code">    | IPH |</span><br><span class="hljs-code">    | CSL |</span><br><span class="hljs-code">    | CSH |</span><br><span class="hljs-code">    </span><br><span class="hljs-code">    后（高位）</span><br><span class="hljs-code"></span><br>256个中断的前5个（04号）中断是专用中断<br><br>431号中断为保留的中断<br><br>其余中断：用户自定义<br><br></code></pre></td></tr></table></figure>

<h3 id="8086的存储器编址和IO编址"><a href="#8086的存储器编址和IO编址" class="headerlink" title="8086的存储器编址和IO编址"></a>8086的存储器编址和IO编址</h3><h4 id="存储器编址"><a href="#存储器编址" class="headerlink" title="存储器编址"></a>存储器编址</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs markdown">20根地址线=1MB（2^20）的存储地址空间：（00000-FFFFFH）<br><br>寄存器不能直接对1MB的内存空间进行寻址，引入分段的概念<br><br>一个段最长64KB（2^16）<br><br>各段的地址分别由CS,DS,SS,ES给出，寄存器为16位<br><br>存储单元的物理地址：（5位）<br><br>段地址左移四位(从16位变成20位)再加16位的偏移量<br><br>偏移量又称有效地址：可以放在IP,SP,BP,SI,DI,BX中<br><br>8086运行过程中，物理地址的形成因操作而异<br><br><span class="hljs-code">    | 取指令                       | CS+IP</span><br><span class="hljs-code">    | 堆栈操作                     | SS+SP或者SS+BP</span><br><span class="hljs-code">    | 往内存写数据或者从内存读数据   | DS+SI或DS+DI或DS+BX</span><br><span class="hljs-code"></span><br>存储器的操作数可以是一个字节，也可以是一个字<br><br>如果是字操作数，低位字节放在较低的地址单元，高位字节放在较高的地址单元<br>字的地址以低位地址来表示<br></code></pre></td></tr></table></figure>

<h4 id="存储器编址的注意事项"><a href="#存储器编址的注意事项" class="headerlink" title="存储器编址的注意事项"></a>存储器编址的注意事项</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">根据一个物理地址可以反推出多个段地址和偏移量的组合<br><br>CS,DS,SS,ES的空间大小为64KB.但是在实际应用中，这些段之间可以有相互覆盖的部分<br><br>存储器中有的区域的功能是固定的<br><br><span class="hljs-code">    中断向量表:00000-003FFH</span><br><span class="hljs-code">    单色显示器的显示缓冲区</span><br><span class="hljs-code">    彩色显示器的显示缓冲区</span><br><span class="hljs-code">    无条件转移指令</span><br></code></pre></td></tr></table></figure>
<h4 id="奇地址和偶地址"><a href="#奇地址和偶地址" class="headerlink" title="奇地址和偶地址"></a>奇地址和偶地址</h4><h3 id="8086的IO编址"><a href="#8086的IO编址" class="headerlink" title="8086的IO编址"></a>8086的IO编址</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">8086允许有65536（64K）个8为的IO端口<br><br>两种编址方式<br>统一编址<br><br><span class="hljs-code">    可以用访问存储器的指令来实现对IO端口的读写，不需要设置专用的IO指令</span><br><span class="hljs-code"></span><br>独立编址<br><br><span class="hljs-code">    使用指令系统中的专用的IO指令</span><br></code></pre></td></tr></table></figure>

<h1 id="第三章-指令系统"><a href="#第三章-指令系统" class="headerlink" title="第三章 指令系统"></a>第三章 指令系统</h1><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>寻址就是寻找操作数得来源</p>
<h3 id="立即数寻址"><a href="#立即数寻址" class="headerlink" title="立即数寻址"></a>立即数寻址</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">所调用得操作数就在指令中直接给出<br>一般用与对寄存器赋值<br></code></pre></td></tr></table></figure>

<h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br><span class="hljs-built_in">AX</span> <span class="hljs-built_in">BX</span> <span class="hljs-built_in">CX</span> <span class="hljs-built_in">DX</span> <span class="hljs-built_in">SI</span> <span class="hljs-built_in">DI</span> <span class="hljs-built_in">SP</span> <span class="hljs-built_in">BP</span><br>对段寄存器不能直接赋值&gt;<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span>,<span class="hljs-number">0FFFFH</span> <br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">DS</span>, <span class="hljs-built_in">AX</span><br><br></code></pre></td></tr></table></figure>

<h3 id="IO端口寻址"><a href="#IO端口寻址" class="headerlink" title="IO端口寻址"></a>IO端口寻址</h3><h4 id="IO直接寻址"><a href="#IO直接寻址" class="headerlink" title="IO直接寻址"></a>IO直接寻址</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">    IO端口的地址直接在指令中给出</span><br><span class="hljs-code">    寻址范围：0-255（00-FFH）</span><br><span class="hljs-code">````</span><br><span class="hljs-code">#### IO间接寻址</span><br><span class="hljs-code">``` markdown</span><br><span class="hljs-code">    先把DX寄存器中设置好IO端口的地址，IO指令用DX用寄存器间接寻址</span><br><span class="hljs-code">    寻址范围：0-655536（0-FFFFH）</span><br></code></pre></td></tr></table></figure>

<h3 id="存储器寻址"><a href="#存储器寻址" class="headerlink" title="存储器寻址"></a>存储器寻址</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">存储器单元的地址由段基地址+偏移量组成<br>偏移量就是有效地址EA<br><br>有效地址EA = 基址 + 变址 * 比例因子 + 位移量<br></code></pre></td></tr></table></figure>



<h4 id="1直接寻址"><a href="#1直接寻址" class="headerlink" title="1直接寻址"></a>1直接寻址</h4><pre><code class="hljs">存储单元的有效地址由指令直接给出
MOV        AX,[1070H] ；将**段的1070H（4位）和1071H（4位）两单元的内容取到AX（16位）中
MOV        AX,ES:[1000H]  ;(带超越前缀)
</code></pre>
<h4 id="2寄存器间接寻址"><a href="#2寄存器间接寻址" class="headerlink" title="2寄存器间接寻址"></a>2寄存器间接寻址</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown">存储单元的有效地址由寄存器指出<br>MOV AX,[BX]<br>MOV CX,ES:[BX]<br><br>默认<br>SS:BP<br><br><br>DS:SI<br>DS:DI<br>DS:BX<br></code></pre></td></tr></table></figure>

<h4 id="3寄存器相对寻址"><a href="#3寄存器相对寻址" class="headerlink" title="3寄存器相对寻址"></a>3寄存器相对寻址</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">带位移量的寄存器相对寻址<br>MOV AX,[BX+100H]<br>寄存器的相对寻址常用做表格处理：将表格的首地址作为位移量，通过修改寄存器的内容指向表格的某一项<br></code></pre></td></tr></table></figure>
<h4 id="4基址-变址的寻址"><a href="#4基址-变址的寻址" class="headerlink" title="4基址+变址的寻址"></a>4基址+变址的寻址</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">基址寄存器BX,BP<br>变址寄存器SI,DI<br>段地址寄存器为DS时基址寄存器用BX<br>段地址寄存器位SS时基址寄存器用BP<br><br>当基址寄存器为BX时，段寄存器使用DS，当基址寄存器为BP时，段寄存器用SS。<br><br>MOV AX,[BX+SI]<br>MOV AX,[BX+DI]<br>MOV AX,[BP+SI]<br>MOV AX,[BP+DI]<br>等价写法：MOV AX,[<span class="hljs-string">BX+SI</span>]=======MOV AX,[<span class="hljs-string">BX</span>][<span class="hljs-symbol">SI</span>]<br></code></pre></td></tr></table></figure>
<h4 id="5相对的基址-变址寻址"><a href="#5相对的基址-变址寻址" class="headerlink" title="5相对的基址+变址寻址"></a>5相对的基址+变址寻址</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">带有位移量的基址+变址寻址<br>MOV AX,[BX+SI+0050H]<br></code></pre></td></tr></table></figure>
<h4 id="6相对的带比例因子的变址寻址（8086没有此功能）"><a href="#6相对的带比例因子的变址寻址（8086没有此功能）" class="headerlink" title="6相对的带比例因子的变址寻址（8086没有此功能）"></a>6相对的带比例因子的变址寻址（8086没有此功能）</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">MOV BX,[SI<span class="hljs-emphasis">*4+7]</span><br></code></pre></td></tr></table></figure>
<h4 id="7基址-比例因子的变址寻址（8086没有此功能）"><a href="#7基址-比例因子的变址寻址（8086没有此功能）" class="headerlink" title="7基址+比例因子的变址寻址（8086没有此功能）"></a>7基址+比例因子的变址寻址（8086没有此功能）</h4><h4 id="8相对的基址-比例因子的寻址（8086没有此功能）"><a href="#8相对的基址-比例因子的寻址（8086没有此功能）" class="headerlink" title="8相对的基址+比例因子的寻址（8086没有此功能）"></a>8相对的基址+比例因子的寻址（8086没有此功能）</h4><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><h3 id="传送指令"><a href="#传送指令" class="headerlink" title="传送指令"></a>传送指令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs markdown">CPU的内存寄存器之间，CPU和存储器之间，CPU和IO端口之间的数据交换<br><br><br>MOV：两操作数的位数相同<br><br><span class="hljs-code">    | MOV AL,BL               | 8位的数据从BL送到AL </span><br><span class="hljs-code">    | MOV ES,DX               | 16位的数据从DX从到段寄存器ES中</span><br><span class="hljs-code">    | MOV AX,[BX]             | 寄存器寻址方式：间接寻址！BX寄存器中存储的是某个存储单元的偏移地址(eg:1070H)，假设地址为1070H的存储单元中的内容是12H，假设地址为1071H的存储单元中的内容是34H，[BX]的意思时是，取出1070H和1071H这两个存储单元中所存储的内容，也就是1234H，然后MOV，AX,[BX]的意思也就是把取出来的值赋给AX，因此AX中存放的值就是1234H</span><br><span class="hljs-code">    | MOV [DI],AX             | 假如AX中的值是1234H，I的值是1070H，那么意思就是，把1234H放到两个偏移地址分别是1070H和1071H的内存单元中，偏移地址为1070H的内存单元中的值是34，偏移地址为1071H的内存单元中的值是12</span><br><span class="hljs-code">    | MOV DI,[BX]             |</span><br><span class="hljs-code">    | MOV CX,[1000H]          | </span><br><span class="hljs-code">    | MOV WORD PTR [SI],1234H |</span><br><span class="hljs-code">    | MOV DX,5040H            | 立即数送到DX</span><br><span class="hljs-code"></span><br><span class="hljs-code">    MOVZX,MOVSX:两操作数的位数不相同</span><br><span class="hljs-code"></span><br>注意<br><br><span class="hljs-code">    CS,IP寄存器不能作为目的操作数</span><br><span class="hljs-code">    SI,DI来间接寻址时，默认的段寄存器为DS</span><br><span class="hljs-code">    BP,SP来间接寻址时，默认的段寄存器为SS</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure>


<h3 id="堆栈指令"><a href="#堆栈指令" class="headerlink" title="堆栈指令"></a>堆栈指令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">PUSH：把一个2字节或者4字节的数据推入堆栈<br><br>POP:<br><br><span class="hljs-code">    | PUSH BX                | 将BX的内容推入堆栈，堆栈指针减2</span><br><span class="hljs-code">    | PUSH [BX+DI]           | 把BX+DI和BX+DI+1所指的两内存单元的值压入堆栈</span><br><span class="hljs-code">    | PUSH 0870H             | 把立即数压栈</span><br><span class="hljs-code">    | PUSH DWORD PTR [BX+SI] | 双字压栈</span><br><span class="hljs-code">    | POP BX                 | 栈顶两单元弹出送给BX，栈顶地址+2</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure>
<h3 id="交换指令"><a href="#交换指令" class="headerlink" title="交换指令"></a>交换指令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">XCHG：字节，字，双字的交换<br><br>实现通用寄存器之间，通用寄存器和存储单元之间，不能在两存储单元之间<br><br><span class="hljs-code">    | XCHG AL,BL     |</span><br><span class="hljs-code">    | XCHG BX,CX     |</span><br><span class="hljs-code">    | XCHG [2530],CX |</span><br></code></pre></td></tr></table></figure>
<h3 id="输入输出指令"><a href="#输入输出指令" class="headerlink" title="输入输出指令"></a>输入输出指令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown">在主机和外部设备之间传送信息时，用输入输出指令<br><br>寻址方式<br><br><span class="hljs-code">    | 直接的IO指令  | 在指令中直接提供了IO端口号码(寻址范围0255)</span><br><span class="hljs-code">    | IN AL,50H    | 把端口50H的内容读入AL</span><br><span class="hljs-code">    | IN AX,70H    | 把端口70H的内容读入AL，把端口71H的内容读入AH</span><br><span class="hljs-code">    | OUT 80H,AX   | 把AL的内容输出到端口80H，把AH的内容输出到端口81H</span><br><span class="hljs-code">    | 间接的IO指令  | 用寄存器DX设置端口号（寻址范围065536）</span><br><span class="hljs-code">    | IN AL,DX     | （DX式唯一的，其他的都不可以）</span><br><span class="hljs-code">    | IN AX,DX     |</span><br><span class="hljs-code">    | OUT DX,AL    |</span><br><span class="hljs-code">    | OUT DX,AX    |</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure>
<h3 id="换码指令"><a href="#换码指令" class="headerlink" title="换码指令"></a>换码指令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">XLAT:将累加器中的一个值变换成内存表格中的某一个值，一般用来实现编码制的转换<br></code></pre></td></tr></table></figure>

<h3 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">LEA:取有效地址：将存储器的有效地址送到一个寄存器，常用来使一个寄存器作为地址指针<br><br><span class="hljs-code">    | LEA AX,[3820H]          | AX=3820H</span><br><span class="hljs-code">    | LEA BX,[BP+SI]          | BX=BP+SI</span><br><span class="hljs-code">    | LEA BX,[BP+SI+10H]      | BX=BP+SI+10H</span><br><span class="hljs-code">    | LDS DI,[2530H]          | 把2530H，2531H的16位偏移量送到DI，把2532H，2533H的16位段码送到DS</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure>

<h3 id="标志传送指令"><a href="#标志传送指令" class="headerlink" title="标志传送指令"></a>标志传送指令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">| LAHF | 将标志寄存器中的低八位传送到AH中<br>| SAHF | 将AH中的内容送到标志寄存器的低八位<br></code></pre></td></tr></table></figure>

<h3 id="算数运算指令"><a href="#算数运算指令" class="headerlink" title="算数运算指令"></a>算数运算指令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs markdown">加法<br><br><span class="hljs-code">    | ADD  | 不带进位ADD CX,1000H</span><br><span class="hljs-code">    | ADC  | 带进位</span><br><span class="hljs-code">    | INC  | a++ INC不会影响CF，即使用INC不会产生进位</span><br><span class="hljs-code"></span><br>减法<br><br><span class="hljs-code">    | SUB  | 不考虑借位</span><br><span class="hljs-code">    | SBB  | 考虑借位</span><br><span class="hljs-code">    | DEC  | a--</span><br><span class="hljs-code">    | NEG  | 求补</span><br><span class="hljs-code">    | CMP  | 比较指令：执行两个数相减但不送回相减的结果，只影响结果的标志位</span><br><span class="hljs-code"></span><br>乘法（和AX或AL进行运算，隐含寻址）<br><br><span class="hljs-code">    | MUL  | 无符号数的乘法 |</span><br><span class="hljs-code">    | IMUL | 有符号数的乘法 |</span><br><span class="hljs-code"></span><br>除法（和AX或AL进行运算，隐含寻址）<br><br><span class="hljs-code">    | DIV  | 无符号数的除法 |</span><br><span class="hljs-code">    | IDIV | 有符号数的除法 |</span><br><span class="hljs-code"></span><br>类型转换<br><br><span class="hljs-code">    | CBW  | 字节转换成字 |</span><br><span class="hljs-code">    | CWD  | 字转换成双字 |</span><br><span class="hljs-code"></span><br>BCD码<br><span class="hljs-code">	BCD码加法十进制调整指令</span><br><span class="hljs-code">        AAA:用与两个非组合的BCD码相加进行调整，产生有个非组合的BCD码</span><br><span class="hljs-code">        DAA:用与两个组合的BCD码相加结果进行调整，产生一个组合的BCD码</span><br><span class="hljs-code">        </span><br><span class="hljs-code">        MOV AL,37H</span><br><span class="hljs-code">        MOV BL,35H</span><br><span class="hljs-code">        ADD AL,BL ;两个16进制数相加，AL此时为37H+35H=6C</span><br><span class="hljs-code">        DAA ;DAA调整，这时AL为72H。</span><br><span class="hljs-code">        </span><br><span class="hljs-code">        组合BCD码是通常的8421码，它用4个二进制位表示一个十进制位，一个字节可以表示两个十进制位，即00~99。</span><br><span class="hljs-code">        MOV AL，68H ；AL=68H，表示压缩BCD码68</span><br><span class="hljs-code">        MOV BL，28H ；BL=28H；表示压缩BCD码28</span><br><span class="hljs-code">        ADD AL，BL ；二进制加法：AL=68H+28H=90H</span><br><span class="hljs-code">        DAA ； 十进制调整：AL=96H</span><br><span class="hljs-code"></span><br><span class="hljs-code">        非组合BCD码用8个二进制位表示一个十进制位，实际上只是用低4个二进制位表示一个十进制位0~9，高4位任意，但通常默认为0。ASCII码中0~9的编码是30H~39H，所以0~9的ASCII码（高4位变为0）就可以认为是非压缩BCD码。</span><br><span class="hljs-code">        MOV AX，0608H ；AX=0608H，表示非压缩BCD码68</span><br><span class="hljs-code">        MOV BL，09H ；BL=09H，表示非压缩BCD码9</span><br><span class="hljs-code">        ADD AL，BL ；二进制加法：AL=08H+09=11H</span><br><span class="hljs-code">        AAA ；十进制调整：AX=0707H</span><br><span class="hljs-code">    ------------------------------------------------------------------------</span><br><span class="hljs-code">	减法</span><br><span class="hljs-code">	AAS  非组合</span><br><span class="hljs-code">	</span><br><span class="hljs-code">	DAS  组合</span><br><span class="hljs-code">	------------------------------------------------------------------------</span><br><span class="hljs-code">	AAM 乘法</span><br><span class="hljs-code">	</span><br><span class="hljs-code">	AAD  除法</span><br><span class="hljs-code">	</span><br><span class="hljs-code">	</span><br></code></pre></td></tr></table></figure>



<h3 id="逻辑运算和移位"><a href="#逻辑运算和移位" class="headerlink" title="逻辑运算和移位"></a>逻辑运算和移位</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs markdown">逻辑运算<br><br><span class="hljs-code">    | AND  | 与 AND AX,1000H，结果放到AX</span><br><span class="hljs-code">    | OR   | 或 OR AX,1000H，结果放到AX</span><br><span class="hljs-code">    | NOT  | 非 NOT AX，结果放到AX，非运算的操作数不能是立即数</span><br><span class="hljs-code">    | XOR  | 异或 XOR AX，1000H，结果放到AX</span><br><span class="hljs-code">    | TEST | 测试：TEST AL,01H，进行与计算，但是不送回结果，仅改变标志位</span><br><span class="hljs-code"></span><br><br>移位<br><span class="hljs-code">    移动一位时，由指令直接给出；移动两位及以上，则移动次数由CL指定</span><br><span class="hljs-code">非循环移位指令</span><br><span class="hljs-code"></span><br><span class="hljs-code">    | SAL  | 算数左移 |</span><br><span class="hljs-code">    | SHL  | 逻辑左移 |</span><br><span class="hljs-code">    | SAR  | 算数右移 |</span><br><span class="hljs-code">    | SHR  | 算数右移 |</span><br><span class="hljs-code"></span><br><br>循环移位指令<br><br><span class="hljs-code">    | ROL  | 不带进位的循环左移 |</span><br><span class="hljs-code">    | ROR  | 不带进位的循环右移 |</span><br><span class="hljs-code">    | RCL  | 带进位的循环左移   |</span><br><span class="hljs-code">    | RCR  | 带进位的循环右移   |</span><br></code></pre></td></tr></table></figure>

<h3 id="串操作"><a href="#串操作" class="headerlink" title="串操作"></a>串操作</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-code">    | 源串一般放在数据段，偏移地址由SI指定 目标串一般放在附加段，偏移地址由DI指定</span><br><span class="hljs-code">    | 指令自动修改地址指针，修改方向由DF指定</span><br><span class="hljs-code">    | 数据块长度由CX指定</span><br><span class="hljs-code">    | CLD与STD是用来操作方向标志位DF（Direction Flag）。CLD使DF复位，即DF=0，STD使DF置位，即DF=1.用于串操作指令中。</span><br><span class="hljs-code"></span><br>重复前缀指令<br><br><span class="hljs-code">    | REP   | 无条件重复 |</span><br><span class="hljs-code">    | REPE  | 相等重复   |</span><br><span class="hljs-code">    | REPZ  | 为零重复   |</span><br><span class="hljs-code">    | REPNE | 不相等重复 |</span><br><span class="hljs-code">    | REPNZ | 不为零重复 |</span><br><span class="hljs-code"></span><br><span class="hljs-code">    | 字符串传送指令：MOVS</span><br><span class="hljs-code">    | 字符串比较指令： COMPS</span><br><span class="hljs-code">    | 字符串检索指令：SCAS</span><br><span class="hljs-code">    | 取字符串：LODS</span><br><span class="hljs-code">    | 存字符串：STOS</span><br><span class="hljs-code"></span><br>IO串操作<br></code></pre></td></tr></table></figure>

<h3 id="调用，转移，循环，中断"><a href="#调用，转移，循环，中断" class="headerlink" title="调用，转移，循环，中断"></a>调用，转移，循环，中断</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs markdown">转移和调用<br><span class="hljs-code">    段内直接转移方式</span><br><span class="hljs-code">    段内间接转移方式</span><br><span class="hljs-code">    段间直接转移方式</span><br><span class="hljs-code">    段间间接寻址方式</span><br><span class="hljs-code">子程序调用和返回</span><br><span class="hljs-code"></span><br><span class="hljs-code">    CALL</span><br><span class="hljs-code">        | CALL 1000H         | 段内直接调用 |</span><br><span class="hljs-code">        | CALL AX            | 段内间接调用 |</span><br><span class="hljs-code">        | CALL 2500H:3600H   | 段间直接调用 |</span><br><span class="hljs-code">        | CALL DWORD PTR[DI] | 段间间接调用 |</span><br><span class="hljs-code">    RET</span><br><span class="hljs-code"></span><br>无条件转移和条件转移<br><br><span class="hljs-code">    | 无条件转移指令 ： JMP</span><br><span class="hljs-code">    | 条件转移指令：</span><br><span class="hljs-code">    				JE/JZ  	结果为0则转移</span><br><span class="hljs-code">    				JNE/JNZ	结果不为0</span><br><span class="hljs-code">    				JG/JNLE 大于（有符号数）</span><br><span class="hljs-code">    				JNG/JLE	不大于（有符号数）</span><br><span class="hljs-code">    				JL/JNGE	小于（有符号数）</span><br><span class="hljs-code">    				JNL/JGE	不小于（有符号数）</span><br><span class="hljs-code">    				JB/JNAE 低于（无符号数）</span><br><span class="hljs-code">    				JNB/JAE	不低于（无符号数）</span><br><span class="hljs-code">    				JA/JNBE	高于（无符号数）</span><br><span class="hljs-code">    				JNA/JBE	不高于（无符号数）</span><br><span class="hljs-code"></span><br>循环<br><br><span class="hljs-code">    | LOOP   | </span><br><span class="hljs-code">      loop指令的格式是：loop标号，cpu执行loop指令的时候，要进行两步操作</span><br><span class="hljs-code">             1：（cx）=（cx）-1   </span><br><span class="hljs-code">            2：判断cx中的值，不为零则转至标号处执行，如果为零，则向下执行</span><br><span class="hljs-code">    | LOOPZ  |</span><br><span class="hljs-code">    | LOOPNZ |</span><br><span class="hljs-code"></span><br>中断<br><br><span class="hljs-code">    | INT n      | 执行中断类型n的中断服务程序 |</span><br><span class="hljs-code">    | INT0       | 执行溢出中断的中断服务程序  |</span><br><span class="hljs-code">    | IRET/IRETD | 从中断服务程序返回调用程序  |</span><br><span class="hljs-code"></span><br>中断指令的执行过程<br><span class="hljs-code">    将FLAGS压入堆栈；</span><br><span class="hljs-code">    将INT指令的下一条指令的CS,IP压栈</span><br><span class="hljs-code">    由n*4得到存放中断向量表的地址</span><br><span class="hljs-code">    将中断向量（中断服务程序入口地址）送CS和IP寄存器</span><br><span class="hljs-code">    转入中断服务程序</span><br><span class="hljs-code">    </span><br><span class="hljs-code">    IRET 是中断服务子程序的返回指令。</span><br><span class="hljs-code">	用于从中断返回， 等价于</span><br><span class="hljs-code">	POP CS</span><br><span class="hljs-code">	POP IP</span><br><span class="hljs-code">	POPF（标志传送指令（标志位出栈指令） POPF）</span><br></code></pre></td></tr></table></figure>

<h3 id="标志操作和处理器控制"><a href="#标志操作和处理器控制" class="headerlink" title="标志操作和处理器控制"></a>标志操作和处理器控制</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">标志操作<br>暂停指令<br>交权，等待<br>总线封锁<br></code></pre></td></tr></table></figure>

<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><h4 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">标识符<br>保留字<br>分界符<br>常数<br></code></pre></td></tr></table></figure>
<h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs markdown">操作数<br><br>运算符<br><br><span class="hljs-code">    算数运算符：+*/和MOD</span><br><span class="hljs-code"></span><br><span class="hljs-code">    逻辑运算符：AND OR NOT XOR</span><br><span class="hljs-code"></span><br><span class="hljs-code">    关系运算符：EQ NE LT GT LE GE</span><br><span class="hljs-code"></span><br>分析运算符<br><br><span class="hljs-code">    OFFSET：取存储单元地址的偏移量</span><br><span class="hljs-code">    SGE:取存储单元地址的断码</span><br><span class="hljs-code">    </span><br><span class="hljs-code">    MOV SI,OFFSET BUFFER</span><br><span class="hljs-code">    MOV DX,SEG BUFFER</span><br><span class="hljs-code">    </span><br><span class="hljs-code">    LEA AX,BUFFER</span><br><span class="hljs-code"></span><br>综合运算符<br><br><span class="hljs-code">    PTR:用来对存储单元规定类型，通常和后面讲述的伪指令BYTE,WORD,DWORD等连用</span><br><span class="hljs-code">    </span><br><span class="hljs-code">	MOV BYTE PTR[1000],0</span><br><span class="hljs-code">	MOV WORD PTR[1000],0</span><br><span class="hljs-code">	MOV DWORD PTR[1000],0</span><br><span class="hljs-code">	</span><br><span class="hljs-code">	</span><br></code></pre></td></tr></table></figure>
<h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 指令性语句 标志性语句<br><span class="hljs-bullet">-</span> 一条指令性语句实际上就是一条指令<br><span class="hljs-bullet">-</span> 指示性语句也叫伪指令<br><span class="hljs-bullet">-</span> 每条指令性语句在汇编过程中都会产生对应的目标代码<br><span class="hljs-bullet">-</span> 指示性语句为汇编程序提供某些信息，让汇编程序在汇编过程中执行某些特定的功能<br></code></pre></td></tr></table></figure>



<h4 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs markdown">标号赋值伪指令<br><span class="hljs-code">	EQU</span><br><span class="hljs-code">	MAXNUM EQU 200 </span><br><span class="hljs-code"></span><br>定义存储单元的伪指令：<br><br><span class="hljs-code">    | DB   | 字节     | AA DB 0AH</span><br><span class="hljs-code">    | DW   | 字       | BB DW 10 DUP(?) </span><br><span class="hljs-code">    | DD   | 双字     |</span><br><span class="hljs-code">    | DQ   | 四字     |</span><br><span class="hljs-code">    | DT   | 10个字节 |</span><br><span class="hljs-code"></span><br>定义存储单元类型的伪指令：必须与PTR配合使用<br><br><span class="hljs-code">    | BYTE  | BYTE PTR  |</span><br><span class="hljs-code">    | WORD  | WORD PTR  |</span><br><span class="hljs-code">    | DWORD | DWORD PTR |</span><br><span class="hljs-code"></span><br>段定义伪指令<br><br><span class="hljs-code">    | SEGMENT |</span><br><span class="hljs-code">    | ENDS    |</span><br><span class="hljs-code">    | ASSUME  | 告诉汇编程序，哪个段为数据段，哪个段为堆栈段，哪个段为代码段</span><br><span class="hljs-code">    | ORG     | 用来规定目标程序存放单元的偏移量   ORG  2000H</span><br><span class="hljs-code"></span><br>简约段定义伪指令<br><br>定义过程的伪指令<br><br><span class="hljs-code">    | PROC | 子程序</span><br><span class="hljs-code">    | ENDP | </span><br><span class="hljs-code">    | NEAR | 段内调用 </span><br><span class="hljs-code">    | FAR  | 段间调用</span><br><span class="hljs-code"></span><br>源程序结束伪指令<br><br><span class="hljs-code">    | END  | 源程序的结束标志 |</span><br></code></pre></td></tr></table></figure>





<h1 id="IO-1"><a href="#IO-1" class="headerlink" title="IO"></a>IO</h1><h1 id="Ⅰ、接口综述"><a href="#Ⅰ、接口综述" class="headerlink" title="Ⅰ、接口综述"></a>Ⅰ、接口综述</h1><p>存储器可以直接挂在到系统总线上，外设不能直接挂在系统总线上</p>
<h2 id="接口的基本功能"><a href="#接口的基本功能" class="headerlink" title="接口的基本功能"></a>接口的基本功能</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">数据的缓冲与暂存<br>信号电平与类型的转换<br>增加信号的驱动能力<br>对外设进行监测、控制与管理、中断<br></code></pre></td></tr></table></figure>

<h2 id="CPU与IO设备之间的信号"><a href="#CPU与IO设备之间的信号" class="headerlink" title="CPU与IO设备之间的信号"></a>CPU与IO设备之间的信号</h2><h3 id="①数据信息"><a href="#①数据信息" class="headerlink" title="①数据信息"></a>①数据信息</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">数字量<br>模拟量<br>开关量<br></code></pre></td></tr></table></figure>
<h3 id="②状态信息"><a href="#②状态信息" class="headerlink" title="②状态信息"></a>②状态信息</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">外设-&gt;CPU<br><span class="hljs-bullet">    -</span> BUSY<br><span class="hljs-bullet">    -</span> READY<br></code></pre></td></tr></table></figure>
<h3 id="③控制信息"><a href="#③控制信息" class="headerlink" title="③控制信息"></a>③控制信息</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">CPU-&gt;外设：控制外设的工作<br></code></pre></td></tr></table></figure>
<h2 id="接口的功能"><a href="#接口的功能" class="headerlink" title="接口的功能"></a>接口的功能</h2><p>CPU和外设之间的数据传送方式—&gt;解决CPU与外设之间数据传输时速度不匹配问题</p>
<h3 id="①程序方式"><a href="#①程序方式" class="headerlink" title="①程序方式"></a>①<strong>程序方式</strong></h3><h4 id="无条件传送方式"><a href="#无条件传送方式" class="headerlink" title="无条件传送方式"></a>无条件传送方式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">如果CPU能够确信一个外设已经准备就绪，那就不必查询外设的状态而直接进行数据传输，这就是无条件传送方式<br>只适用于简单的外设的操作：开关，数码管<br>输入需要缓冲，输出需要锁存<br></code></pre></td></tr></table></figure>



<h4 id="条件传送方式"><a href="#条件传送方式" class="headerlink" title="条件传送方式"></a>条件传送方式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">又名“查询方式”<br>用条件传送方式时，CPU通过执行程序不断读取并测试外设的状态，当外设处于READY或空闲状态时，CPU输入输出指令与外设进行数据交换<br>在查询方式下，CPU不断读取状态字和检测状态字，如状态字表明外设并未准备好，则CPU等待，占用CPU的时间<br></code></pre></td></tr></table></figure>

<h3 id="②中断方式"><a href="#②中断方式" class="headerlink" title="②中断方式"></a>②中断方式</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">由外设中断CPU的工作，CPU暂停执行当前程序，而去执行一个数据输入输出的程序，此程序称为中断处理子程序或中断服务子程序，中断子程序执行完后，CPU又转回来执行原来的程序<br>外设主动发起中断请求<br>CPU本身的功能：<br><span class="hljs-code">    每条指令执行完后，如有中断请求，那么在中断允许标志位为1的情况下，CPU保留下一条指令的地址和当前的标志，转去执行中断服务子程序</span><br><span class="hljs-code">多个中断源产生中断，中断优先级问题？</span><br></code></pre></td></tr></table></figure>

<h3 id="③DMA（直接存储器存取方式）"><a href="#③DMA（直接存储器存取方式）" class="headerlink" title="③DMA（直接存储器存取方式）"></a>③DMA（直接存储器存取方式）</h3><h1 id="Ⅱ、串行接口和串行通信"><a href="#Ⅱ、串行接口和串行通信" class="headerlink" title="Ⅱ、串行接口和串行通信"></a>Ⅱ、串行接口和串行通信</h1><p>数据是一位一位进行传输的</p>
<p>每一位数据占用一个固定的时间长度</p>
<h2 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">全双工<br>半双工<br>单工<br></code></pre></td></tr></table></figure>

<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">异步方式：收发双方不用统一时钟进行定时<br>两个字符之间的传输间隔是任意的，每一个字符的前后都要用一些数位来作为分隔位<br>起始位：每个字符开始传送的标志，起始位采用逻辑0电平<br>数据位：数据位紧跟着起始位传送；由5-8个二进制位阻成，低位先传；<br>校验位：奇校验，偶校验，不传送校验位<br><span class="hljs-section">停止位：表示该字符传送结束。停止位采用逻辑电平1，可选择1，1.5或2位</span><br><span class="hljs-section">---------------------------------------------------------------------------------------------------------------</span><br>同步方式：收发双方采用同一个时钟信号定时<br>以一个固定长度的字符阻成的数据块为传输单位，每个数据块附加一个或两个同步字符，最后以校验字符结束<br></code></pre></td></tr></table></figure>

<h2 id="串行通信的传输率"><a href="#串行通信的传输率" class="headerlink" title="串行通信的传输率"></a>串行通信的传输率</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown">波特率：指的单位时间内传送二进制数据的位数，单位为位/秒（bps）<br><br>发送时钟：决定数据位宽度的时钟<br><br>接收时钟：用与测定每一位输入数据位宽度的时钟<br><br>发送/接收时钟=n<span class="hljs-emphasis">*波特率</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">- n为波特率因子，表征多少个时钟周期传输一个bit</span><br><span class="hljs-emphasis">- n=1或16或32或64</span><br><span class="hljs-emphasis">- 接收端一般n远大于1</span><br></code></pre></td></tr></table></figure>



<h1 id="Ⅲ、8251A"><a href="#Ⅲ、8251A" class="headerlink" title="Ⅲ、8251A"></a>Ⅲ、8251A</h1><h2 id="1-基本性能"><a href="#1-基本性能" class="headerlink" title="1.基本性能"></a>1.基本性能</h2><p>可以工作在同步或异步方式<br><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/1.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="1"></p>
<h2 id="2-基本工作原理"><a href="#2-基本工作原理" class="headerlink" title="2.基本工作原理"></a>2.基本工作原理</h2><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/2.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="2"></p>
<h3 id="七个模块"><a href="#七个模块" class="headerlink" title="七个模块"></a>七个模块</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs markdown">接收缓冲器<br><span class="hljs-code">	从RXD引脚上接收串行数据，并按照相应的格式将串行数据转换成并行数据</span><br><span class="hljs-code"></span><br>接收控制电路<br><span class="hljs-code">	对接收的数据进行检测，检测起始位，校验位，停止位等</span><br><span class="hljs-code"></span><br>发送缓冲器<br><span class="hljs-code">	把来自CPU的并行数据加上相应的控制信息，然后转换成串行数据从TXD引脚发送出去</span><br><span class="hljs-code"></span><br>发送控制电路<br><span class="hljs-code">	控制插入起始位，校验位，停止位，同步字符等</span><br><span class="hljs-code"></span><br>数据总线缓冲器<br><span class="hljs-code">	把8251和系统总线相连，在CPU执行输入/输出指令时，游数据总线缓冲器发送和接收数据</span><br><span class="hljs-code">	控制字，命令字和状态信息也通过数据总线缓冲区传输</span><br><span class="hljs-code"></span><br>读/写控制逻辑电路<br><br><span class="hljs-code">    接收写信号 /WR，并将来自数据总线的数据和控制字写入8251A</span><br><span class="hljs-code">    接收读信号 /RD，并将数据或状态字从8251A送往数据总线</span><br><span class="hljs-code">    - C//D：控制/数据信号；C//D   /WR   /RD三个信号组合起来通知8251A当前读写的是数据，控制字，还是状态字</span><br><span class="hljs-code">    - CLK：时钟信号</span><br><span class="hljs-code">    - RESET：复位信号</span><br><span class="hljs-code"></span><br>调制/解调控制电路<br><span class="hljs-code">	实现 8251A与调制/解调器的连接</span><br></code></pre></td></tr></table></figure>

<h3 id="8251A的发送和接收"><a href="#8251A的发送和接收" class="headerlink" title="8251A的发送和接收"></a>8251A的发送和接收</h3><h4 id="异步方式"><a href="#异步方式" class="headerlink" title="异步方式"></a>异步方式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">接收<br><br><span class="hljs-code">    在异步方式准备接收一个字符的时候，RxD就在线上检测低电平（没有检测的时候就是高电平），假如这个时候检测到了低电平，8251A就会以这个低电平作为起始位，并且启动内部定时计数器，当计数器到一半数位传输时间（比如初始设置时间脉冲为波特率的16倍），则定时器到第八个脉冲的时候，又重新对RxD进行取样，如果仍为低电平就确定是一个有效的起始位，（如果这个时候为高电平了，8251A会认为刚刚低电平是一个干扰信号，这个过程就重头开始了），8251就开始进行常规取样并进行字符装配（就是每隔一段时间对RxD进行采样）数据进入移位寄存器后（并进行去掉奇偶校验位和停止位），变成并行数据，在通过内部总线送到数据输入寄存器，同时发出RxRDY信号到CPU，表示外设的数据已经收到了，是可用的。对于少于八位的，高位自动填零</span><br><span class="hljs-code"></span><br>发送<br><br><span class="hljs-code">    当程序把TxEn（允许发送信号）和CTS#（清除请求发送信号，不懂的朋友再仔细看看上文）后就开始发送。在发送的时候，发送器自动添加1个起始位，再按照初始化的格式添加奇偶校验位，停止位。数据及起始位，校验位，停止位总是在发送时钟的TxC下降沿时发出</span><br></code></pre></td></tr></table></figure>
<h4 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">接收<br><br><span class="hljs-code">    其实和异步也差不多，就是RxD先进行搜索同步字符，找到第一个数据了，送到移位寄存器移位，然后和同步字符的内容进行比较，相等就是找到了，SYNRET=1；开始接收数据块，不相等就重新来（双同步也差不多，就是第一次找到了再来一次，第二次找不到重头开始找第一个字符）,如果是外同步的话，如果SYNDET=1；的时候，直接开始，RxD就不用找起始位了直接开始采样数据块。</span><br><span class="hljs-code">    实现同步之后，就利用时钟信号对RxD进行数据采样，送到移位寄存器移位，然后从RxRDY引脚发出一个信号，表示已经收到了一个字符，一旦CPU读完之后，这个RxRDY=0；</span><br><span class="hljs-code"></span><br>发送<br><br><span class="hljs-code">    发送也差不多，程序先对TxEN和CTS#初始化了，这个时候就开始发送，程序会先发1/2个同步字符，然后发送数据块，发送数据块的时候，发送器自动按初始化要求添加奇偶校验位（没有就不加）。如果8251正在发送的时候CPU来不及发送数据了（比如说遇到了中断之类的），那么就会重新发1/2个同步字符，等待CPU。满足了同步字符之间没有空隙。</span><br></code></pre></td></tr></table></figure>


<h2 id="3-8251A的对外信号"><a href="#3-8251A的对外信号" class="headerlink" title="3.8251A的对外信号"></a>3.8251A的对外信号</h2><h3 id="8251A和CPU之间的连接信号"><a href="#8251A和CPU之间的连接信号" class="headerlink" title="8251A和CPU之间的连接信号"></a>8251A和CPU之间的连接信号</h3><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/9.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="9"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br>片选信号<br><br><span class="hljs-code">	/CS：CS#，片选信号，由M/IO#和地址译码器得到</span><br><span class="hljs-code"></span><br>数据信号<br><br><span class="hljs-bullet">    -</span> D0-D7：D0-D7        数据传输信号<br><span class="hljs-code">    8251A的8根数据线D7-D0与8086的数据总线相连</span><br><span class="hljs-code"></span><br>读/写控制信号<br><br><span class="hljs-code">    /RD：RD# 读信号，CPU从8251A中读信息</span><br><span class="hljs-code">    /WD：WR# 写信号，CPU写入8251A</span><br><span class="hljs-code"></span><br><span class="hljs-code">    8251只有两个端口地址，数据端口是偶地址（输入输出是一个端口），控制信息是奇地址，在8086中是用A1来区分奇偶地址的，如果A1是0，就是偶地址，A1为1就是奇地址，这刚好和C/D#对应了，所以A1脚通常连接C/D#</span><br><span class="hljs-code"></span><br><span class="hljs-code">    | C//D    | /RD     | /WD     | 操作                   |</span><br><span class="hljs-code">    |—————————|—————————|—————————|————————————————————————|</span><br><span class="hljs-code">    | 0       | 0       | 1       | CPU从8251A输入数据      |</span><br><span class="hljs-code">    | 0       | 1       | 0       | CPU往8251A输出数据      |</span><br><span class="hljs-code">    | 1       | 0       | 1       | CPU读取8251A的状态      |</span><br><span class="hljs-code">    | 1       | 1       | 0       | CPU往8251A写入控制命令  |</span><br><span class="hljs-code"></span><br>收发联络信号<br><br><span class="hljs-bullet">    -</span> TXRDY：发送准备好信号，用来通知CPU，8251A已经准备好发送一个字符<br><br><span class="hljs-bullet">    -</span> TxRDY：发送器准备好，输出，high，表示发送器已经准备好了，这表示发送数据缓冲器空的（没空怎么发啊），CPU可以向8251A发送数据。如果用中断形式的话，这个TxRDY也可以做中断请求信号，如果是查询方式就不断查询它就完事了<br><br><span class="hljs-bullet">    -</span> TxE 发送空信号，输出，high，表示并串转化器为空（数据要经过并串转化器把并行数据转化成串行数据才能发送）。如果8251获得一个数据，TxE就为低。在同步方式下不允许字符串有间隔，但如果CPU来不及给8251A发送数据，则TxE就为1，插入同步字符<br><br><span class="hljs-bullet">    -</span> RxRDY，表示接受器准备好了，可以接受数据了，如果从外设接收到一个数据，等待CPU处理，当然也可以用中断了，把这个当成中断请求信号，程序查询就查他就完事了<br><br><span class="hljs-bullet">    -</span> SYNDET：同步检测信号（只用于同步方式）<br><span class="hljs-code">    		同步检测/断电检测信号，高有效，输出/输入 同步方式时表示同步检测，如果为内同步，作为输出，输出为1，表示找到同步字了；在外同步的时候，作为输入，变高后，在RxC#（接收器时钟）的下一个下降沿装配字符，在异步方式下，作为空白检测信号，输出，如果接收到全0的字符，输出高电平</span><br></code></pre></td></tr></table></figure>

<h3 id="8251A与外设的连接信号"><a href="#8251A与外设的连接信号" class="headerlink" title="8251A与外设的连接信号"></a>8251A与外设的连接信号</h3><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/3.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="3"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs markdwon">数据信号<br>    - TXD<br>    发送数据信号TXD用来输出数据，CPU送往8251A的并行数据转换为串行数据后，通过TXD送往外设<br>    - RXD<br>    接收数据信号RXD用来接收外设送来的串行数据，数据进入8251A后，转换为并行方式<br><br>和外设的联络信号<br>    - DTR#  数据终端准备好了，由8251A发给外设，表示CPU准备就绪<br>    - DER#  数据设备请求好了，由外设发给8251A，表示外设已经准备就绪<br>    - RTS#  请求发送信号，由8251A发送给外设，表示CPU已经准备好发送<br>    - CTS#  清除请求发送信号，由外设发送8251A，表示可以往外设发送数据<br>    - CLK          8251A的内部时序时钟，同步要求是波特率的30倍，异步的话要求波特率的4.5倍<br>    - TxC，发送时钟，输入，控制字符的发送速度，同步是等于字符传送的波特率，异步方式是初始化定义的<br>    - RxC，和TxC差不多，是控制接受端的接受速度<br><br>时钟、电源、地<br>    - CLK：用来产生8251A器间的内部时序<br>    - TXC:发送器时钟输入，用来控制发送字符的速度<br>    - RXC:接收器时钟输入，用来控制接收字符的速度<br>    - VCC<br>    - GND<br></code></pre></td></tr></table></figure>
<h2 id="4-编程"><a href="#4-编程" class="headerlink" title="4.编程"></a>4.编程</h2><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/4.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="4"></p>
<h3 id="8251A的初始化"><a href="#8251A的初始化" class="headerlink" title="8251A的初始化"></a>8251A的初始化</h3><p>8251A有一个奇一个偶两个端口地址；</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">偶地址端口对应数据输入寄存器和数据输出寄存器；<br>奇地址端口对应状态寄存器，模式寄存器，控制寄存器，同步字符寄存器<br></code></pre></td></tr></table></figure>

<h4 id="用偶地址端口时-A1-0"><a href="#用偶地址端口时-A1-0" class="headerlink" title="用偶地址端口时(A1&#x3D;0)"></a>用偶地址端口时(A1&#x3D;0)</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">写入：数据输入寄存器<br>读出：数据输出寄存器<br></code></pre></td></tr></table></figure>

<h4 id="用奇地址端口时（A1-1-8251A初始化的约定"><a href="#用奇地址端口时（A1-1-8251A初始化的约定" class="headerlink" title="用奇地址端口时（A1&#x3D;1)(8251A初始化的约定)"></a>用奇地址端口时（A1&#x3D;1)(8251A初始化的约定)</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">第一种描述方法（来自课本）<br><span class="hljs-code">    芯片复位以后，第一次用奇地址端口写入的值作为模式字送入模式寄存器</span><br><span class="hljs-code">    如果模式字中规定了8251A工作在同步模式，那么，CPU接着往奇地址端口输出的就是同步字符，同步字符被写入同步字符寄存器。如此前规定同步字符为两个，则会按先后次序分别写入第一个同步字符寄存器和第二个同步字符寄存器</span><br><span class="hljs-code">    此后，只要不是复位命令，不管是同步模式，还是异步模式，由CPU往奇地址端口写入的值都将作为控制字送到控制寄存器，而往偶地址端口写入的值将作为数据，送到数据发送缓冲器</span><br><span class="hljs-code"></span><br>第二种描述方法（来自网络）<br><span class="hljs-code">    芯片复位之后，第一次用奇地址写控制字，在控制字中规定是同步还是异步；</span><br><span class="hljs-code">    如果是同步方式，CPU会接着发1或者2个字节就是同步字符，写入同步字符寄存器，然后再把控制命令字写入奇端口；</span><br><span class="hljs-code">    如果是异步方式，CPU往奇端口输出的一个字就是命令控制字；</span><br><span class="hljs-code">    在相关命令设置好了之后，只要不复位，用奇端口写控制字，偶端口写的是数据，送到数据输出缓冲器中</span><br></code></pre></td></tr></table></figure>
<h4 id="地址说明"><a href="#地址说明" class="headerlink" title="地址说明"></a>地址说明</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 关于8位接口芯片和16位数据总线的连接问题<br><span class="hljs-bullet">    -</span> 8086CPU有一个必须遵守的约定，即低八位数据线总是与偶地址存储单元或端口关联；<br><span class="hljs-bullet">    -</span> 而高八位数据线总是与奇地址存储单元或端口关联；<br><span class="hljs-bullet">    -</span> 为了满足这一个要求，连接时在硬件上将总线的A1与8251A的C//D引脚相连接，而在软件设计的时候，用连续的偶地址代替端口的奇偶地址，就解决了8位接口芯片与16位数据总线的连接<br></code></pre></td></tr></table></figure>
<h4 id="初始化的概述"><a href="#初始化的概述" class="headerlink" title="初始化的概述"></a>初始化的概述</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 模式字决定了8251A将工作在同步模式还是异步模式，如果工作在同步模式，还会指出同步字符的个数是一个还是两个；同步字符被写入同步字符寄存器<br><span class="hljs-bullet">-</span> 如果是异步模式，则在设置完模式字后，接着便要设置控制字<br>控制字的主要含义相同，控制字就是各种控制命令，包括复位命令<br><span class="hljs-bullet">-</span> CPU向8251A发送控制字之后，8251A首先判断控制字是否为复位命令：如果是复位命令，则返回重新接收模式字；如果不是复位命令，则8251A开始进行数据传输。<br></code></pre></td></tr></table></figure>
<h3 id="模式寄存器的格式"><a href="#模式寄存器的格式" class="headerlink" title="模式寄存器的格式"></a>模式寄存器的格式</h3><p>模式字<strong>8位</strong></p>
<h4 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h4><p>需要考虑的量：停止位&#x2F;校验位&#x2F;校验允许位&#x2F;数据位的数目&#x2F;波特率因子</p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/5.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="5"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs markdown">（从高到低）<br>前两位是停止位的数目，00非法，01是1位，10是1.5位，11是2位停止位<br>第三位是EP（奇偶校验类型），0为奇校验，1为偶校验<br>第四位是有无校验，0是无，1是有<br>第五第六位是数据的大小，00是5位，01是6位，10是7位，11是8位<br>最后两位是决定波特率因子（不能是00，00就表示同步通信了），01表示波特率因子为1，10表示波特率因子为16，11表示波特率因子为64<br>举个例子，异步通信，1个停止位，无校验，8个数据位（刚好最近在做单片机的串口通信，这就是8N1格式）波特率因子为16，则应该向奇端口（假设还是FFF2H吧）写入01001110B，HEX格式为4EH、<br><span class="hljs-bullet">-</span> MOV DX,       FFFEH（端口地址）<br><span class="hljs-bullet">-</span> MOV AL, 4EH（模式字）<br><span class="hljs-bullet">-</span> OUT DX, AL<br><br><br>波特率<br>同步模式下，发送和接收的波特率分别和/TxC引脚，/RxC引脚上的输入时钟的频率相同<br>异步模式下，要用模式寄存器中的最低2位来确定波特率因子，<br>此时满足: /TxC引脚，/RxC引脚上的输入时钟的频率=波特率因子<span class="hljs-emphasis">*波特率</span><br></code></pre></td></tr></table></figure>
<h4 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h4><p>需要考虑的量:同步字符的数目&#x2F;同步方式&#x2F;奇偶校验&#x2F;奇偶校验允许位&#x2F;数据位的数目&#x2F;同步模式<br><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/8.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="8"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs markdown">（从高到低）<br>第一位是同步字符的位数，0是2个同步字符，1是1个同步字符<br>第二位决定是内同步还是外同步，0是内同步，1是外同步<br>第三位是奇偶校验位，0是奇校验，1是偶校验<br>第四位是有没有校验，0是没有校验，1是有校验<br>第五第六位是决定数据块的位数，00是5位，01是6位，10是7位，11是8位<br>最后两位必定是00<br>举个例子，比如说现在要求发送的是同步方式，1个同步字符外同步，偶校验，数据位是8位，那么初始化命令字就应该向奇端口（假如为FFF2H）写01111100B，换成16进制就是79H<br>汇编初始化就应该是<br><span class="hljs-bullet">-</span> MOV DX FFF2H<br><span class="hljs-bullet">-</span> MOV AL 79H<br><span class="hljs-bullet">-</span> OUT DX AL<br><span class="hljs-code">````</span><br><span class="hljs-code">### 控制寄存器的格式</span><br><span class="hljs-code"></span><br><span class="hljs-code">![6](https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/6.png)</span><br><span class="hljs-code">``` markdown</span><br><span class="hljs-code">从高到低</span><br><span class="hljs-code">第七位：检索同步字符，只用在内同步模式，为1时，8251A会对同步字符进行检索</span><br><span class="hljs-code">第六位：使8251A复位，从而重新进入初始化流程</span><br><span class="hljs-code">第五位：用来设置发送请求，此位置为1会使得/RTS引脚输出为低电平</span><br><span class="hljs-code">第四位：1将清楚状态寄存器中所有的出错指示位</span><br><span class="hljs-code">第三位：为1使得引脚TxD变为低电平，于是输出一个空白字符</span><br><span class="hljs-code">第二位：接收允许信号，在CPU从8251A接收数据前，先使此位为1</span><br><span class="hljs-code">第一位：DTR</span><br><span class="hljs-code">第零位：发送允许信号，只有将此位是1时，才能使数据从8251A接口往外设传输</span><br></code></pre></td></tr></table></figure>
<h3 id="状态寄存器的格式"><a href="#状态寄存器的格式" class="headerlink" title="状态寄存器的格式"></a>状态寄存器的格式</h3><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/7.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="7"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">当需要检测8251A的工作状态时，需要用到状态字。<br>状态字存放在状态寄存器中。<br></code></pre></td></tr></table></figure>

<h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><h3 id="异步模式下的初始化程序举例"><a href="#异步模式下的初始化程序举例" class="headerlink" title="异步模式下的初始化程序举例"></a>异步模式下的初始化程序举例</h3><p>设8251A工作在<strong>异步模式</strong>，波特率系数(因子)为16，7个数据位&#x2F;字符，偶校验，2个停止位，发送、接收允许，设端口地址为0042H。完成初始化程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;- 模式字：1111010B-&gt;FAH<br>;- 控制字：00110111B-&gt;37H (?)<br>;- 端口地址:对于CPU来说是偶地址，对于接口是奇地址<br><br>;- 初始化：<br>MOV AL,0FAH;送模式字<br>OUT 42H,AL ;异步方式，7位字符，偶校验,2个停止位  <br>MOV AL,37H;设置控制字，使发送、接收允许，清出错标志，使 /RTS和/DTR有效 <br>OUT 42H,AL ;送控制字<br></code></pre></td></tr></table></figure>


<h3 id="同步模式下初始化程序举例"><a href="#同步模式下初始化程序举例" class="headerlink" title="同步模式下初始化程序举例"></a>同步模式下初始化程序举例</h3><p>设端口地址为42H，采用内同步方式，2个同步字符（设同步字符为16H），偶校验，7位数据位&#x2F;字符 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;- 模式字00111000B 即38H<br>;- 控制字为：10010111B 即97H（？）。它使8251A对同步字符进行检索；同时使状态寄存器中的3个出错标志复位；此外，使8251A的发送器启动，接收器也启动；控制字还通知8251A，CPU当前已经准备好进行数据传输。 <br><br>;具体程序段如下：  <br>MOV AL，38H  ;设置模式字，同步模式，  用2个同步字符，<br>OUT 42H，AL   ; 7个数据位，偶校验<br>MOV AL，16H  <br>OUT 42H，AL   ;送同步字符16H<br>OUT 42H，AL    ;同步字符有两个一样的，因此送两次<br>MOV AL， 97H   ;设置控制字，使发送器和接收器启动<br>OUT 42H，AL<br></code></pre></td></tr></table></figure>
<h3 id="利用状态字进行编程的举例"><a href="#利用状态字进行编程的举例" class="headerlink" title="利用状态字进行编程的举例"></a>利用状态字进行编程的举例</h3><p>先对8251A进行初始化，然后对状态字进行测试，以便输入字符。本程序段用来输入80个字符。</p>
<p>分析：8251A的控制和状态端口地址为42H，数据输入和输出端口地址为40H。字符输入后，放在BUFFER标号所指的内存缓冲区中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;具体的程序段如下：<br>    MOV AL,0FAH <br>    OUT 42H,AL<br>    MOV AL,35H<br>    OUT 42H,AL<br>    MOV DI,0<br>    MOV CX,80<br>B：<br>    IN AL,42H<br>    TEST AL,02H<br>    JZ B  <br>    IN AL,40H<br>    MOV BX,OFFSET BUFFER<br>    MOV [BX+DI],AL<br>    INC DI<br>    IN AL,42H<br>    TEST AL,38H <br>    JNZ E<br>    LOOP B<br>    JMP EXIT<br>E： <br>    CALL ERR-OUT      <br>    EXIT:... ...<br></code></pre></td></tr></table></figure>


<h1 id="Ⅳ、并行接口和并行芯片"><a href="#Ⅳ、并行接口和并行芯片" class="headerlink" title="Ⅳ、并行接口和并行芯片"></a>Ⅳ、并行接口和并行芯片</h1><ul>
<li><p>并行通信就是把一个字符的各位用几条线同时进行传输；</p>
</li>
<li><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/10.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="10"></p>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 控制寄存器<br><br><span class="hljs-bullet">	-</span> - 用来接收CPU的控制命令<br><br><span class="hljs-bullet">-</span> 状态寄存器<br><br><span class="hljs-bullet">	-</span> - 提供各种状态位供CPU查询<br><br><span class="hljs-bullet">-</span> 输入缓冲寄存器<br><br><span class="hljs-bullet">-</span> 输出缓冲寄存器<br><br></code></pre></td></tr></table></figure>


<h1 id="Ⅴ、8255A"><a href="#Ⅴ、8255A" class="headerlink" title="Ⅴ、8255A"></a>Ⅴ、8255A</h1><p>可编程并行通信接口8255A</p>
<h2 id="1-8255A的内部结构"><a href="#1-8255A的内部结构" class="headerlink" title="1.8255A的内部结构"></a>1.8255A的内部结构</h2><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/11.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="11"></p>
<h3 id="①数据端口A-B-C"><a href="#①数据端口A-B-C" class="headerlink" title="①数据端口A,B,C"></a>①数据端口A,B,C</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> Port A<br><span class="hljs-code">    端口A具有一个8位数据输入锁存器和一个数据输出锁存器/缓冲器；</span><br><span class="hljs-code">    用端口A做输入口或输出口时，数据均受到锁存</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">-</span> Port B<br><span class="hljs-code">    端口B具有一个8位数据输入缓冲器和一个数据输出锁存器/缓冲器；</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">-</span> Port C<br><span class="hljs-code">    端口C具有一个8位数据输入缓冲器和一个数据输出锁存器/缓冲器，一般作为控制或状态信息端口</span><br><span class="hljs-code">    当端口C作为输入口时，对数据不锁存</span><br><span class="hljs-code">    当端口C作为输出口时，对数据进行锁存</span><br><span class="hljs-code"></span><br>使用中，A，B口为两个独立的数据输入输出端口，C口配合A口和B口的工作<br>C口常常通过控制命令被分成2个四位的端口，分别用来为端口A和B提供控制信号和状态信号<br></code></pre></td></tr></table></figure>

<h3 id="②A组控制和B组控制"><a href="#②A组控制和B组控制" class="headerlink" title="②A组控制和B组控制"></a>②A组控制和B组控制</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">控制端口A与端口C的高4位（PC7-PC4）<br>控制端口B与端口C的低4位（PC3-PC0）<br></code></pre></td></tr></table></figure>

<h3 id="③读-写控制逻辑电路"><a href="#③读-写控制逻辑电路" class="headerlink" title="③读&#x2F;写控制逻辑电路"></a>③读&#x2F;写控制逻辑电路</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">功能：管理数据传输过程。<br><br>CS#-片选信号<br><br>A0、A1-端口选择信号<br><br>RD#-读信号<br><br>WR#-写信号<br><br>RESET-复位信号<br><br>读写控制逻辑：接收/CS信号以及来自地址总线的选择端口信号（A2 A1），还接收控制总线的信号/WR,/RD,REST，并将其组合成A和B组的控制信号<br></code></pre></td></tr></table></figure>


<h3 id="④数据总线缓冲器"><a href="#④数据总线缓冲器" class="headerlink" title="④数据总线缓冲器"></a>④数据总线缓冲器</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">双向三态的8位数据缓冲器，8255A正是通过它与系统数据总线相连<br></code></pre></td></tr></table></figure>

<h2 id="2-芯片引脚信号"><a href="#2-芯片引脚信号" class="headerlink" title="2.芯片引脚信号"></a>2.芯片引脚信号</h2><h3 id="和外设相连的信号"><a href="#和外设相连的信号" class="headerlink" title="和外设相连的信号"></a>和外设相连的信号</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">PA0－PA7：A口的8条输入输出信号线。<br>PB0－PB7：B口的8条输入输出信号线。<br>PC0－PC7：C口的8条输入输出信号线。<br></code></pre></td></tr></table></figure>

<h3 id="和CPU相连的信号"><a href="#和CPU相连的信号" class="headerlink" title="和CPU相连的信号"></a>和CPU相连的信号</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">D0－D7：双向数据信号线。和系统总线相连<br>/RD：读信号线。<br>/WR：写信号线。<br>/CS：片选信号线。当片选信号有效时，读信号和写信号才对8255A有效<br>A1、A0：口地址选择信号线。8255A有四个端口地址<br>00--A端口；01--B端口；10--C端口；11--控制口。<br>RESET：复位输入信号，复位时内部寄存器都被清除，同时，三个数据端口自动置为输入口<br></code></pre></td></tr></table></figure>

<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/12.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="12"></p>
<h3 id="端口地址举例说明"><a href="#端口地址举例说明" class="headerlink" title="端口地址举例说明"></a>端口地址举例说明</h3><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/13.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="13"></p>
<h2 id="3-控制字"><a href="#3-控制字" class="headerlink" title="3.控制字"></a>3.控制字</h2><p>控制字分为两类：各端口的方式选择控制字和C端口的按位置1&#x2F;置0控制字</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">控制字的D7位称为标识位<br>D7=1---&gt;方式选择控制字的标识符<br>D7=0---&gt;C端口的按位置1/置0控制字的标识符<br></code></pre></td></tr></table></figure>

<h3 id="方式选择控制字"><a href="#方式选择控制字" class="headerlink" title="方式选择控制字"></a>方式选择控制字</h3><p>方式选择控制字的格式</p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/14.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="14"></p>
<p>说明</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">8255A的[三种工作方式]<br><span class="hljs-code">    方式0：基本的输入/输出方式</span><br><span class="hljs-code">    方式1：选通的输入/输出方式</span><br><span class="hljs-code">    方式2：双向传输方式</span><br><span class="hljs-code"></span><br>端口A可以工作在三种工作方式的任意一种，端口B只能工作在方式0或方式1，端口C则常配合端口A和B的工作，为这两个端口的输入/输出提供控制信号和状态信号<br>归为同一组的两个端口可以分别工作在输入或输出方式，不要求其工作同输入或输出<br></code></pre></td></tr></table></figure>



<h3 id="端口C置1-置0控制字"><a href="#端口C置1-置0控制字" class="headerlink" title="端口C置1&#x2F;置0控制字"></a>端口C置1&#x2F;置0控制字</h3><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/15.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="15"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">○ 8255A的端口C的各位均可用置1/置0控制字单独设置，因此C端口很适合做控制位使用<br>○ 当8255A收到控制字时，就对最高位即标识位进行检测，D7=1，将此字节作为方式选择控制字写入控制寄存器，D7=0，将此字节作为端口C置1/置0控制字<br>○ C端口的按位置1/置0控制字注意：<br><span class="hljs-code">    § C端口的按位置1/置0控制字尽管时对C端口进行操作，但必须写入控制端口，而不是写入C端口</span><br><span class="hljs-code">    § D0位决定置1或置0 ，D0=0置0; D0=1置1</span><br><span class="hljs-code">    § D3、D2、D1位决定了对C端口中的哪一位操作 </span><br><span class="hljs-code">    § D4 5 6无影响</span><br><span class="hljs-code">    § D7位必须为0 </span><br></code></pre></td></tr></table></figure>



<h2 id="4-工作方式"><a href="#4-工作方式" class="headerlink" title="4.工作方式"></a>4.工作方式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">方式0：基本输入输出方式	适用于无条件传送和查询方式的接口电路（传输方式转8086页面）<br>方式1：选通输入输出方式	适用于查询和中断方式的接口电路<br>方式2：双向选通传送方式	适用于双向传送数据的外设	适用于查询和中断方式的接口电路<br></code></pre></td></tr></table></figure>

<h3 id="①方式0"><a href="#①方式0" class="headerlink" title="①方式0"></a>①方式0</h3><p>基本的输入&#x2F;输出方式</p>
<p>特点</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> PA和PB可通过方式选择控制字规定为输入或者输出端口- PC分为两个四位端口，高四位一个端口，第四位一个端口；这两个四位端口，也可以通过方式选择控制字规定为输入或输出端口端口可作为输入口，也可作为输出口，各端口之间没有规定必然的联系。可以有16种不同的组合，适用于多种不同的场合。 <br><br><br>8255A中方式0对输出进行锁存（和总线相连肯定要锁存的），输入不锁存<br>8255A中没有时钟输入信号，所有的时序都是由引脚控制信号定时的<br>当CPU执行IN指令的时候，产生RD#信号，控制8255A从端口读取外设的输入数据，然后从D0-D7中输入到CPU<br>当CPU执行OUT指令的时候，产生WD#信号，完成CPU从端口向外传输数据<br></code></pre></td></tr></table></figure>

<p>时序</p>
<p>输入（CPU从8255A读取数据）时序要求</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">发出读信号前，先发出地址信号，从而使得8255A的片选信号和端口选择信号A1         A0有效，于是启动8255A输入数据要领先于读信号（要求在CPU发出读信号之前，外设已经将数据送到8255A的输入缓冲器中） <br></code></pre></td></tr></table></figure>

<p>输出（将数据有效传输到8255A）时序要求</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">略<br></code></pre></td></tr></table></figure>

<p>应用</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">用于连接简单外设。适用于：（1）无条件输入输出方式。（2）查询输入输出方式：A、B口作为8位数据的输入或输出口，C口的高/低4位分别定义为A、B口的控制位和状态  位，作为A（B）的应答信号。应答信号不固定，可自由定义应用实例：作为主机和打印机的接口<br></code></pre></td></tr></table></figure>



<h3 id="②方式1"><a href="#②方式1" class="headerlink" title="②方式1"></a>②方式1</h3><p>选通的输入&#x2F;输出方式</p>
<p>特点</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> PA和PB用方式1进行输入/输出，端口C自动提供选通信号和应答信号<br><span class="hljs-bullet">-</span> PA和PB端口只有一个工作在方式1，那么PC一个端口中有3位被规定为配合方式1工作的信号，PC的另一个端口可以工作在方式0，PC的其他位以可工作在方式0，即作为输入/输出<br><span class="hljs-bullet">-</span> PA和PB都工作在方式1，那么PC中就需要6位用来作为配合方式1工作的信号，剩下的两位可以作为输入和输出<br><br><br><br><br>方式1是单方向的输入/输出工作模式<br><br>将3个端口分成两组，端口A和B可以两个数据口，分别工作在方式1，而端口C用来配合端口A和B在方式1下进行工作，作为选通信号<br><br>注：<br><br>A口工作于方式1输入，固定用PC5-PC3作联络信号线；<br><br>A口工作在方式1输出的时候，PC7，PC6和PC3作为选通信号<br><br>B口工作于方式1输入输出的时候，固定用PC2-PC0作联络信号线。<br><br>如果AB都用方式1进行传输，C口剩下的两位可以工作在方式0下<br></code></pre></td></tr></table></figure>

<p>时序</p>
<p>输入信号和输入时序</p>
<p> <img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/16.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="16"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">所用到的控制信号的定义如下：<br><br>  ① STB为低电平有效的输入选通信号，由外设提供的输入信号，当它有效时，把输入装置来的数据送入输入锁存器。<br><br>  ② IBF为高电平有效的输入缓冲器满信号，通知外设送来的数据已被接收，由STB信号的前沿产生。当CPU用输入指令读走数据后，此信号被清除。 <br><br>  ③ INTR为中断请求信号，高电平有效。CPU响应中断请求后在服务程序中读走数据时，由RD信号将其清除。<br><br>  ④ INTE为中断允许状态，可事先用位控方式写入。<br></code></pre></td></tr></table></figure>

<p>输出信号和输出时序</p>
<p> <img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/17.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="17"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">当CPU相应了8255的中断后，发出WD#信号，输出数据到锁存器中。输送完了之后，WD有效的时候，打开OBF#为0，缓冲器满，告诉CPU不要写数据到8255A了，（OBF#也是外设的选通信号）同时INTR为0（已经响应了中断）。当外设读完了数据，WD为1，发送响应信号ACK#，ACK#的上升沿也把OBF置为1，缓冲器空，INTR为1，发送下一个中断，可以读下一个数据了<br></code></pre></td></tr></table></figure>



<p>应用</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br></code></pre></td></tr></table></figure>



<h3 id="③方式2"><a href="#③方式2" class="headerlink" title="③方式2"></a>③方式2</h3><p>双向传输方式</p>
<p>特点</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">方式2将方式1的选通输入输出功能组合成一个双向数据端口，可以发送数据和接收数据；只有端口A可以工作于方式2，需要利用端口C的5个信号线，其作用与方式1相同；方式2的数据输入过程与方式1的输入方式一样；方式2的数据输出过程与方式1的输出方式有一点不同：数据输出时8255A不是在OBF#有效时向外设输出数据，而是在外设提供响应信号ACK#时才送出数据<br><br>当A端口工作方式2的时候（需要PC3-PC7），B口还可以工作在方式1（需要PC0-PC2）和方式0（PC0-PC2可以在方式0啦）<br></code></pre></td></tr></table></figure>

<p>时序</p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/18.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="18"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">如果A口外设输入数据到8255中的时候，STB#有效，外设数据输入到A的PA0-PA7，输完数据后，STB为1，同时IBF为1，触发中断，INTR为1，CPU响应中断，发出IN指令，RD为0，当RD有效的时候，INTR为0（表示已经响应了中断），数据传输到数据总线中，读完后，INFA为0，继续开始读取数据<br><br>如果8255发送了一个中断，CPU响应了中断，发出WR#信号，数据从总线中到锁存器中，在WR有效的时候清除INTR（响应了中断）。同时让OBFA为0（PC7），告诉外设要读数据了，外设读完后发出响应信号ACK#，ACK上升沿恢复为1的时候，触发OBFA为1，又触发了中断<br><br>注意，由于A口的输入锁存器和输出锁存器是互相独立的，故当CPU向A口输出数据时，外部设备也可同时向A口输入数据。反之亦然。<br></code></pre></td></tr></table></figure>
<p>应用</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">磁盘驱动器<br></code></pre></td></tr></table></figure>



<h2 id="5-应用举例"><a href="#5-应用举例" class="headerlink" title="5.应用举例"></a>5.应用举例</h2><h1 id="Ⅵ、8259A"><a href="#Ⅵ、8259A" class="headerlink" title="Ⅵ、8259A"></a>Ⅵ、8259A</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">中断控制器的功能：<br><span class="hljs-code">    接收外部的中断请求，进行判断，选中优先级最高的中断请求，送到CPU的INTR端；CPU响应中断进入中断子程序时，负责对外部中断请求管理，可实现中断嵌套。</span><br><span class="hljs-code"></span><br>8259A的工作特点： <br><br><span class="hljs-code">    ① 能管理8级中断，可与其它8个8259A芯片组成主从式中断系统，实现64级中断源控制；</span><br><span class="hljs-code"></span><br><span class="hljs-code">    ② 可编程使用，非常灵活；</span><br><span class="hljs-code"></span><br><span class="hljs-code">    ③ 只需一组5V电源。</span><br></code></pre></td></tr></table></figure>

<h2 id="1-外部信号和含义"><a href="#1-外部信号和含义" class="headerlink" title="1.外部信号和含义"></a>1.外部信号和含义</h2><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/19.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="19"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs markdown">① D7～D0 数据线：在系统中，他们和数据总线相连<br><br>② INT 中断请求信号：和CPU的INTR端相连，向CPU发送中断请求<br><br>③ INTA# 中断应答信号：接收来自CPU的中断应答信号，如果CPU接收到中断请求信号，而此时中断允许位标志为1，并且正好一条指令执行完毕，那么在当前总线周期和下一个总线周期中，CPU将在/TNTA引脚上分别分发一个负脉冲作为中断响应信号，在第二个/INTA脉冲结束时，CPU读取8259A送到数据总线上的中断类型号<br><br>④ RD# 读出信号：将8259A某个内部寄存器的内容送达数据总线<br><br>⑤ WR# 写入信号：使8259A从数据总线上接收数据<br><br>⑥ CS# 片选信号<br><br>⑦ A0 端口选择信号：8259A有两个端口地址，一个为奇地址，一个为偶地址，奇地址较高，偶地址较低<br><br>⑧ IR7～IR0 I/O中断请求信号：与IO设备相连或者说连接从片的INT引脚，接收其中断请求<br><br>⑨ CAS2～CAS0 从片选择信号<br><br>⑩ SP#/EN# 主片和从片的选择和驱动信号<br><br><span class="hljs-code">    /SP//EN：双功能引脚</span><br><span class="hljs-code"></span><br><span class="hljs-code">    （1）输出，低电平有效</span><br><span class="hljs-code"></span><br><span class="hljs-code">        8259A工作在缓冲方式时，该引脚输出低电平控制信号，用来使能系统总线与8259A数据引脚之间的数据缓冲器，使中断向量码能在第二个INTA周期正常从8259A输出。</span><br><span class="hljs-code"></span><br><span class="hljs-code">    （2）输入</span><br><span class="hljs-code"></span><br><span class="hljs-code">        当8259A工作在主从级联方式时，该引脚为输入：</span><br><span class="hljs-code"></span><br><span class="hljs-code">        SP=1，设定8259A为主片；</span><br><span class="hljs-code"></span><br><span class="hljs-code">        SP=0，设定8259A为从片</span><br><span class="hljs-code">        </span><br><span class="hljs-code">        </span><br></code></pre></td></tr></table></figure>





<h2 id="2-编程结构和工作原理"><a href="#2-编程结构和工作原理" class="headerlink" title="2.编程结构和工作原理"></a>2.编程结构和工作原理</h2><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/20.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="20"></p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/22.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="22"></p>
<h3 id="组成-2"><a href="#组成-2" class="headerlink" title="组成"></a>组成</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs markdown">控制部分——7个寄存器（八位的寄存器）<br><br>   初始化命令字ICW（1-4）<br>   	功能：决定8259A的工作方式<br><span class="hljs-code">        通常是在计算机系统启动时在初始程序设置，一旦设定，一般在系统工作过程不再改变。</span><br><span class="hljs-code">   操作命令字OCW（1-3）</span><br><span class="hljs-code">       功能:在应用程序中设定，动态地控制CPU处理中断的过程</span><br><span class="hljs-code">       中断屏蔽寄存器IMR（OCW1）</span><br><span class="hljs-code">       保存对中断请求信号IR的屏蔽状态,Di位为1表示IRi中断被屏蔽（禁止）；为0表示允许</span><br><span class="hljs-code"></span><br>处理部件（8位的寄存器）<br><br>   功能：接收和处理从IR0-IR7进入的中断<br><span class="hljs-bullet">   -</span> IRR——中断请求寄存器<br><span class="hljs-code">       保存8个外界中断请求信号IR0～IR7的请求状态</span><br><span class="hljs-code">       - Di位为1表示IRi引脚有中断请求；为0表示无请求</span><br><span class="hljs-code">       </span><br><span class="hljs-code">   - PR——中断优先级裁决器</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">   -</span> ISR——当前中断服务寄存器<br><span class="hljs-code">       保存正在被8259A服务着的中断状态</span><br><span class="hljs-code">       Di位为1表示IRi中断正在服务中；为0表示没有被服务</span><br></code></pre></td></tr></table></figure>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/21.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload></p>
<p>（1）接收、处理外设中断申请，决定是否向CPU发中断申请信号。<br>（2）若CPU响应中断，则在CPU中断响应周期送出中断类型号。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">中断请求寄存器IRR接收外部中断请求，IRR有8位，分别和引脚IR7-IR0相对应;<br>接收来自某一引脚的中断请求后，IRR寄存器的对应位置便置1，即对此中断请求锁存;<br>此后，逻辑电平根据中断屏蔽寄存器IMR中对应位决定时候让此请求通过;<br>决定IRR中的中断申请是否进入优先级裁决器PR。<br><span class="hljs-code">    IMR对应位为0，允许中断申请进入优先级裁决器，</span><br><span class="hljs-code">    IMR对应位为1，不允许进入，中断申请被IMR屏蔽。</span><br></code></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">中断优先级裁决器PR把新进入的中断请求和当前正在处理的中断比较，从而决定哪一个优先级更高<br>当前中断服务寄存器 ISR 记录CPU正在响应的中断。<br><span class="hljs-bullet">-</span> ISR中的某位为1，表示CPU正在响应此级中断，即正在执行此中断源的中断子程；<br><span class="hljs-bullet">-</span> ISR中的某位为 0，表示CPU没有或已响应完此级中断，即不在执行此中断源的中断子程<br><br>如果进入的中断申请比ISR中记录的中断优先级高，则通过8259A的INT引脚 CPU发出中断请求信号；<br>如果进入的中断申请不比 ISR 中记录的中断优先级高，     同级或低级，则不向 CPU 发中断请求信号。<br></code></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">如果CPU的中断允许标志位IF为1,那么CPU执行完当前指令后，就可响应中断，这时，CPU从/INTA端往8259A送出两个负脉冲:<br><br><br>第一个负脉冲到达时，8259A完成三个动作<br><span class="hljs-bullet">    -</span> 使IRR锁存功能失效。对IR7-IR0线上的中断请求信号就不再接收；直到第二个负脉冲到达时，才使IRR锁存功能有效<br><span class="hljs-bullet">    -</span> 使当前中断服务服务器ISR中的相应位置1，以便中断优先级裁决寄存器以后的工作提供判断依据<br><span class="hljs-bullet">    -</span> 使IRR寄存器中的相应位清零（之前接收中断请求时设置的1，现在需要清零）<br><br><br>第二个负脉冲到达时，8259A完成两个动作<br><span class="hljs-bullet">    -</span> 将中断类型寄存器中的内容ICW2送到数据总线的D7-D0，CPU将此作为中断类型号<br><span class="hljs-bullet">    -</span> 如ICW4中的中断自动结束位为1，则将当前中断服务寄存器ISR的相应位清零<br></code></pre></td></tr></table></figure>
<h2 id="3-工作方式"><a href="#3-工作方式" class="headerlink" title="3.工作方式"></a>3.工作方式</h2><h3 id="设置优先级的方式"><a href="#设置优先级的方式" class="headerlink" title="设置优先级的方式"></a>设置优先级的方式</h3><h4 id="全嵌套方式"><a href="#全嵌套方式" class="headerlink" title="全嵌套方式"></a>全嵌套方式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">最常用的方式<br><br>8259A的中断优先权顺序固定不变，从高到低依次为IR0、IR1、IR2、……IR7。0级优先级最高<br>中断请求后，8259A对当前请求中断中优先权最高的中断IRi予以响应，将其中断类型码送上数据总线，对应ISR的Di位置位，直到中断结束（ISR的Di位复位）。<br>在ISR的Di位置位期间，禁止再发生同级和低级优先权的中断，但允许高级优先权中断的嵌套。<br></code></pre></td></tr></table></figure>
<h4 id="特殊全嵌套方式"><a href="#特殊全嵌套方式" class="headerlink" title="特殊全嵌套方式"></a>特殊全嵌套方式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">与全嵌套方式基本相同，只有一点不同：当处理某一级中断时，如果有同级的中断请求，也会给予响应。<br><br>特殊全嵌套方式一般用在8259A级联系统中。<br><br>一方面，CPU对于优先级别较高的主片的中断输入是允许的；<br>另一方面，CPU对于来自同一从片的优先级别较高（但对于主片来讲，优先级别是相同的）的中断也是允许、能够响应的。<br></code></pre></td></tr></table></figure>
<h4 id="优先级自动循环方式"><a href="#优先级自动循环方式" class="headerlink" title="优先级自动循环方式"></a>优先级自动循环方式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">适用场合：系统中多个中断源优先级相等。<br>初始优先级队列规定为：IR0~IR7。从IR0～IR7引入的中断轮流具有最高优先权。当任何一级中断被处理完，它的优先级别就被改变为最低，而最高优先级分配给该中断的下一级中断。<br>例如：现正为IR3引入的中断服务，若服务完毕，IR3为最低优先级，IR4有最高优先级，优先级顺序为 IR4,IR5,IR6,…IR2,IR3。<br>优先级自动循环方式——由OCW2决定<br></code></pre></td></tr></table></figure>
<h4 id="优先级特殊循环方式"><a href="#优先级特殊循环方式" class="headerlink" title="优先级特殊循环方式"></a>优先级特殊循环方式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">与优先级自动循环方式相比，只有一点不同：初始优先级是由编程决定的。<br>例如：编程确定IR5为最低优先级，则IR6为最高优先级，初始优先级顺序为IR6,IR7,IR0…IR4,IR5。<br>优先级特殊循环方式——由OCW2决定<br></code></pre></td></tr></table></figure>
<h3 id="屏蔽中断源的方式"><a href="#屏蔽中断源的方式" class="headerlink" title="屏蔽中断源的方式"></a>屏蔽中断源的方式</h3><h4 id="普通屏蔽方式"><a href="#普通屏蔽方式" class="headerlink" title="普通屏蔽方式"></a>普通屏蔽方式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">8259A的每个中断请求输入端都可通过对应屏蔽位的设置而被屏蔽<br><br>将OCW1（IMR）的Di位置1，则对应的中断IRi被屏蔽，该中断请求不能从8259A送到CPU。<br>如果OCW1（IMR）的Di位置0，则允许IRi中断产生。<br>撤销屏蔽：可以再程序中根据需要设置OCW1（IMR）寄存器的值。<br></code></pre></td></tr></table></figure>
<h4 id="特殊屏蔽方式"><a href="#特殊屏蔽方式" class="headerlink" title="特殊屏蔽方式"></a>特殊屏蔽方式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">将OCW1（IMR）的Di位置1，对应的中断IRi被屏蔽的同时，使ISR的Di位置0；<br>开放了其他级别较低的中断。<br><br>特殊屏蔽是在中断处理程序中使用的，用了这种方式之后，尽管系统正在处理高级中断，但对外界来讲，只有同级中断被屏蔽，而允许其它任何级别的中断请求。<br>应用场合： 一个中断服务程序的运行过程中，需要动态地改变系统中的中断优先级结构，即：在中断处理的一部分，禁止低级中断嵌套；而在中断处理的另一部分，允许低级中断嵌套<br></code></pre></td></tr></table></figure>
<h3 id="结束中断处理的方式"><a href="#结束中断处理的方式" class="headerlink" title="结束中断处理的方式"></a>结束中断处理的方式</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">中断结束是什么：<br><br>CPU响应某级中断后，8259A自动将ISR的对应位置1，如果CPU已执行完中断子程，而ISR中的对应位仍为1,8259A的优先级裁决器仍会据ISR的内容做裁决，从而会屏蔽同级或低级的中断申请。在中断响应后，对 ISR中相应位的清0很重要，  它是8259A认为中断结束的标志。<br></code></pre></td></tr></table></figure>
<h4 id="中断自动结束方式"><a href="#中断自动结束方式" class="headerlink" title="中断自动结束方式"></a>中断自动结束方式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">适用于系统中只有一片8259A且多个中断不会嵌套的情况。<br>系统进入中断过程，8259A就自动将当前中断服务寄存器中对应位ISn清除。<br>方法：ICW4中AEOI位为1。<br></code></pre></td></tr></table></figure>
<h4 id="中断一般结束方式"><a href="#中断一般结束方式" class="headerlink" title="中断一般结束方式"></a>中断一般结束方式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">配合全嵌套优先权方式使用。<br>当CPU用输出指令往8259A发出一般中断结束命令（EOI）时，8259A就会把当前中断服务寄存器优先权最高的IS位复位。<br>方法:在程序中，往8259A的偶地址端口输出一个操作命令字OCW2,OCW2的EOD=1,SL=0,R=0z<br></code></pre></td></tr></table></figure>
<h4 id="特殊的中断结束方式"><a href="#特殊的中断结束方式" class="headerlink" title="特殊的中断结束方式"></a>特殊的中断结束方式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">配合非全嵌套方式使用。<br><span class="hljs-bullet">-</span> CPU在程序中向8259A发送一条特殊中断结束命令（SEOI），这个命令中指出了要清除哪个IS位。<br>方法：OCW2中的EOI=1,SL=1,R=0<br><br>8259A级联方式下，一般采用非自动结束方式。CPU应发出两个中断结束命令，一个送主8259A，用来将其主8259A的ISR寄存器相应位清“0”；另一个送从8259A，用来将其从8259A中的ISR寄存器相应位清“0”。<br></code></pre></td></tr></table></figure>
<h3 id="连接系统总线的方式"><a href="#连接系统总线的方式" class="headerlink" title="连接系统总线的方式"></a>连接系统总线的方式</h3><h4 id="缓冲方式"><a href="#缓冲方式" class="headerlink" title="缓冲方式"></a>缓冲方式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">8259A的数据线需加总线驱动器予以驱动。<br>8259A把 SP#/EN#       引脚作为输出端，输出允许信号（低电平），作为总线驱动器的启动信号。<br><br>由ICW4设置<br></code></pre></td></tr></table></figure>
<h4 id="非缓冲方式"><a href="#非缓冲方式" class="headerlink" title="非缓冲方式"></a>非缓冲方式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">8259A直接与数据总线相连。<br><span class="hljs-bullet">-</span> SP#/EN#引脚为输入端。<br>若8259A级联，由其确定是主片（SP#/EN#       为高）或从片 （SP#/EN# 为低）。<br><br>由ICW4设置<br></code></pre></td></tr></table></figure>
<h3 id="引入中断请求方式"><a href="#引入中断请求方式" class="headerlink" title="引入中断请求方式"></a>引入中断请求方式</h3><h4 id="边沿触发方式"><a href="#边沿触发方式" class="headerlink" title="边沿触发方式"></a>边沿触发方式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">8259A将中断请求输入端出现的上升沿作为中断请求信号。<br><br><span class="hljs-bullet">-</span> ICW1设置<br></code></pre></td></tr></table></figure>
<h4 id="电平触发方式"><a href="#电平触发方式" class="headerlink" title="电平触发方式"></a>电平触发方式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">中断请求端出现的高电平是有效的中断请求信号。<br><br><span class="hljs-bullet">-</span> ICW1设置<br></code></pre></td></tr></table></figure>
<h4 id="中断查询方式"><a href="#中断查询方式" class="headerlink" title="中断查询方式"></a>中断查询方式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">中断查询方式的特点：<br><span class="hljs-bullet">    -</span> 8259A不使用INT向CPU发中断请求信号。<br><span class="hljs-bullet">    -</span> CPU内部的中断允许触发器复位，禁止外部对CPU的中断请求。<br><span class="hljs-bullet">    -</span> CPU要使用软件查询来确认中断源。<br><br>查询软件：关中断、送查询命令、读取查询字。<br></code></pre></td></tr></table></figure>
<h2 id="4-初始化"><a href="#4-初始化" class="headerlink" title="4.初始化"></a>4.初始化</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">8259A的命令控制字包括两类<br><br>初始化命令字和操作命令字<br><br>初始化命令字：一般在系统复位后的初始化编程中设置，用于确定8259A的基本工作方式，设置以后一般保持不变<br><br>初始化编程：指系统在上电或复位后对可编程器件进行控制字设定的一段程序<br><br>操作命令字：是在初始化以后应用程序随时写入的，它实现对8259A的状态，中断方式和过程的动态控制，在工作中可随时写入操作命令字，以修改某些控制方式<br></code></pre></td></tr></table></figure>

<h3 id="初始化编程"><a href="#初始化编程" class="headerlink" title="初始化编程"></a>初始化编程</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">8259A开始工作前，必须进行初始化编程；<br>给8259A写入初始化命令字ICW。<br></code></pre></td></tr></table></figure>
<h3 id="中断操作编程"><a href="#中断操作编程" class="headerlink" title="中断操作编程"></a>中断操作编程</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">在8259A工作期间；<br>可以写入操作命令字OCW将选定的操作传送给8259A，使之按新的要求工作；<br>还可以读取8259A的信息，以便了解它的工作状态。<br></code></pre></td></tr></table></figure>
<h2 id="5-初始化命令字"><a href="#5-初始化命令字" class="headerlink" title="5.初始化命令字"></a>5.初始化命令字</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">8259A有两个连续的端口地址<br>偶地址较低，奇地址较高<br><br>初始化命令字ICW1～ICW4必须按照顺序填写；<br><span class="hljs-bullet">-</span> ICW1写入偶地址端口，ICW2～ICW4写入奇地址端口。<br></code></pre></td></tr></table></figure>
<h3 id="ICW1-（芯片控制初始化命令字）"><a href="#ICW1-（芯片控制初始化命令字）" class="headerlink" title="ICW1:（芯片控制初始化命令字）"></a>ICW1:（<em>芯片控制初始化命令字</em>）</h3><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/23.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="23"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> A0=0 偶地址端口<br><span class="hljs-bullet">-</span> D7       D6 D5 ：8086系统中不使用，设置1和0都可以<br><span class="hljs-bullet">-</span> D4：D4=1，作为OCW1的标识位，用与区分OCW2和OCW3，因为二者也是写到偶地址端口的<br><span class="hljs-bullet">-</span> D3：设置中断请求方式。边沿触发/电平触发<br><span class="hljs-bullet">-</span> D2：8086系统中不使用，设置1和0都可以<br><span class="hljs-bullet">-</span> D1：规定单片或级联方式：SNGL＝1，单片方式；SNGL＝0，级联方式<br><span class="hljs-bullet">-</span> D0：8086系统中设置为1，用来指出后面还将要设置ICW4<br></code></pre></td></tr></table></figure>
<h3 id="ICW2（中断类型号初始化命令字）"><a href="#ICW2（中断类型号初始化命令字）" class="headerlink" title="ICW2（中断类型号初始化命令字）"></a>ICW2（中断类型号初始化命令字）</h3><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/24.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="24"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">中断类型号的高五位也就是ICW2的高五位，低三位的值则却决于引入中断的引脚序号<br> ICW2是任选的；一旦ICW2确定下来，IR0-IR7所对应的八个中断类型号也就确定了<br> ICW2高5位影响中断类型码，而中断类型码的低3位由IR0～IR7决定。<br><br>例：ICW2为20H，8259A的IR0-IR7的中断类型码为20H,21H,22H…,27H<br></code></pre></td></tr></table></figure>
<h3 id="ICW3（主片-从片初始化命令字）"><a href="#ICW3（主片-从片初始化命令字）" class="headerlink" title="ICW3（主片&#x2F;从片初始化命令字）"></a>ICW3（主片&#x2F;从片初始化命令字）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">系统中包含多片8259A时，才需要ICW3。<br>由ICW1的D1位（SNGL）指示，SNGL=0时，才需要设置ICW3。<br></code></pre></td></tr></table></figure>
<p>如是主片,则ICW3的格式如下： </p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/25.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="25"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">IRi＝1说明对应的IRi引脚上接有从片；<br><br>IRi＝0则表示IRi没有连接从片<br></code></pre></td></tr></table></figure>
<p>如是从片，则ICW3的格式如下： </p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/26.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="26"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">ID2～ID0编码说明从片INT引脚接到主片哪个IR引脚<br></code></pre></td></tr></table></figure>
<h3 id="ICW4（方式控制初始化命令字）"><a href="#ICW4（方式控制初始化命令字）" class="headerlink" title="ICW4（方式控制初始化命令字）"></a>ICW4（方式控制初始化命令字）</h3><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/27.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="27"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> ICW1的第D0位为1时，才写入ICW4；<br>16位或32位系统必须设置ICW4。<br></code></pre></td></tr></table></figure>


<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> D7-D5:全为0，作为ICW4的标识码<br><br><span class="hljs-bullet">-</span> D4:嵌套方式:<br><br><span class="hljs-code">    特殊全嵌套方式（SFNM＝1）</span><br><span class="hljs-code">    普通全嵌套方式（SFNM＝0）</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">-</span> D3:数据线的缓冲方式：<br><br><span class="hljs-code">    缓冲方式（BUF＝1）</span><br><span class="hljs-code">    非缓冲方式（BUF＝0） </span><br><span class="hljs-code"></span><br><span class="hljs-bullet">-</span> D2:<br><br><span class="hljs-code">    BUF=0时,M/S#不起作用</span><br><span class="hljs-code"></span><br><span class="hljs-code">    BUF=1时主片/从片选择：</span><br><span class="hljs-code"></span><br><span class="hljs-code">    主片（M/S#=1）</span><br><span class="hljs-code">    从片（M/S#=0）</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">-</span> D1:中断结束方式：<br><br><span class="hljs-code">    自动中断结束（AEOI＝1）</span><br><span class="hljs-code">    非自动中断结束（AEOI＝0）</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">-</span> D0:微处理器类型：<br><br><span class="hljs-code">    16位或32位系统（mPM＝1）</span><br><span class="hljs-code">    8位系统8080/8085（mPM＝0）</span><br></code></pre></td></tr></table></figure>
<h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">8259A在进入工作之前，必须先使用初始化命令字将每片8259A进行初始化。8259A的初始化流程应该遵循固定的次序<br><br>① ICW1写入偶端口，ICW2～ICW4写入奇端口；<br><br>② ICW1～ICW4的设置次序固定；<br><br>③ ICW1和ICW2必须设置，ICW3和ICW4非必须 ；16位和32位系统中ICW4必须设置，多8259A级联时，ICW3要设置<br><br>④ 在级联时，主片和从片各设置ICW3；注意其ICW3的格式并不相同<br></code></pre></td></tr></table></figure>
<h2 id="6-操作命令字"><a href="#6-操作命令字" class="headerlink" title="6.操作命令字"></a>6.操作命令字</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">操作命令字是在应用程序中设置的<br><br>设置次序没用要求<br><br><span class="hljs-bullet">-</span> OCW1写入奇地址端口<br><br><span class="hljs-bullet">-</span> OCW2 OCW3写入偶地址端口<br></code></pre></td></tr></table></figure>
<h3 id="OCW1（中断屏蔽操作命令字）"><a href="#OCW1（中断屏蔽操作命令字）" class="headerlink" title="OCW1（中断屏蔽操作命令字）"></a>OCW1（中断屏蔽操作命令字）</h3><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/28.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="28"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">中断屏蔽操作命令字：内容写入中断屏蔽寄存器IMR<br><span class="hljs-bullet">-</span> Di＝Mi对应IRi为1禁止IRi中断；为0允许IRi中断。各位互相独立。<br></code></pre></td></tr></table></figure>
<h3 id="OCW2（优先级循环方式和中断结束方式操作命令字）"><a href="#OCW2（优先级循环方式和中断结束方式操作命令字）" class="headerlink" title="OCW2（优先级循环方式和中断结束方式操作命令字）"></a>OCW2（优先级循环方式和中断结束方式操作命令字）</h3><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/29.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="29"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> R、SL和EOI配合使用产生中断结束EOI命令和改变优先权顺序<br><span class="hljs-bullet">-</span> D4D3=00  为OCW2的标志位<br><span class="hljs-bullet">-</span> L2～L0的3位编码指定IR引脚 <br></code></pre></td></tr></table></figure>

<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/30.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="30"></p>
<h3 id="OCW3（状态操作命令字）"><a href="#OCW3（状态操作命令字）" class="headerlink" title="OCW3（状态操作命令字）"></a>OCW3（状态操作命令字）</h3><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/31.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="31"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">（1）设置和撤销特殊屏蔽方式<br><br>（2）设置中断查询方式<br><br>（3）设置对内部寄存器的读出命令<br></code></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> ESMM称为SMM的允许位<br><span class="hljs-bullet">    -</span> SMM为特殊屏蔽模式位<br><span class="hljs-bullet">    -</span> ESMM为特殊屏蔽模式允许位<br></code></pre></td></tr></table></figure>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/32.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="32"></p>
<p>P：查询方式位</p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/33.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="33"></p>
<p>RR RIS</p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/34.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="34"></p>
<h2 id="7-使用举例"><a href="#7-使用举例" class="headerlink" title="7.使用举例"></a>7.使用举例</h2><h1 id="Ⅶ、8253"><a href="#Ⅶ、8253" class="headerlink" title="Ⅶ、8253"></a>Ⅶ、8253</h1><h2 id="定时信号"><a href="#定时信号" class="headerlink" title="定时信号"></a>定时信号</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">一般来说，定时信号可用软件和硬件两种方法得到<br><br>软件定时:<br><br>根据所需要的时间常数来设计一个延时子程序；<br>当延时时间较长时，可循环该延时子程序<br><br>硬件定时<br><br>计数器/定时器：计数时不会占用CPU的资源<br></code></pre></td></tr></table></figure>

<h2 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/8253_1.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="8253_1"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br>计数器：在设置好计数初值（即定时常数）后，便开始减1计数，减为0时，输出一个信号<br><br><span class="hljs-section">计数器在减到0以后，输出一个信号便结束了，除非重新触发</span><br><span class="hljs-section">--------------------------------------------</span><br>定时器：在设置好定时常数后，便进行减1计数，并按定时常数不断地输出为时钟周期整数倍的定时间隔<br><br>定时器减到0以后，自动恢复初值重新奇数，并不断产生信号<br><br><br>3个独立的16位计数器通道；<br>共用1个控制寄存器和1个状态寄存器（只有8254有状态寄存器）。<br>每个计数器有6种工作方式；<br>按二进制或十进制（BCD码）计数。<br></code></pre></td></tr></table></figure>


<h2 id="编程结构"><a href="#编程结构" class="headerlink" title="编程结构"></a>编程结构</h2><p>8253 内部没有状态寄存器</p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/8253_2.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="8253_2"></p>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br>8253内部有三个计数器：计数器0，计数器1，计数器2，其结构完全相同<br><br>每个计数器的输入和输出都决定于设置控制寄存器中的控制字，他们共用一个控制寄存器，但相互之间完全独立<br><br>内部结构<br><br><span class="hljs-code">    三个引脚：时钟输入CLK,门控信号输入端GATE,输出端OUT</span><br><span class="hljs-code">    内部部件：16位计数初值寄存器CR,计数执行部件CE,输出锁存器OL</span><br><span class="hljs-code"></span><br><span class="hljs-code">    执行部件实际上就是一个16位的减法计数器，其起始值就是初值寄存器的值，初值寄存器的值是通过程序设置的</span><br><span class="hljs-code"></span><br><span class="hljs-code">    输出锁存器OL用来锁存计数执行部件CE的内容，从而使得CPU可对此进行读操作</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">    -</span> CE CR OL 都是十六位的寄存器，但也可用作为8位寄存器来用<br><br><span class="hljs-code">    计数器的工作方式决定于控制寄存器中的控制字</span><br></code></pre></td></tr></table></figure>

<h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br>\1. 设置8253\8254的工作方式；<br><br>\2. 设置计数初值到计数初值寄存器CR；<br><br>\3. 第一个CLK信号使计数初值寄存器的内容置入<br><br>计数执行部件CE；<br><br>\4. 以后每来一个CLK信号，CE减1； <br><br>\5. OUT端输出一特殊波形的信号；<br><br>注：以上计数过程中还受到GATE信号的控制。<br></code></pre></td></tr></table></figure>


<h2 id="外部信号"><a href="#外部信号" class="headerlink" title="外部信号"></a>外部信号</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> CLK0-CLK2：三个计数器的时钟信号<br><br><span class="hljs-bullet">-</span> GATE0-GATE2：三个计数器的门控信号<br><br><span class="hljs-bullet">-</span> OUT0-OUT2：三个计数器的输出信号<br><br><span class="hljs-bullet">-</span> A1,A0：地址线，对三个计数器和控制寄存器进行寻址<br><br><span class="hljs-code">        8253有四个端口地址</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">        -</span> A1A0=00,计数器0<br><span class="hljs-bullet">        -</span> A1A0=01，计数器1<br><span class="hljs-bullet">        -</span> A1A0=10，计数器2<br><span class="hljs-bullet">        -</span> A1A0=11，控制端口<br><br>/RD，/RD有效时，CPU对8253的输出锁存器进行读操作<br><br>/WR,/RD有效时，CPU对8253的一个计数器写入计数初值或对控制寄存器写入控制字<br><br><span class="hljs-bullet">-</span> CS：/CS有效时，/WR,/RD才会有效<br></code></pre></td></tr></table></figure>

<h2 id="控制寄存器与控制字"><a href="#控制寄存器与控制字" class="headerlink" title="控制寄存器与控制字"></a>控制寄存器与控制字</h2><p>8253内部的三个寄存器共用一个控制寄存器，通过对控制寄存器写入控制字，就可使得三个计数器处于不同的工作模式，控制端口是只写的；</p>
<h3 id="模式设置控制字"><a href="#模式设置控制字" class="headerlink" title="模式设置控制字"></a>模式设置控制字</h3><p>模式控制字：用来设置三个计数器的工作模式</p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/8253_3.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="8253_3"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> BCD位：计数初值的格式<br><br>此位为0，后面设置的计数初值为BCD码格式，0-9999；<br>此位为1，后面设置的计数初值为二进制格式，为0-FFFFH<br><br><span class="hljs-bullet">-</span> M2 M1 M0：模式选择位<br><br>000 模式0<br>001 模式1<br>X10 模式2<br>X11 模式3<br>100 模式4<br>101 模式5<br><br><span class="hljs-bullet">-</span> RW1 RW0 读写指示位<br><br>00 对计数器进行锁存操作，使当前计数值在输出锁存器中锁定，以便读出<br>01 只读/只写低八位<br>10 只读/只写高八位<br>11 先读/写低八位，再读/写高八位<br><br><span class="hljs-bullet">-</span> SC1 SC0 选择计数器<br><br>设置模式控制器字时，指出时对哪一个计数器进行设置<br><br>00 计数器0<br>01 计数器1<br>10 计数器2<br>11 读出控制字的标识码<br></code></pre></td></tr></table></figure>

<h3 id="关于的控制字说明"><a href="#关于的控制字说明" class="headerlink" title="关于的控制字说明"></a>关于的控制字说明</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1、8253/8254只有一个工作方式控制字，但是对每个计数器而言，它们的工作方式控制字内容一定各不相同（前两位不同），所用各计数器的控制字需要分别设置，先后不计。<br><br>2、在工作方式控制字被设置之后，随后必须紧接着给计数器预设置计数初值，计数器方可开始工作。<br><br>8253/8254初始化的工作有两个内容：<br><br>（1）首先向控制寄存器写入控制字，以选择计数器（3个计数器之一），确定工作方式（6种方式之一），指定计数器计数初值的长度和装入顺序以及计数值的码制（BCD或二进制码）。<br><br>（2）然后向已选定的计数器按控制字要求写入计数初值。<br></code></pre></td></tr></table></figure>


<h3 id="读出控制字"><a href="#读出控制字" class="headerlink" title="读出控制字"></a>读出控制字</h3><p>读出控制字：用来读取计数器当前的计数值</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">每个计数器的当前计数值可以被读取，因为计数值是不断变化的，所以在读取前要先进行锁存。读出控制字就是起锁存作用的，所以也叫做锁存命令<br><span class="hljs-bullet">-</span> D6 D7 D0：D7D6=11为读出控制字的标识码；D0=0必须是这样设置<br>/COUNT：如果为0，则将所选计数器的当前计数值进行锁存，以便后面读取<br>/STATUS：如果为零，则将所选计数器的状态进行锁存<br><span class="hljs-bullet">-</span> D3D2D1：分别对应于计数器2，1，0。在一个时刻只能对一个计数器进行锁存<br></code></pre></td></tr></table></figure>


<h2 id="编程命令"><a href="#编程命令" class="headerlink" title="编程命令"></a>编程命令</h2><p>对8253的编程没有顺序规定，非常灵活</p>
<h3 id="三条原则"><a href="#三条原则" class="headerlink" title="三条原则"></a>三条原则</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">对计数设置初值前必须先写控制字<br>初值设置时，要符合控制字中的格式规定<br>要读计数器的当前值和和状态字，必须用控制字先进行锁存<br></code></pre></td></tr></table></figure>

<h3 id="编程命令-1"><a href="#编程命令-1" class="headerlink" title="编程命令"></a>编程命令</h3><h4 id="写入命令——针对控制寄存器"><a href="#写入命令——针对控制寄存器" class="headerlink" title="写入命令——针对控制寄存器"></a>写入命令——针对控制寄存器</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">设置控制字命令，设置初值命令，锁存命令<br>一个计数器在工作之前，需要先设置控制字对所选择的计数器设定工作模式和计数格式；<br>设置初值命令用来给出计数的初值<br>锁存命令是配合读出命令使用的。在读取计数值时，必须先用锁存命令将当前计数值在输出锁存器中锁住，否则，在读数时，计数器的值在变化，就得到一个不确定的结果<br>当锁存命令到来时，计数执行部件到某一个值，因为锁存器是跟随计数执行部件工作的，所以锁存器中为同一值，此时这一计数被锁住<br><span class="hljs-bullet">-</span> CPU将此锁定值读走之后，锁存器自动失效，于是又跟随计数执行部件变化。<br>在锁存和读出计数值的过程中，计数执行部件仍在不停地作减一计数<br></code></pre></td></tr></table></figure>
<h4 id="读出命令——针对计数器"><a href="#读出命令——针对计数器" class="headerlink" title="读出命令——针对计数器"></a>读出命令——针对计数器</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">读出命令用来读取8253的某个计数器的当前计数值<br>读取计数器的值之前必须先锁存，再读取<br></code></pre></td></tr></table></figure>
<h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">写入控制字时，所有的控制逻辑电路立即复位，输出端OUT进入初始状态（高或低电平）<br>初始值写入之后，要经过一个时钟上升沿和一个下降沿，计数执行部件才开始计数<br>通常，在时钟脉冲CLK上升沿时，门控信号GATE被采样<br>在时钟脉冲的下降沿，计数器作减一操作。<br><br>其中0是最大初值，1是最小初值；<br></code></pre></td></tr></table></figure>
<h3 id="模式0——计数结束产生中断"><a href="#模式0——计数结束产生中断" class="headerlink" title="模式0——计数结束产生中断"></a>模式0——计数结束产生中断</h3><p>不是连续波形，产生中断；计数期间为低电平，结束为高电平。</p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/8253_00.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="8253_00"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">①控制字写入之后，OUT变低；初值装入后，要经过1个CLK的周期（1个上升沿和1个下降沿）后，计数器才开始计数，所以，输出OUT要经过N+1个时钟周期后才有输出；<br><br>②输出OUT的有效电平为高电平，并可同时触发中断请求；<br><br>③门控GATE的作用：高电平时计数，低电平或下降沿时停止计数；<br><br>④CW为写入控制字，N=4表示写入初值，计数值一次有效。<br></code></pre></td></tr></table></figure>



<h3 id="模式1：可编程单稳态触发器"><a href="#模式1：可编程单稳态触发器" class="headerlink" title="模式1：可编程单稳态触发器"></a>模式1：可编程单稳态触发器</h3><p>周期性波形，计数期间为低电平，其余为高电平。</p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/8253_11.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="8253_11"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">①控制字和初值装入后，OUT变高，在门控GATE的上升沿触发下，经过1个CLK的上升沿和1个下降沿后，计数器开始从初值减1计数，同时使OUT=0；当计数结束（归0）时，OUT=1，使输出产生1个宽度为TW=N×TCLK的负脉冲——单稳态触发器。<br><br>②在GATE的上升沿触发下，输出可再次产生1个宽度为TW负脉冲——可重复触发。<br></code></pre></td></tr></table></figure>
<h3 id="模式2：分频器"><a href="#模式2：分频器" class="headerlink" title="模式2：分频器"></a>模式2：分频器</h3><p>连续波形产生负脉冲，在最后一个计数期间为低电平，其余为高电平。</p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/8253_22.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="8253_22"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">①控制字装入后，OUT=1为初始状态。<br><br>②初值装入后，经过1个CLK的周期，计数器开始从初值减1计数，计到1（不是0）时，使输出OUT=0并保持1个CLK周期，然后OUT=1，开始下一个新的计数周期，使输出为CLK的时钟1/N分频信号，占空比q=（N-1）/N。<br><br>③门控GATE的作用：高电平时计数，低电平停止计数；GATE再次变高后从初始值重新计数；而在GATE=1时，计数完成之后自动重新装入初值，循环计数。<br><br>④如果计数过程中写入新值.不影响当前计数.完成后重新装入新值<br></code></pre></td></tr></table></figure>
<h3 id="模式3：方波发生器"><a href="#模式3：方波发生器" class="headerlink" title="模式3：方波发生器"></a>模式3：方波发生器</h3><p>周期性方波（占空比1:1）。</p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/8253_33.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="8253_33"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">特点与方式2类似，主要区别：输出方波，其占空比q为<br><br>①当N为偶数时，q=0.5；<br><br>②当N为奇数时，q=(N+1)/2N。<br></code></pre></td></tr></table></figure>





<h3 id="模式4：软件触发的选通信号发生器"><a href="#模式4：软件触发的选通信号发生器" class="headerlink" title="模式4：软件触发的选通信号发生器"></a>模式4：软件触发的选通信号发生器</h3><p>单次波形输出，计数结束后输出一个CLK周期的低电平，其余为高电平，不能自动循环。</p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/8253_44.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="8253_44"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">①初值装入后，经过1个CLK的周期，计数器开始从初值减1计数，计数结束（归0）时，使输出OUT产生一个宽度为1个CLK周期的负脉冲——选通信号。<br><br>②（用指令）重新装入初值后，经过N+1个CLK周期，又可使OUT产生一个选通信号——（用软件）可重复触发。<br><br>③门控GATE的作用：高电平时计数，低电平时停止计数。<br></code></pre></td></tr></table></figure>

<h3 id="模式5：硬件触发的选通信号发生器"><a href="#模式5：硬件触发的选通信号发生器" class="headerlink" title="模式5：硬件触发的选通信号发生器"></a>模式5：硬件触发的选通信号发生器</h3><p>单次波形输出，波形特征同方式4，但重置初值和GATE上升沿之后可重新计时。</p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/8253_55.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="8253_55"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">①初值装入后，在GATE的上升沿的触发下，经过1个CLK的周期，计数器开始从初值减1计数，计数结束（归0）时，使输出OUT产生一个宽度为1个CLK周期的负脉冲——选通信号。<br><br>②用GATE的上升沿可重新触发，使OUT产生一个选通信号——（用硬件）可重复触发。<br></code></pre></td></tr></table></figure>



<h3 id="8253工作模式小结"><a href="#8253工作模式小结" class="headerlink" title="8253工作模式小结"></a>8253工作模式小结</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">模式2、4、5的输出波形是相同的，都是宽度为一个CLK周期的负脉冲。<br><br>但模式2是连续工作，模式4由软件（设置计数值）触发启动，模式5由门控脉冲触发启动<br><br>写入计数值后才能开始计数<br><br>模式0、2、3、4在写入计数值后，计数过程就开始了<br><br>模式1、5需要外部触发启动，才开始计数<br><br>6种方式中只有方式2、3是连续计数，其他4种方式都是一次计数，要继续工作需要重新启动，方式0、4由写入计数值（软件）启动，方式1、5要由外部信号（硬件）启动。<br><br></code></pre></td></tr></table></figure>

<h2 id="应用举例-1"><a href="#应用举例-1" class="headerlink" title="应用举例"></a>应用举例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;假设端口是<br>0123H;control<br>0120H;0<br>0121H;1<br>0122H<br><br><br>CNT0：<br>MOV DX,0123H            ;初始化<br>MOV AL,34H<br>OUT DX,AL<br>MOV DX,0120H            ;写入计数初值<br>MOV AX,20000            ;使用AX寄存器，分为低8位和高8位，即AL和AH<br>OUT DX,AL<br>MOV AL,AH<br>OUT DX,AL<br><br><br>CNT1：<br>MOV DX,0123H            ;初始化<br>MOV AL,56H<br>OUT DX,AL<br>MOV DX,0121H            ;写入计数初值<br>MOV AX,200              ;这里AX可以直接写AL,200用八位寄存器就够   <br>OUT DX,AL<br><br><br>CNT2：<br>MOV DX,0123H            ;初始化<br>MOV AL,B0H<br>OUT DX,AL<br>MOV DX,0122H            ;写入计数初值<br>MOV AX,10000<br>OUT DX,AL<br>MOV AL,AH<br>OUT DX,AL<br><br></code></pre></td></tr></table></figure>





<h1 id="80C51"><a href="#80C51" class="headerlink" title="80C51"></a>80C51</h1><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 8位微处理器<br><span class="hljs-bullet">-</span> 物理结构上具有两个寻址空间:寻址64KB程序空间，寻址64KB数据空间<br><span class="hljs-bullet">-</span> 分类:<br><span class="hljs-code">	无片内ROM型：80C31 必须代价EPROM才能使用</span><br><span class="hljs-code">	带片内ROM型</span><br><span class="hljs-code">		片内EPROM型：87C51</span><br><span class="hljs-code">		片内FLASH型：89C51</span><br><span class="hljs-code">		片内掩膜ROM型：80C51</span><br><span class="hljs-code">		片内一次性编程（OTP）ROM：97C51</span><br><span class="hljs-code">- 存储器配置：程序存储器和数据存储器分离，使用不同的指令和寻址方式进行访问</span><br><span class="hljs-code">	寻址64KB程序空间，寻址64KB数据空间</span><br><span class="hljs-code">- 80C51共有111条指令</span><br><span class="hljs-code">- 80C51有分为2个中断优先级的5个中断源</span><br><span class="hljs-code">- 内部RAM</span><br><span class="hljs-code">	4个通用工作寄存区</span><br><span class="hljs-code">	32个通用寄存器</span><br><span class="hljs-code">	1个位寻址区</span><br><span class="hljs-code">- 4个并行IO口（P0-P3）</span><br><span class="hljs-code">	P0 P2可作为片外扩展地址总线使用</span><br><span class="hljs-code">- 内部集成一个全双工的异步串口接口，可同时发送和接收数据</span><br><span class="hljs-code"></span><br>------------------------------------------------<br>补充：<br>单片机按存储结构可分为二类：一类是哈佛结构，另一类是普林斯顿结构。<br><span class="hljs-code">       ①哈佛结构</span><br><span class="hljs-code">       所谓哈佛结构是指程序存储器地址空间与数据存储器地址空间分开的单片机结构，如80C51单片机采用哈佛结构，所以80C51单片机的程序存储器地址空间与数据存储器地址空间是分开的，各有64K存储空间。</span><br><span class="hljs-code">       ②普林斯顿结构</span><br><span class="hljs-code">       所谓普林斯顿结构是指程序存储器地址空间与数据存储器地址空间合并的单片机结构，如MCS-96单片机采用普林斯顿结构，所以MCS-96单片机的程序存储器地址空间与数据存储器地址空间是合并的，共有64K存储空间。</span><br></code></pre></td></tr></table></figure>

<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210626102242.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210626102242"></p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210626103208.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210626103208"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 80C51中没有单独的地址总线和数据总线，而是与通用并行口中的P0和P2口公用；<br><span class="hljs-code">	8位数据线，16位地址线</span><br><span class="hljs-code">        P0口分时作为低八位地址线和8为数据线用；</span><br><span class="hljs-code">        P2口作为高八位地址线</span><br><span class="hljs-code">    单片机在进行外部扩展时的地址线和数据线都不是独立的总线，而是与并行口IO共用</span><br><span class="hljs-code">    来自网络：</span><br><span class="hljs-code">    	8051单片机CPU是几位的?  </span><br><span class="hljs-code">    	—— 8位,多少位机一般以数据总线的位数来确定的,8051的数据总线为P0口,8位分别为P0.0~P0.7,有16根地址总线,分别为P0和P2.</span><br><span class="hljs-code">    </span><br></code></pre></td></tr></table></figure>

<h2 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h2><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210626103507.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210626103507"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs markdown">（来自网络）<br>若除去图中的存储器电路和I/O部件，剩下的便是CPU。它可以分为运算器和控制器两部分。<br><span class="hljs-code">	运算器功能部件包括算术逻辑运算单元ALU、累加器ACC、寄存器B、暂存寄存器TMP1、TMP2、程序状态字寄存器PSW等。</span><br><span class="hljs-code">	控制器功能部件包括 **程序计数器PC** 、指令寄存器IR、指令译码器ID、定时控制逻辑电路CU、**数据指针寄存器DPTR** 、**堆栈指针SP** 及时钟电路等。</span><br><span class="hljs-code"></span><br>（1）运算器<br><span class="hljs-code">    ①算术逻辑运算单元ALU（Arithmetic Logical Unit）</span><br><span class="hljs-code">    ALU可以进行算术、逻辑运算。算术运算有：加、减、乘、除，逻辑运算有：与、或、异或等。</span><br><span class="hljs-code">    ②累加器ACC</span><br><span class="hljs-code">    累加器ACC的主要功能是在运算前存放一个操作数，运算后存放一个操作结果。80C51系列单片机虽然在结构上仍然以累加器A作为重要部件。但由于内部电路采取了措施，使得累加器A在数据传送、逻辑操作等方面的核心作用有所削弱。数据可以在片内直接/间接地址的存储器之间直接传送，而不必经过累加器A。但，加、减、乘、除算术运算指令的运算结果都存放在累加器A或AB寄存器对中。</span><br><span class="hljs-code">    ③暂存器TMP1、TMP2</span><br><span class="hljs-code">    由80C51单片机的内部结构框图可知，ALU进行算术逻辑运算前的两个操作数来自暂存器TMP1、TMP2，所以暂存器TMP1、TMP2用于存放运算前的两个操作数。</span><br><span class="hljs-code">    ④程序状态字寄存器PSW</span><br><span class="hljs-code">    程序状态字寄存器PSW用来存放运算结果的状态标志。PSW寄存器各位的含义如下，其中PSW.1未定义，其它各位说明如下：</span><br><span class="hljs-code">        CY：进位标志。它是累加器A的进位位，如果操作结果在最高位有进位（加法）或借位（减法）时置1，否则清0。</span><br><span class="hljs-code">        AC：半进位标志。它是低半字节的进位位（累加器A中A3位向A4位的进位），主要用于BCD码调整。低4位有进位（加法时）或向高4位有借位时（减法时），AC是1，否则，AC清0。</span><br><span class="hljs-code">        F0：用户定义的状态标志位。可通过软件对它置位、复位或测试，以控制程序的流向。</span><br><span class="hljs-code">        RS1、RS0：工作寄存器区选择控制位，用于选择4组工作寄存器之一。可以用软件来置位或清零，以确定工作寄存器区。RS1、RS0与寄存器区的对应关系如下：</span><br><span class="hljs-code">        RS1、RS0=00——0区（地址00H~07H）</span><br><span class="hljs-code">        RS1、RS0=01——1区（地址08H~0FH）</span><br><span class="hljs-code">        RS1、RS0=10——2区（地址10H~17H）</span><br><span class="hljs-code">        RS1、RS0=11——3区（地址18H~1FH）</span><br><span class="hljs-code">        OV：溢出标志位，用于表示有符号数算术运算的溢出。溢出时OV为1，否则OV为0。</span><br><span class="hljs-code">        P：奇偶标志位。每个指令周期都由硬件来置位或清零，以表示累加器A中1的个数的奇偶性。若1的个数为奇数，则P置位；若1的个数为偶数，则清零。</span><br><span class="hljs-code">    ⑤寄存器B</span><br><span class="hljs-code">    在乘除指令中，用到了寄存器B。</span><br><span class="hljs-code">（2）控制器</span><br><span class="hljs-code">控制器是控制单片机各种操作的部件，用于完成指令规定的操作。它包括程序计数器PC、指令寄存器IR、指令译码器ID、定时控制逻辑、数据指针寄存器DPTR、时钟发生器、复位电路、堆栈指针SP等。</span><br><span class="hljs-code">	①程序计数器 PC</span><br><span class="hljs-code">    程序计数器PC为16位寄存器，用于存放下一条要执行指令地址，具有自动加1功能。</span><br><span class="hljs-code">    ②指令寄存器IR、指令译码器ID、定时控制逻辑电路</span><br><span class="hljs-code">    指令寄存器IR用来暂时存放当前取出的指令，并由指令译码器ID译码，产生相应的译码信号，并传送给定时控制电路，定时控制电路发出各种控制信号控制各器件完成指令规定的操作。</span><br><span class="hljs-code">    ③数据指针DPTR</span><br><span class="hljs-code">    DPTR为16位寄存器。由于80C51单片机采用哈佛结构，因此，其程序存储器与地址存储器是分开的，程序存储器的地址是由程序计数器PC提供，而数据存储器的地址是由数据指针DPTR提供的，所以DPTR用于存放片外数据存储器及I/O口的地址。</span><br><span class="hljs-code">    ④时钟电路</span><br><span class="hljs-code">    时钟电路是计算机的心脏，它控制着计算机的工作节奏。</span><br><span class="hljs-code">    ⑤复位和复位电路</span><br><span class="hljs-code">    计算机在启动运行时都需要复位，复位就是使CPU和系统中的其它部件处于一个确定的初始状态，并从这个状态开始工作。</span><br><span class="hljs-code">    ⑥堆栈指针SP</span><br><span class="hljs-code">    堆栈指针SP用于存放栈顶单元的地址。</span><br></code></pre></td></tr></table></figure>

<h1 id="引脚"><a href="#引脚" class="headerlink" title="引脚"></a>引脚</h1><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210626105743.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210626105743"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs markdown">Vss(20脚):接地<br><br>VCC（40脚）: 主电源+5V<br><br>XTAL1（19脚）:接外部晶体的一端。在片内它是振荡电路反相放大器的输入端。在采用外部时钟时，对于HMOS单片机，该端引脚必须接地；对于CHMOS单片机，此引脚作为驱动端。<br><br>XTAL2（18脚）: 接外部晶体的另一端。在片内它是一个振荡电路反相放大器的输出端，振荡电路的频率是晶体振荡频率。若需采用外部时钟电路，对于HMOS单片机，该引脚输入外部时钟脉冲；对于CHMOS单片机，此引脚应悬浮。<br><br><br>RST（9脚）: 单片机刚接上电源时，其内部各寄存器处于随机状态，在该脚输入24个时钟周期宽度以上的高电平将使单片机复位（RESET）<br><br> <br><br>PSEN（29脚）: 在访问片外程序存储器时，此端输出负脉冲作为存储器读选通信号。CPU在向片外存储器取指令期间，PSEN信号在12个时钟周期中两次生效。不过，在访问片外数据存储器时，这两次有效PSEN信号不出现。PSEN端同样可驱动8个LSTTL负载。我们根据PSEN、ALE和XTAL2输出端是否有信号输出，可以判别80C51是否在工作。<br><br> <br><br>ALE/PROG（30脚）:在访问片外程序存储器时，此端输出负脉冲作为存储器读选通信号。CPU在向片外存储器取指令期间，PSEN信号在12个时钟周期中两次生效。不过，在访问片外数据存储器时，这两次有效PSEN信号不出现。PSEN端同样可驱动8个LSTTL负载。我们根据PSEN、ALE和XTAL2输出端是否有信号输出，可以判别80C51是否在工作。<br><br> <br><br>EA/VPP（31脚）: 当EA端输入高电平时，CPU从片内程序存储器地址0000H单元开始执行程序。当地址超出4KB时，将自动执行片外程序存储器的程序。当EA输入低电平时，CPU仅访问片外程序存储器。在对87C51EPROM编程时，此引脚用于施加编程电压VPP。<br><br> <br><br>输入/输出引脚：<br><br><span class="hljs-code">    （1）P0.0—P0.7    (39脚—32脚)</span><br><span class="hljs-code"></span><br><span class="hljs-code">    （2）P1.0—P1.7   （1脚—8脚）</span><br><span class="hljs-code"></span><br><span class="hljs-code">    （3）P2.0—P2.7   （26脚—21脚）</span><br><span class="hljs-code"></span><br><span class="hljs-code">    （4）P3.0—P3.7   （10脚—17脚）</span><br><span class="hljs-code">    	P3.0/RXD(串口收)</span><br><span class="hljs-code">    	P3.1/TXD（串口发）</span><br></code></pre></td></tr></table></figure>



<h1 id="存储器-1"><a href="#存储器-1" class="headerlink" title="存储器"></a>存储器</h1><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210626110555.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210626110555"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">由于80C51单片机采用哈佛结构，所以其程序存储器和数据存储器是分开的，各有自身的寻址系统、控制信号和功能。<br>程序存储器用来存放程序和表格常数；数据存储器通常用来存放程序运行所需要的给定参数和运行结果。<br><span class="hljs-code">     从实际的物理存储介质来看，80C51有4种存储空间，它们是片内程序存储器、片外程序存储器（MOVC）、片内数据存储器（含特殊功能寄存器）和片外数据存储器(MOVX)。80C51的存储器配置情况如下图所示。</span><br></code></pre></td></tr></table></figure>

<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210626105940.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210626105940"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdwon">从逻辑地址空间来看，80C51单片机可分为三部分，即：程序存储器、片外数据存储器、片内数据存储器。这3部分分别使用不同的地址指针，不同的访问指令。因此，下面按逻辑结构介绍80C51的存储器结构。<br>（1）程序存储器<br>由下图可知，程序存储器以程序计数器PC作地址指针，通过16位地址总线，可寻址的地址空间为0000H~0FFFFH共64K(216=64K)字节，其访问指令为MOVC。用于存放程序指令码与固定的数据表格等。<br></code></pre></td></tr></table></figure>

<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210626111106.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210626111106"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">80C51单片机中内部和外部共64K字节程序存储器的地址空间是统一的。对于有内部ROM的单片机，在正常运行时，应把引脚接高电平，使程序从内部ROM开始执行。当PC值超出内部ROM的容量时，会自动转向外部程序存储器空间。<br><span class="hljs-code">      （2）片外数据存储器</span><br><span class="hljs-code">      由80C51的存储器配置图可知，片外数据存储器以DPTR作为地址指针，通过16位地址总线，可寻址的地址空间为0000H~0FFFFH共64K(216=64K)字节，其访问指令为MOVX。用于存放数据与运算结果。</span><br><span class="hljs-code">      （3）片内据存储器</span><br><span class="hljs-code">      片内数据存储器的地址空间从00H~FFH共256字节，其访问指令为MOV。其地址可由R0、R1寄存器提供。内部数据存储器是最灵活的地址空间，它分成物理上独立且性质上不同的2个区：00H~7FH单元组成的128字节RAM区，地址为80H~FFH的特殊功能寄存器区（简称SFR区）。</span><br><span class="hljs-code">      1）RAM区（00H~7FH）</span><br><span class="hljs-code">      又由80C51的存储器配置图可知，RAM区又分为3个区：工作寄存器区、位地址区与数据缓冲区。</span><br><span class="hljs-code">      ①工作寄存器区（00H~1FH）</span><br><span class="hljs-code">      80C51单片机的内部RAM区结构如80C51的存储器配置图所示。</span><br><span class="hljs-code">      ②位地址区（20H~2FH）</span><br><span class="hljs-code">      内部RAM的20H~2FH为位寻址区域，见表1所示。这16个单元的每一位都有一个位地址，位地址范围为00H~7FH。通常把各种程序状态标志、位控制变量设在位寻址区内。位寻址区的RAM单元也可以作为一般的数据缓冲区使用。</span><br><span class="hljs-code"></span><br><span class="hljs-code">      						表1 内部RAM区的位地址映像表</span><br></code></pre></td></tr></table></figure>

<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210626111229.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210626111229"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdwon">③数据缓冲区<br>      数据缓冲区的地址空间从30H~7FH共80个字节单元，用于存放数据与运算结果，如加法运算时，存放加数、被加数及运算和。通常堆栈区也设置在该区内。有些单片机将显示缓冲区设置在该区内。<br>      2）特殊功能寄存器SFR（80H~FFH）<br>      80C51单片机内的I/O口锁存器、状态标志寄存器、定时器、串行口、数据缓冲器以及各种控制寄存器统称为特殊功能寄存器，它们离散地分布在内部RAM地址空间（80H~0FFH）内，表2列出了这些特殊功能寄存器的标识符、名称及地址。由表2-2可知累加器ACC、寄存器B、程序状态字PSW、I/O口P0~P3等均为特殊功能寄存器。<br>      <br>      <br>      							表2 特殊功能寄存器SFR<br></code></pre></td></tr></table></figure>

<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210626111242.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210626111242"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdwon">注：带“·”号的寄存器可按字节和按位寻址，其特征是直接地址能被8整除。带“*”号的寄存器是与定时器/计数器2有关的寄存器，仅在80C52系列中存在。下面以一个实例说明单片机的内部存储器。<br></code></pre></td></tr></table></figure>

<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210626111344.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210626111344"></p>
<h1 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown">震荡周期T:时序中最小的时间单位<br><span class="hljs-code">	由外接晶体或者输入时钟决定</span><br><span class="hljs-code">时钟周期（状态周期）</span><br><span class="hljs-code">	晶体振荡器的真当信号经过片内时钟发生器二分频后的信号</span><br><span class="hljs-code">	时钟周期是振荡周期的2倍</span><br><span class="hljs-code">机器周期</span><br><span class="hljs-code">	CPU执行一条指令所需要的时间的基本单位</span><br><span class="hljs-code">	51单片机中的机器周期由12个振荡周期构成</span><br><span class="hljs-code">	分为六个状态周期（S1-S6）</span><br><span class="hljs-code">	每个状态又分为P1和P2两相时钟</span><br><span class="hljs-code">指令周期</span><br><span class="hljs-code">	CPU执行一条指令所需要的时间，以机器周期位单位</span><br><span class="hljs-code">	</span><br><span class="hljs-code">	51单片机共111条指令</span><br><span class="hljs-code">	单机器周期指令：64个</span><br><span class="hljs-code">	双机器周期指令：45个</span><br><span class="hljs-code">	四机器周期指令:2个（乘法指令和除法指令）	</span><br></code></pre></td></tr></table></figure>

<h1 id="复位-1"><a href="#复位-1" class="headerlink" title="复位"></a>复位</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 在启动时需要复位，使CPU和系统的各个部件处于一种初始状态<br><span class="hljs-bullet">-</span> 复位信号从单片机的RST引脚输入，高电平有效，维持至少两个机器周期<br><span class="hljs-bullet">-</span> 上电自动复位<br><span class="hljs-bullet">-</span> 按键手动复位<br></code></pre></td></tr></table></figure>

<h1 id="并行I-O口"><a href="#并行I-O口" class="headerlink" title="并行I&#x2F;O口"></a>并行I&#x2F;O口</h1><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210626111834.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210626111834"></p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210626115604.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210626115604"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs markdwon">80C51单片机含有4 个8位并行I/O口P0、P1、P2和P3。<br>每个口有8个引脚，如图2-1所示，共有32个I/O引脚，每一个并行I/O口都能用作输入或输出。<br>每一条IO引脚都能独立地用作输入或输出，做输出时数据可以锁存，做输入时数据可以缓冲<br><br>        各口的第一、第二功能如下：<br>               I/O口     引脚       第一功能           第二功能<br>               P0口   P0.0~P0.7    输入与输出       分时的传送地址低8位与数据线<br>               P1口   P1.0~P0.7    输入与输出       无第二功能<br>               P2口   P2.0~P2.7    输入与输出       传送地址的高8位<br>               P3口   P3.0~P3.7    输入与输出       P3.0——RXD：串行口输入端<br>               P3.1——TXD：串行口输出端<br>               P3.2——INT0：外部中断0中断请求输入端<br>               P3.3——INT1：外部中断1中断请求输入端<br>               P3.4——T0：定时器/计数器0外部输入端<br>               P3.5——T1：定时器/计数器1外部输入端<br>               P3.6——WR：外部数据存储器写选通信号<br>               P3.7——RD：外部数据存储器读选通信号<br>               <br>               <br>       四个通道口都有一种特殊的线路结构，每个口都包含一个锁存器，即特殊功能寄存器P0~P3，一个输出驱动器和两个（P3口有三个）三态缓冲器。这种结构在数据输出时，可以锁存，即在重新输出新的数据之前，口上的数据一直保持不变。但对于输入信号是不锁存的，所以外设欲输入的数据必须保持到取数指令执行（把数据读取后）为止。<br>       <br>       <br>       <br>       下面分别叙述各个端口的结构、功能和使用方法。<br>       -------------------------------------------------------------------------------------------<br>（1）P0口的组成与功能————————三态双向口<br><br>       1）位结构<br>       在访问外部存储器时，P0口是一个真正的双向数据总线口，并分时送出地址的低8位。<br>       它包含两个输入缓冲器、一个输出锁存器以及输出驱动电路、输出控制电路。<br>       输出驱动电路由两只场效应管V1和V2组成，其工作状态受输出控制电路的控制。输出控制电路包括与门、反相器和多路模拟开关MUX。<br>       P0口既能用作通用I/O口（需要上拉电阻），又能用作地址/数据总线（不需要上拉电阻）。<br>       <br>       2）作为通用I/O口<br>       P0口作为通用I/O口使用时，CPU令控制信号为低电平。这时多路开关MUX接通B端即输出锁存器的 端，同时使与门输出低电平，场效应管V1截止，因而输出级为开漏输出电路。<br><br>           ①作为输出口<br>           当用P0口输出数据时，写信号加在锁存器的时钟端CL上，此时与内部总线相连的D端其数据经反相后出现的 端上，再经V2管反相，于是在P0口引脚上出现的数据正好是内部总线上的数据。由于输出级为开漏电路，所以用作输出口时应外接上拉电阻。<br>           ②作为输入口<br>           当P0口用于输入数据时，要使用端口中的两个三态输入缓冲器之一。这时有两种工作方式：读引脚和读锁存器。<br>           当CPU执行一般的端口输入指令时，“读引脚”信号使图2-4中下面一个缓冲器开通，于是端口引脚上的数据经过缓冲器输入到内部总线上。<br>           当CPU执行“读一修改一写”一类指令时，“读锁存器”信号使图2-4上面一个缓冲器开通，锁存器Ｑ端的数据经缓冲器输入内部数据总线。<br>           在P0口作为输入口使用时，必须首先向端口锁存器写入“1”。这是因为当进行读引脚操作时，如果V2是导通的，那么不论引脚上的输入状态如何，都会变为低电平。为了正确读入引脚上的逻辑电平，先要向锁存器写1，使其 端为0，V2截止。该引脚成为高阻抗的输入端。<br>           <br>       3）作为地址/数据总线<br>       P0口还能作为地址总线低8位或数据总线，供系统扩展时使用。这时控制信号为高电平，多路开关MUX接通A端。有两种工作情况：一种是总线输出，另一种是外部数据输入。作为总线输出时，从“地址/数据”端输入的地址或数据信号通过与门驱动V2，同时通过非门驱动V2，结果在引脚上得到地址或数据输出信号。<br>       作为数据总线输入数据时，从引脚上输入的外部数据经过读引脚缓冲器进入内部数据总线。对于80C51、87C51单片机，P0口能作为I/O口或地址/数据总线使用。对于80C31单片机，P0口只能用作地址/数据总线。<br>       综上所述，P0口既可以作为地址/数据总线口，这时它是真正的双向口，也可作通用的I/O口，但只是一个准双向口。准双向口的特点是：复位时，口锁存器均置“1”，8根引脚可当一般输入线使用，而在某引脚由原输出状态变成输入状态时，则应先写入“1”，以免错读引脚上的信息。一般情况下，P0口已当作地址/数据总线口使用时，就不能再作通用I/O口使用。<br><br><br>       -------------------------------------------------------------------------------------------<br>（2）P1口组成与功能————————准双向口<br><br>       P1口只用作通用I/O口，其一位结构图如图所示。与P0口相比，P1口的位结构图中少了地址/数据的传送电路和多路开关，上面一只MOS管改为上拉电阻。<br>       P1口作为一般I/O的功能和使用方法与P0口相似。当输入数据时，应先向端口写“1”。它也有读引脚和读锁存器两种方式。所不同的是当输出数据时，由于内部有了上拉电阻，所以不需要再外接上拉电阻。<br>       P1口作为输入口使用时，有两种工作方式：读端口   读引脚<br>       	读端口:实际上并不从外部读入数据，只是把端口锁存器中的内容读入到内部总线，经过某种运算和变换后，再写回端口锁存器；<br>       	读引脚:真正地把外部的输入信号读入到内部总线。<br>       	<br>       <br>       <br>       -------------------------------------------------------------------------------------------      <br>（3）P2口的组成与功能————————准双向口<br><br>		当系统中接有外部存储器时，P2口可用于输出高8位地址，若当作通用I/O口用，P2口则是一个准双向口。因此说P2口能用作通用I/O口或地址总线，其一位的结构如图所示。<br>       ①作为通用I/O口<br>       当控制信号为低电平时，多路开关接到B端，P2口作为通用I/O口使用，其功能和使用方法与P1口相同。<br>       ②作为地址总线<br>       当控制端输出高电平时，多路开关接到A端，地址信号经反相器、V从引脚输出。这时P2口输出地址总线高8位，供系统扩展使用。<br>       对80C51、87C51单片机，P2口能作为I/O口或地址总线作用。对于80C31单片机，P2口只能用作地址总线。<br>      <br>     -------------------------------------------------------------------------------------------     <br>（4）P3口组成与功能———————多功能口<br><br>	P3口能作通用I/O口，同时每一引脚还有第二功能。P3口的一位结构如图2-7所示。<br>    作为通用I/O口：当“第二功能输出”端为高电平时，P3口用作通用I/O口。这时与非门对于输入端Q来说相当于非门，位结构与P2口完全相同，因此P3口用作通用I/O口时的功能和使用方法与P2口、P1口相同。<br>    用作第二功能： 当P3口的某一位作为第二功能输出使用时，应将该位的锁存器置“1”，使与非门的输出状态只受“第二功能输出”端的控制。“第二功能输出”端的状态经与非门和驱动管V输出到该位引脚上。<br>    当P3口的某一位作为第二功能输入使用时，该位的锁存器和“第二功能输出”端都应为“1”，这样，该位引脚上的输入信号经缓冲器送入“第二功能输入”端。<br>    <br>    <br>    <br>    <br>    <br>    <br>    <br>    至此，可以对组成一般单片机应用系统时各个并行口的分工小结如下：<br>    P0口：分时的用作地址低8位与数据线，低8位地址由PC低8位或DPL提供。<br>    P1口：按位可编址的输入输出口。<br>    P2口：地址线的高8位，高8位地址由PC高8位或DPH提供。<br>    P3口：双功能口，若不用第二功能，可作为一般的I/O口。<br></code></pre></td></tr></table></figure>



<h1 id="定时器-计数器"><a href="#定时器-计数器" class="headerlink" title="定时器&#x2F;计数器"></a>定时器&#x2F;计数器</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 80C51 单片机内部有两个可编程定时器/计数器，T0和T1<br><span class="hljs-bullet">-</span> 他们的工作方式指令对相应的特殊功能寄存器编程来设定，设置后用作定时器或计数器<br><span class="hljs-bullet">-</span> 定时器/计数器的硬件组成就是：双字节加法计数器TH和TL<br><span class="hljs-bullet">-</span> 作定时器使用时，计数器脉冲由单片机内部振荡器提供,计数频率为震荡频率的12分之一，即每个机器周期加1<br><span class="hljs-bullet">-</span> 作计数器使用时，计数脉冲由P3口的P3.4（或P3.5）即T0(或T1)引脚引入，外部脉冲的下降沿触发计数，计数器在每个机器周期的S5P2期间采样外部脉冲。<br><span class="hljs-code">		若一个周期的采样值为1，下一个周期的采样值为0，则计数器加1，故识别一个从0到1的跳变需要两个机器周期</span><br></code></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">工作原理：<br>加1计数器输入的计数脉冲有两个来源，一个是由系统的时钟振荡器输出脉冲经12分频后送来，一个是T0或T1引脚输入的外部脉冲源。每来一个脉冲计数器加1，当加到计数器全为1时，再输入一个脉冲就使计数器回零，计数器的溢出使TCON中的TF0或TF1置1，向CPU发出中断请求（定时/计数器中断允许时）。如果定时/计数器工作于定时模式，则表示定时时间已到，如果工作于计数模式，则表示计数值已满。<br><br>可见，由溢出时计数器的值减去计数初值才是加1计数器的计数值。<br><br>设置为定时器模式时，加1计数器是对内部机器周期计数（1个机器周期等于12个振荡周期，即技术频率为晶振频率的1/12）。计数值N乘以机器周期Tcy就是定时时间t。<br><br>例：假设计数50个数，那么定时时间为：   （定时时间（μs）=计数数X1/(晶振频率)X12）。<br><br>16位寄存器能够计数的最大时间为65536μs。<br><br>设置为计数模式时，外部事件计数脉冲由T0或T1引脚输入到计数器。在每个机器周期的S5P2期间采样T0、T1引脚电平。当某周期采样到一高电平输入，而下一周期有采样到一低电平时，计数器加1，更新的计数值在下一机器周期得S3P1期间装入计数器。由于检测一个从1到0下降沿需要2个机器周期，因此要求被采样的电平至少要维持一个机器周期。当晶振频率为12MHz时，最高计数频率不超过1/2MHz，即计数脉冲的周期要大于2μs。<br></code></pre></td></tr></table></figure>

<p>TMOD：定时器&#x2F;计数器的工作方式</p>
<p>TCON：定时器&#x2F;计数器的启动运行</p>
<p>80C51单片机定时&#x2F;计数器的工作由两个特殊功能寄存器控制。<strong>TMOD用于设置其工作方式；TCON用于控制其启动和中断申请</strong>。</p>
<h2 id="方式控制寄存器-TMOD"><a href="#方式控制寄存器-TMOD" class="headerlink" title="方式控制寄存器 TMOD"></a>方式控制寄存器 TMOD</h2><p>地址：89H</p>
<p><strong>工作方式寄存器TMOD用于设置定时&#x2F;计数器的工作方式，</strong>低四位用于T0，高四位用于T1。其格式如下：</p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627094607.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627094607"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">GATE：门控位。GATA=0时，只要用软件使TCON中的TR0或TR1为1，就可以启动定时/计数器工作；GATA=1时，要用软件使TR0或TR1为1，同时外部中断引脚也为高电平时，才能启动定时/计数器工作。<br><br>C//T：定时/计数模式选择位。C/=0时为定时模式；C/=1时为计数模式。<br><br>M1M0：工作方式设置位。定时/计数器有四种工作方式，由M1M0进行设置。<br></code></pre></td></tr></table></figure>

<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627094610.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627094610"></p>
<h2 id="运行控制寄存器-TCON"><a href="#运行控制寄存器-TCON" class="headerlink" title="运行控制寄存器 TCON"></a>运行控制寄存器 TCON</h2><p>TCON的低4位用于控制外部中断。TCON的高4位用于控制定时&#x2F;计数器的<strong>启动和中断申请</strong>。其格式如下：</p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627094643.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627094643"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">TF1（TCON.7）：T1溢出中断请求标志位。T1计数溢出时由硬件自动置TF1为1。CPU响应中断后TF1由硬件自动清0.T1工作时，CPU可随时查询TF1的状态。所以，TF1可用作查询测试的标志。TF1也可以用软件置1或清零，同硬件置1或清0的效果一样。<br><br>TR1（TCON.6）：T1运行控制位。TR置1时，T1开始工作；TR1置0时，T1停止工作。TR1由软件置1或清零。所以，软件可控制定时/计数器的启动与停止。<br><br>TF0（TCON.5）：T0溢出中断请求标志位，其功能与TF1类同。<br><br>TR0（TCON.4）：T0运行控制位，其功能与TR1类同。<br></code></pre></td></tr></table></figure>

<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627094923.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627094923"></p>
<h3 id="方式0"><a href="#方式0" class="headerlink" title="方式0"></a>方式0</h3><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627095053.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627095053"></p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627095059.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627095059"></p>
<h3 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h3><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627095112.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627095112"></p>
<h3 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h3><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627095120.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627095120"></p>
<h3 id="方式3"><a href="#方式3" class="headerlink" title="方式3"></a>方式3</h3><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627095127.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload></p>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><h2 id="中断的概念"><a href="#中断的概念" class="headerlink" title="中断的概念"></a>中断的概念</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 单片机与外设交换信息可采用查询方式和中断方式<br><span class="hljs-bullet">-</span> 中断就是CPU暂时终止当前正在执行的程序而转去执行中断服务子程序，所有中断的方式CPU效率高！<br><br><br><span class="hljs-bullet">-</span> 中断类型<br><span class="hljs-bullet">	-</span> 屏蔽中断<br><span class="hljs-code">		又名：直接中断</span><br><span class="hljs-code">		通过指令使中断系统与外界隔开，使外接发来的中断请求不起作用，不引起中断。</span><br><span class="hljs-code">	- 非屏蔽中断</span><br><span class="hljs-code">		计算机一定要处理的中断方式，不能用软件来加以屏蔽</span><br><span class="hljs-code">		一般用与程序中掉电等紧急情况</span><br><span class="hljs-code">	- 软件中断</span><br><span class="hljs-code">		一种用指令系统中专门的中断指令来实现的一种中断，一般用与程序中断点的设置，以便于程序的调试！</span><br><span class="hljs-code">		</span><br><span class="hljs-code">中断源:</span><br><span class="hljs-code">	引起中断的原因，或是能发出中断申请的来源</span><br><span class="hljs-code">	</span><br><span class="hljs-code">中断系统的任务：</span><br><span class="hljs-code">	对于中断申请开放或屏蔽（开中断和关中断）</span><br><span class="hljs-code">		只有在开中断的情况下，才有可能接受中断源的申请</span><br><span class="hljs-code">	中断的排队</span><br><span class="hljs-code">		中断优先级问题</span><br><span class="hljs-code">	中断的响应</span><br><span class="hljs-code">		单片机在响应了中断的申请后，应使CPU从主程序转去执行中断服务子程序；</span><br><span class="hljs-code">		同时要把断点地址送人堆栈进行保护，以便在执行完中断服务子程序后能返回到原来的断点继续执行主程序。</span><br><span class="hljs-code">		中断系统还要能够确定各个被响应中断源的中断服务子程序的入口</span><br><span class="hljs-code">	中断的撤销</span><br><span class="hljs-code">		在响应中断请求之后，返回主程序之前，中断申请应该撤销；</span><br><span class="hljs-code">		否则就等于中断申请仍然存在，这将会影响其他中断申请的响应；</span><br><span class="hljs-code">        80C51只能对一部分中断申请在响应后自动撤销</span><br><span class="hljs-code">        </span><br></code></pre></td></tr></table></figure>



<h2 id="中断申请与控制"><a href="#中断申请与控制" class="headerlink" title="中断申请与控制"></a>中断申请与控制</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown">5个中断源<br><br><span class="hljs-bullet">-</span> 两个外部中断<br><span class="hljs-bullet">  -</span> 两个外部中断源分别从/INT0（P3.2）和/INT1（P3.3）引脚输入<br><span class="hljs-bullet">  -</span> 外部中断请求信号：<br><span class="hljs-bullet">  -</span> 电平输入方式<br><span class="hljs-bullet">    -</span> /INT0（P3.2）和/INT1（P3.3）引脚检测到低电平为有效的中断申请<br><span class="hljs-bullet">  -</span> 负边沿输入方式<br><span class="hljs-bullet">    -</span> /INT0（P3.2）和/INT1（P3.3）引脚检测到从1到0的负脉冲跳变<br><span class="hljs-bullet">-</span> 两个定时器/计数器中断<br><span class="hljs-bullet">  -</span> 内部中断<br><span class="hljs-bullet">  -</span> 当T0或T1溢出（全1变成全0）时发出中断申请<br><span class="hljs-bullet">-</span> 一个串行口中断<br><span class="hljs-bullet">  -</span> 内部中断<br><span class="hljs-bullet">  -</span> 在串行口，每接受或发送完一组数据后自动发出的中断申请<br></code></pre></td></tr></table></figure>



<h3 id="TCON寄存区"><a href="#TCON寄存区" class="headerlink" title="TCON寄存区"></a>TCON寄存区</h3><ul>
<li>地址88H</li>
<li>其中各位都可以位寻址，位地址88H-8FH；</li>
<li>定时器&#x2F;计数器溢出中断和外部中断的申请标志，在CPU响应中断之后会自动撤除</li>
</ul>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210626140324.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210626140324"></p>
<h3 id="SCON寄存区"><a href="#SCON寄存区" class="headerlink" title="SCON寄存区"></a>SCON寄存区</h3><ul>
<li>地址98H</li>
<li>位寻址：98H-9FH</li>
<li>串行口的中断申请标志是由TI和RI相或以后产生的，并且串行口中断申请在得到CPU响应之后不会自动撤除</li>
</ul>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210626140340.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210626140340"></p>
<h3 id="IE-中断允许寄存区"><a href="#IE-中断允许寄存区" class="headerlink" title="IE 中断允许寄存区"></a>IE 中断允许寄存区</h3><ul>
<li>地址A8H</li>
<li>位寻址:A8H-AFH</li>
<li>80C51在复位时，IE各位的状态都是0，所以CPU处于关中断的状态</li>
</ul>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210626140355.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210626140355"></p>
<h3 id="IP-中断优先级寄存器"><a href="#IP-中断优先级寄存器" class="headerlink" title="IP 中断优先级寄存器"></a>IP 中断优先级寄存器</h3><ul>
<li>地址B8H</li>
<li>位寻址：B8H-BCH</li>
<li>IP寄存器的某一位为1则相应的中断源为高优先级</li>
<li>IP寄存器的某一位为0则相应的中断源为低优先级</li>
</ul>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210626140414.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210626140414"></p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210626140414.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload></p>
<h2 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h2><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627091716.jpg" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627091716"></p>
<h2 id="中断响应的条件"><a href="#中断响应的条件" class="headerlink" title="中断响应的条件"></a>中断响应的条件</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">①、中断源有中断请求；<br>②、此中断源的中断允许为位1；<br>③、CPU开中断（即EA=1）。<br></code></pre></td></tr></table></figure>

<p>以外部中断0为例：</p>
<pre><code class="hljs">   主程序中需要的代码：
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">EA=<span class="hljs-number">1</span>；<span class="hljs-comment">//打开总中断开关</span><br>EX0=<span class="hljs-number">1</span>；<span class="hljs-comment">//开外部中断0</span><br>IT0=<span class="hljs-number">0</span>/<span class="hljs-number">1</span>；<span class="hljs-comment">//设置外部中断的触发方式</span><br></code></pre></td></tr></table></figure>



<pre><code class="hljs">    中断服务函数： 
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//void 函数名（）interrupt(中断服务子程序) 0(优先级)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">int0</span> <span class="hljs-params">()</span> interrupt 0 <br><br>&#123;<br>　　<span class="hljs-keyword">do</span> anything that you want<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h1><h2 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h2><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627095510.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627095510"></p>
<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627095754.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627095754"></p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627095758.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627095758"></p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627095800.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627095800"></p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627095802.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627095802"></p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627095808.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627095808"></p>
<h2 id="串口结构"><a href="#串口结构" class="headerlink" title="串口结构"></a>串口结构</h2><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627095919.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627095919"></p>
<h2 id="串行口控制寄存器-SCON"><a href="#串行口控制寄存器-SCON" class="headerlink" title="串行口控制寄存器 SCON"></a>串行口控制寄存器 SCON</h2><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627100401.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627100401"></p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627100403.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627100403"></p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627100406.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627100406"></p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627100408.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627100408"></p>
<h2 id="特殊功能寄存器-PCON"><a href="#特殊功能寄存器-PCON" class="headerlink" title="特殊功能寄存器 PCON"></a>特殊功能寄存器 PCON</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">只有D7位与串口工作有关<br>D7（SMOD）=1 串行口传送的波特率加倍<br></code></pre></td></tr></table></figure>



<h2 id="串行口的四种工作方式"><a href="#串行口的四种工作方式" class="headerlink" title="串行口的四种工作方式"></a>串行口的四种工作方式</h2><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627100702.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627100702"></p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627100705.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627100705"></p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627100707.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627100707"></p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/microcomputer/QQ%E5%9B%BE%E7%89%8720210627100709.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="QQ图片20210627100709"></p>
<h1 id="DA"><a href="#DA" class="headerlink" title="DA"></a>DA</h1><h1 id="AD"><a href="#AD" class="headerlink" title="AD"></a>AD</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/" class="category-chain-item">知识积累</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF/" class="print-no-link">#电子信息</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>微机原理与单片机</div>
      <div>https://blog.cosmicdusty.cc/post/Knowledge/MicrocomputerPrincipleAndSinglechipMicrocomputer/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Murphy</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年6月3日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/post/Knowledge/LearnLinux/" title="《鸟哥的Linux私房菜》">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">《鸟哥的Linux私房菜》</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/post/Ideas/GetYourPhotos/" title="悄无声息获取你的照片">
                        <span class="hidden-mobile">悄无声息获取你的照片</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"JijHNKemeVNog4wF7g9I5TR3-gzGzoHsz","appKey":"FvsKdxHOP2aG5rHrHby5aV0b","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a rel="nofollow noopener"><span>Powered by</span></a> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span><b>Hexo</b></span></a> <i class="iconfont icon-love"></i> <a rel="nofollow noopener"><span>Themed by</span></a> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span><b>Fluid</b></span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量
        <span id="busuanzi_value_site_pv"></span>
        次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数
        <span id="busuanzi_value_site_uv"></span>
        人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
