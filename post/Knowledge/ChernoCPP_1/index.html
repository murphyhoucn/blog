

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/星星.png">
  <link rel="icon" href="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/星星.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Murphy">
  <meta name="keywords" content="Murphy,CosmicDusty,murphy,cosmicdusty,cn">
  
    <meta name="description" content="第一次学习C++还是在2020疫情在家上网课的时候，那时候因为上学期没学习C，只是寒假在家刷了一下C的教程，再加上是在家上网课的授课形式，所以C++学的一塌糊涂，C++一直成为自己的一块儿“心病”。之前也有过学习C++的打算的，但是没有看到很合适的教程，能找到的教程都在教很基础的东西，我听起来也觉得有些无趣。因为前段时间一直都在学习深度学习的东西，学得有点烦，就想学些别的东西换换脑子，也相当于给自">
<meta property="og:type" content="article">
<meta property="og:title" content="ChernoCPP-1">
<meta property="og:url" content="https://cosmicdusty.cc/post/Knowledge/ChernoCPP_1/index.html">
<meta property="og:site_name" content="MurphyHou">
<meta property="og:description" content="第一次学习C++还是在2020疫情在家上网课的时候，那时候因为上学期没学习C，只是寒假在家刷了一下C的教程，再加上是在家上网课的授课形式，所以C++学的一塌糊涂，C++一直成为自己的一块儿“心病”。之前也有过学习C++的打算的，但是没有看到很合适的教程，能找到的教程都在教很基础的东西，我听起来也觉得有些无趣。因为前段时间一直都在学习深度学习的东西，学得有点烦，就想学些别的东西换换脑子，也相当于给自">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231225120947890.png">
<meta property="article:published_time" content="2023-11-13T11:53:39.000Z">
<meta property="article:modified_time" content="2024-01-11T09:02:14.000Z">
<meta property="article:author" content="Murphy">
<meta property="article:tag" content="CPP">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231225120947890.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>ChernoCPP-1 - MurphyHou</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"cosmicdusty.cc","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"16d93d5abbd7ea15ec53daed5459ebf7","google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"JijHNKemeVNog4wF7g9I5TR3","app_key":"FvsKdxHOP2aG5rHrHby5aV0b","server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?16d93d5abbd7ea15ec53daed5459ebf7";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>CosmicDusty</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231225120947890.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="ChernoCPP-1"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Murphy
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-13 19:53" pubdate>
          2023年11月13日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          18k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          149 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">ChernoCPP-1</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Back-to-Top"><a href="#Back-to-Top" class="headerlink" title="Back to Top"></a>Back to Top</h1><h2 id="Video-Links"><a href="#Video-Links" class="headerlink" title="Video Links"></a>Video Links</h2><div align = center>
    <iframe width="560" height="315" src="https://www.youtube.com/embed/18c3MTX0PK0?si=bLufMIg-rIzpv17Y" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
</div>

<h2 id="Notebook-Links"><a href="#Notebook-Links" class="headerlink" title="Notebook Links"></a>Notebook Links</h2><ul>
<li><a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/">📘 The Cherno’s C++ Course Notes 📘</a></li>
<li><a target="_blank" rel="noopener" href="https://space.bilibili.com/364152971/channel/collectiondetail?sid=13909">神经元猫的个人空间-神经元猫个人主页-哔哩哔哩视频 (bilibili.com)</a></li>
</ul>
<h1 id="01-Welcome-to-C"><a href="#01-Welcome-to-C" class="headerlink" title="01. Welcome to C++"></a>01. Welcome to C++</h1><p>C++ for hardware, C++ for game engines</p>
<h1 id="02-04-Setup-C-in-different-OS"><a href="#02-04-Setup-C-in-different-OS" class="headerlink" title="02-04. Setup C++ in different OS"></a>02-04. Setup C++ in different OS</h1><h1 id="05-How-C-works"><a href="#05-How-C-works" class="headerlink" title="05. How C++ works"></a>05. How C++ works</h1><p>preprocessor statement<br>head file<br>main function: entry point</p>
<p>source file(Main.cpp) –compiler–&gt; object files(Main.obj) –linker–&gt; executable file(Main.exe) <em>(Windows platform)</em></p>
<p>source file(file1.cpp, file2.cpp) –compiler–&gt; object files(file1.obj, file2.obj) –linker–&gt; executable file(file.exe) <em>(Windows platform)</em></p>
<p>declaration and defination</p>
<h1 id="06-How-the-C-Compiler-Works"><a href="#06-How-the-C-Compiler-Works" class="headerlink" title="06. How the C++ Compiler Works"></a>06. How the C++ Compiler Works</h1><p>text form to an actual executable binary</p>
<ul>
<li>compiling(cpp-&gt;obj)</li>
<li>linking(obj-&gt;exe)</li>
</ul>
<p>translation unit</p>
<h2 id="preprocessor"><a href="#preprocessor" class="headerlink" title="preprocessor"></a>preprocessor</h2><p>How ‘#include <xxx>‘ works</p>
<p>All the compiler did was open the header file and copy whatever was in here. Let’s see a simple example.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// EndBrace.h</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//Math.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">math</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> result = a * b;<br>  retrun result;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EndBrace.h&quot;</span></span><br></code></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">#include <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">xx</span>&gt;</span></span></span><br><span class="hljs-section">#include &quot;xx&quot;</span><br><span class="hljs-section">#define A B</span><br><br><span class="hljs-section">#if</span><br><span class="hljs-section">#endif</span><br></code></pre></td></tr></table></figure>

<h2 id="what’s-actually-inside-the-obj-file"><a href="#what’s-actually-inside-the-obj-file" class="headerlink" title="what’s actually inside the obj file"></a>what’s actually inside the obj file</h2><p>function signature</p>
<p>the complier’s work: It takes the source files and output an object file which contains machine code and any other constant data that we’ve defined.</p>
<h1 id="07-How-the-C-Linker-Works"><a href="#07-How-the-C-Linker-Works" class="headerlink" title="07. How the C++ Linker Works"></a>07. How the C++ Linker Works</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//Math.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">math</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> result = a * b;<br>  retrun result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="08-Variables-in-C"><a href="#08-Variables-in-C" class="headerlink" title="08. Variables in C++"></a>08. Variables in C++</h1><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231208164738792.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="image-20231208164738792"></p>
<p>int -&gt; 4 Bytes(4×8&#x3D;32 bits) -&gt; (-$2^31$)~($2^31-1$)<br>unsigned int 4 Bytes(4×8&#x3D;32 bits) -&gt; $2^32$<br>char<br>short<br>long<br>long long<br>float -&gt; float var &#x3D; 5.5f;<br>double -&gt; double var &#x3D; 5.5;<br>bool -&gt; 1 Byte (Although it only need 1 bit, 但在从内容中获取bool类型的数据是时候，我们没法寻址到每个bit，这能寻址到每个Byte). 0 means <code>false</code> and any other digits mean <code>true</code>. 为了节约这个内存空间，我们可以把8个bool类型的变量放在1个Byte的内存中，但这个是高级的操作了。</p>
<p><code>sizeof()</code></p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/variables.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="Variable"></p>
<p>pointer: <code>int* a;</code></p>
<p>reference: <code>int&amp; a;</code></p>
<h1 id="09-Functions-in-C"><a href="#09-Functions-in-C" class="headerlink" title="09. Functions in C++"></a>09. Functions in C++</h1><p>function and method</p>
<p>return value</p>
<h1 id="10-C-header-file"><a href="#10-C-header-file" class="headerlink" title="10. C++ header file"></a>10. C++ header file</h1><p><code>.cpp</code> and <code>.h</code></p>
<blockquote>
<p>所谓的头文件，其实它的内容跟 .cpp 文件中的内容是一样的，都是 C++ 的源代码。但头文件不用被编译。我们把所有的函数声明全部放进一个头文件中，当某一个 .cpp 源文件需要它们时，它们就可以通过一个宏命令 “#include” 包含进这个 .cpp 文件中，从而把它们的内容合并到 .cpp 文件中去。当 .cpp 文件被编译时，这些被包含进去的 .h 文件的作用便发挥了。</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/cpp-header.html">理解 C++ 中的头文件和源文件的作用 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">#pragma once</span><br><br>任何一个以‘#’开始的语句都被称作预处理语句，‘pragma’是一个被输入到编译器或者是预处理器的指令，‘pragma once’意思是这说只include这个文件一次。<br>‘pragma once’被称为为‘header guard’(头文件保护符)，其作用是防止我们把单个头文件多次include到一个单一translation unit里。<br></code></pre></td></tr></table></figure>



<p>下面这两种写法等价，都是起到了头文件保护作用。前者是现在常用是格式，后者是之前的代码常用的格式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Log.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitLog</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Log</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* message)</span></span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Player</span> &#123;&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Log.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _LOG_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _LOG_H_</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitLog</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Log</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* message)</span></span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Player</span> &#123;&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<p>#include <xx> &amp; #include “xx.h”<br>&lt;&gt;只用于编译器的include路径，而””可以用于所有。</p>
<p>iostream这个东西看起来不想是文件呀？<br>iostream是一个文件，只不过没有拓展名，是写标准库的人决定这么去干的，为了区分C的标准库和C++的标准库。C标准库的头文件中一般都有‘.h’的拓展名，而C++的没有。</p>
<h1 id="11-How-to-DEBUG-C-in-VISUAL-STUDIO"><a href="#11-How-to-DEBUG-C-in-VISUAL-STUDIO" class="headerlink" title="11. How to DEBUG C++ in VISUAL STUDIO"></a>11. How to DEBUG C++ in VISUAL STUDIO</h1><p>Breakpoints &amp; Reading memory</p>
<h1 id="12-CONDITIONS-and-BRANCHES-in-C-if-statements"><a href="#12-CONDITIONS-and-BRANCHES-in-C-if-statements" class="headerlink" title="12. CONDITIONS and BRANCHES in C++(if statements)"></a>12. CONDITIONS and BRANCHES in C++(if statements)</h1><p>if and else</p>
<p>else if其实并不是一个关键词，而是else和if的一个组合。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1</span><br><span class="hljs-keyword">if</span> (ptr)<br>  <span class="hljs-built_in">Log</span>(ptr);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ptr = <span class="hljs-string">&quot;Hello&quot;</span>)<br>  <span class="hljs-built_in">Log</span>(<span class="hljs-string">&quot;Ptr is Hello&quot;</span>);<br><br><br><span class="hljs-comment">// 2</span><br><span class="hljs-keyword">if</span> (ptr)<br>  <span class="hljs-built_in">Log</span>(ptr);<br><span class="hljs-keyword">else</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (ptr = <span class="hljs-string">&quot;Hello&quot;</span>)<br>    <span class="hljs-built_in">Log</span>(<span class="hljs-string">&quot;Ptr is Hello&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 1和2实际上等价</span><br></code></pre></td></tr></table></figure>


<h1 id="13-BEST-Visual-Studio-Setup-for-C-Projects"><a href="#13-BEST-Visual-Studio-Setup-for-C-Projects" class="headerlink" title="13. BEST Visual Studio Setup for C++ Projects!"></a>13. BEST Visual Studio Setup for C++ Projects!</h1><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231116091704815.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="Virtual folder"></p>
<p>Visual Studio项目中的文件夹是虚拟文件夹，起到一种筛选器的作用。</p>
<div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231116094337168.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="VS C++项目目录更改"></div><div class="group-image-wrap"><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231116094309560.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="Output Directory"></div><div class="group-image-wrap"><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231116094253436.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="Intermediate Directory"></div></div></div>


<blockquote>
<p><code>bin</code> means binary</p>
<ul>
<li>Output Directory: $(SolutionDir)bin$(Platform)$(Configuration)\</li>
<li>Intermediate Directory: $(SolutionDir)bin\intermediate$(Platform)$(Configuration)\</li>
</ul>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/visualstudio/ide/solutions-and-projects-in-visual-studio?view=vs-2022">什么是 Visual Studio 解决方案和项目？ - Visual Studio (Windows) | Microsoft Learn</a></p>
</blockquote>
<h1 id="14-Loops-in-C-for-loops-while-loops"><a href="#14-Loops-in-C-for-loops-while-loops" class="headerlink" title="14. Loops in C++ (for loops, while loops)"></a>14. Loops in C++ (for loops, while loops)</h1><h2 id="for-loops"><a href="#for-loops" class="headerlink" title="for loops"></a>for loops</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>	&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; endl;<br>	&#125;<br><span class="hljs-comment">// step1, 定义变量i并赋值为0</span><br><span class="hljs-comment">// step2, 判断‘i &lt; 5’是否成立，若成立，则进入循环体；若不成立，则退出循环。</span><br><span class="hljs-comment">// step3，执行到“&#125;”时候，执行‘i++’。然后重复2和3。</span><br><br><span class="hljs-comment">// 等价写法</span><br>	<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (; i &lt; <span class="hljs-number">5</span>; )<br>	&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; endl;<br>		i++;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h2 id="while-loops"><a href="#while-loops" class="headerlink" title="while loops"></a>while loops</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>)<br>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; endl;<br>	i++;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>for loops和while loops怎么选择，这两个基本上一样，选择哪个，主要取决于是否需要新变量（当然也无所谓）。for loops中<code>for (int i = 0; i &lt; 5; i++)</code>i是临时变量，跳出循环后i就没有定义了，而在while loops中，i是在循环体之外定义的，所有跳出while loops时，i依然有定义，其值是跳出while loops时i的数值。</p>
<h2 id="do-while-loops"><a href="#do-while-loops" class="headerlink" title="do while loops"></a>do while loops</h2><p>至少会执行循环一次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span><br>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; endl;<br>  i++;<br>&#125; <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure>


<h1 id="15-Control-Flow-in-C-break-continue-return"><a href="#15-Control-Flow-in-C-break-continue-return" class="headerlink" title="15. Control Flow in C++ (break, continue, return)"></a>15. Control Flow in C++ (break, continue, return)</h1><p>continue: loops</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">continue</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>  &#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">i = 0</span><br><span class="hljs-comment">i = 2</span><br><span class="hljs-comment">i = 4</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>break: loops and switch</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">break</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>  &#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">i = 0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>




<p>return: get out of the function entirely</p>
<h1 id="16-Pointer-in-C-⭐"><a href="#16-Pointer-in-C-⭐" class="headerlink" title="16. Pointer in C++ ⭐"></a>16. Pointer in C++ ⭐</h1><ul>
<li>raw pointer(原始指针) ✔</li>
<li>smart pointer(智能指针)</li>
</ul>
<blockquote>
<p>Computer deal with memory. <strong>Memory</strong> is everything to a computer.</p>
</blockquote>
<p>指针用于管理和操控内存。</p>
<blockquote>
<p>A pointer is an integer, a number which stores a <strong>memory address</strong>. That is all that is!</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span>* ptr = <span class="hljs-number">0</span>; <span class="hljs-comment">// 事实上这里的0并不是一个有效的地址，0就是个整数，符合上面说的那句话。</span><br><span class="hljs-type">void</span>* ptr = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//与上面的语句等价，因为C++中NULL的定义就是‘#define NULL 0’</span><br><span class="hljs-type">void</span>* ptr = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// C++ 11中引入的新特性</span><br></code></pre></td></tr></table></figure>

<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231118110801496.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="#define NULL O"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在stack上创建数据</span><br><br>	<span class="hljs-type">int</span> var1 = <span class="hljs-number">5</span>;<br>	<span class="hljs-type">int</span>* ptr1 = &amp;var1;<br>	cout &lt;&lt; <span class="hljs-string">&quot;the memory address of var1 is &quot;</span> &lt;&lt; ptr1 &lt;&lt; endl;<br>	*ptr1 = <span class="hljs-number">10</span>;<br>	cout &lt;&lt; <span class="hljs-string">&quot;the value stored in memory address of var1 is &quot;</span> &lt;&lt; *ptr1 &lt;&lt; endl;<br><br><br>	<span class="hljs-type">int</span> var2 = <span class="hljs-number">6</span>;<br>	<span class="hljs-type">int</span>* ptr2;<br>	ptr2 = &amp;var2;<br>	*ptr2 = <span class="hljs-number">12</span>;<br>	cout &lt;&lt; <span class="hljs-string">&quot;the memory address of var2 is &quot;</span> &lt;&lt; ptr2 &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;the value stored in memory address of var2 is &quot;</span> &lt;&lt; *ptr2 &lt;&lt; endl;<br><br><span class="hljs-comment">//the memory address of var1 is 00DBFAB4</span><br><span class="hljs-comment">//the value stored in memory address of var1 is 10</span><br><span class="hljs-comment">//the memory address of var2 is 00DBFA9C</span><br><span class="hljs-comment">//the value stored in memory address of var2 is 12</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>首先说明,在C++中，内存分为5个区：堆、占、自由存储区、全局&#x2F;静态存储区、常量存储区</p>
<ul>
<li><strong>栈</strong>：是由编译器在需要时自动分配，不需要时自动清除的变量存储区。通常存放局部变量、函数参数等。</li>
<li><strong>堆</strong>：是由new分配的内存块，由程序员释放（编译器不管），一般一个new与一个delete对应，一个new[]与一个delete[]对应。如果程序员没有释放掉,资源将由操作系统在程序结束后自动回收。</li>
<li><strong>自由存储区</strong>：是由malloc等分配的内存块，和堆十分相似，用free来释放。</li>
<li><strong>全局&#x2F;静态存储区</strong>：全局变量和静态变量被分配到同一块内存中（在C语言中，全局变量又分为初始化的和未初始化的，C++中没有这一区分）。</li>
<li><strong>常量存储区</strong>：这是一块特殊存储区，里边存放常量，不允许修改。<br>（注意：堆和自由存储区其实不过是同一块区域（这句话是有问题的，下文解释），new底层实现代码中调用了malloc，new可以看成是malloc智能化的高级版本，详情参见new和malloc的区别及实现方法，  以及这一篇）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/268503784"><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34175893/article/details/83502412">C++中堆（heap）和栈(stack)的区别（面试中被问到的题目）_c++堆和栈的区别-CSDN博客</a></a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>* buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">8</span>]; <span class="hljs-comment">//分配一个8字节的内存，并返回这块内存的开始地址给指针。</span><br><span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>); <span class="hljs-comment">//使用“0”数值填充buffer只想的内存，其内存大小为8 Bytes.</span><br><br><span class="hljs-keyword">delete</span>[] buffer;<br></code></pre></td></tr></table></figure>

<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231118113422225.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="new char[8]?"></p>
<p>double pointer:双重指针（指针变量的指针，用一个指针变量b存储一个指针变量a的地址）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>** ptr = &amp;buffer;<br></code></pre></td></tr></table></figure>



<h1 id="17-Reference-in-C"><a href="#17-Reference-in-C" class="headerlink" title="17. Reference in C++"></a>17. Reference in C++</h1><blockquote>
<p>在计算机如歌处理这两种关键字的角度看，指针和引用基本上是一回事。<br>引用是基于指针的一种（syntax sugar），来使得代码更易读更好学。</p>
</blockquote>
<blockquote>
<p>语法糖就相当于汉语里的成语。即，用更简练的言语表达较复杂的含义。在得到广泛接受的情况之下，可以提升交流的效率。</p>
<p>之所以叫【语法糖】，不只是因为加糖后的代码功能与加糖前保持一致，更重要的是，糖在不改变其所在位置的语法结构的前提下，实现了运行时等价。可以简单理解为，加糖后的代码编译后跟加糖前一毛一样。<br>之所以叫【语法糖】，是因为加糖后的代码写起来很爽，包括但不限于:代码更简洁流畅，代码更语义自然. 写得爽，看着爽，就像吃了糖。效率高，错误少，老公回家早…<br>PS: 据说还有一种叫做【语法盐】的东西，主要目的是通过反人类的语法，让你更痛苦的写代码其实它同样能达到避免代码书写错误的效果，但编程效率应该是降低了，毕竟提高了语法学习门槛，让人咸到忧伤…</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20651624">什么是语法糖？ - 知乎 (zhihu.com)</a></p>
</blockquote>
<p>引用是指对某个<em>已存在</em>的变量的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">  <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br>  <span class="hljs-type">int</span>* b = &amp;a; <span class="hljs-comment">// 这里的&amp;不是引用，而是取变量a的地址。</span><br>  <span class="hljs-type">int</span>&amp; ref = a; <span class="hljs-comment">// 这里的&amp;是引用，&amp;紧跟着变量类型，&amp;是变量类型的一部分。</span><br><br><span class="hljs-comment">// 不是出现了&amp;符号就是引用。做好取地址和引用的区分。</span><br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++">	<span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br>	<span class="hljs-type">int</span>&amp; ref = a; <span class="hljs-comment">// 创建了一个alias(别名)</span><br><span class="hljs-comment">// ref并不是一个变量，而是变量a的一个别名。ref只存在于源码中，编译器编译时，只有a这一个变量。</span><br><br><br><br>  <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br>  <span class="hljs-type">int</span>&amp; ref = a;<br>  ref = <span class="hljs-number">10</span>;<br>  <br>  cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>  cout &lt;&lt; <span class="hljs-string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;<br><br><span class="hljs-comment">// a = 10</span><br><span class="hljs-comment">// ref = 10</span><br><br></code></pre></td></tr></table></figure>

<p>举个例子！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IncreaseValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span><br><span class="hljs-function"></span>&#123;<br>  value++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br>  <span class="hljs-built_in">IncreaseValue</span>(a);<br>  cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>  cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><span class="hljs-comment">// a = 5</span><br><br><span class="hljs-comment">// value的数值增加了，但这里的value只是形式参数，value的值的改变并不会影响实际参数a的数值。</span><br></code></pre></td></tr></table></figure>

<p>要想使用函数把实参a的值进行改变，可以使用指针的方式来实现！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IncreaseValue</span><span class="hljs-params">(<span class="hljs-type">int</span>* value)</span></span><br><span class="hljs-function"></span>&#123;<br>  (*value)++; <span class="hljs-comment">// 这里要考虑多个运算符号的运算先后顺序</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br>  <span class="hljs-built_in">IncreaseValue</span>(&amp;a);<br>  cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>  cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><span class="hljs-comment">// a = 6</span><br><br><span class="hljs-comment">// 使用指针的方法，传到IncreaseValue函数中的不是变量a的值，而是变量a的地址。</span><br><span class="hljs-comment">// 使用*value解引用，把改内存地址上的数值增加，从而改变了变量a的值。</span><br></code></pre></td></tr></table></figure>

<p>使用<strong>指针</strong>可以改变实参a的值，但是使用<strong>引用</strong>能更方便的实现此功能！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IncreaseValue</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; value)</span> </span><br><span class="hljs-function"></span>&#123;<br>  value++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br>  <span class="hljs-built_in">IncreaseValue</span>(a);<br>  cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>  cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><span class="hljs-comment">// a = 6</span><br><br><span class="hljs-comment">// int&amp; value = a; 所以value的变化等价于a的变化。</span><br></code></pre></td></tr></table></figure>

<p>注意：一旦声明了一个引用，就不能更改它所引用的对象了！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">  <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br>  <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><br>  <span class="hljs-type">int</span>&amp; ref = a;<br>  ref = b;<br><br>  cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br><br><span class="hljs-comment">// a = 10</span><br><br><span class="hljs-comment">// ref已经作为变量a的引用了，‘ref = b;’不能把ref作为b的引用，只是把b的数值赋值给了ref，也就是赋值给了a。</span><br></code></pre></td></tr></table></figure>

<p>另外，因为ref并不是一个实际的变量，声明ref的时候必须立刻将其作为一个真正变量的引用！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">  <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><br>  <span class="hljs-type">int</span>&amp; ref; <span class="hljs-comment">// 这是非法的，必须立刻声明ref为真正变量的引用！</span><br>  ref = a;<br><br><span class="hljs-comment">// 1&gt;F:\MicrosoftVisualStudio\Microsoft Visual Studio\MSBuild\Microsoft\VC\v170\Microsoft.CppCommon.targets(741,5): error MSB6006: &quot;CL.exe&quot; exited with code 2.</span><br><span class="hljs-comment">// 1&gt;E:\userDoc\ChernoDevCPP\NewProject\NewProject\src\Main.cpp(7,10): error C2530: &#x27;ref&#x27;: references must be initialized</span><br><span class="hljs-comment">// 1&gt;Done building project &quot;NewProject.vcxproj&quot; -- FAILED.</span><br></code></pre></td></tr></table></figure>


<h1 id="18-Classes-in-C-⭐"><a href="#18-Classes-in-C-⭐" class="headerlink" title="18. Classes in C++⭐"></a>18. Classes in C++⭐</h1><p>Object-Oriented Programming(OOP)</p>
<p>Class and Object（类与对象）</p>
<ul>
<li>C++支持：面向过程、面向对象、基于对象、泛型编程四种类型的编程；</li>
<li>C不支持米那些对象编程；</li>
<li>JAVA, C#只适合面向对象编程（不是不可以其他风格，只是最好编写面向对象编程风格的程序）</li>
</ul>
<blockquote>
<p>类是一种将数据和函数组织在一起的方式。</p>
</blockquote>
<p>在面对很多很多变量的时候，使用class能使得代码更简洁和方便维护。</p>
<p>由类类型定义的变量叫做对象(object)，创建新对象的过程叫做实例化(instance)。</p>
<p>visibility(访问控制)</p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231119152759312.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="visibility(访问控制)"></p>
<p>默认情况下，类中的成员的访问控制都是私有的，意味着只有类内部的函数才能方位这些变量。</p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231119153029355.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="public"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span><br>&#123;<br><span class="hljs-keyword">public</span>: <span class="hljs-comment">// 公有，表示允许在类外访问这些变量</span><br>  <span class="hljs-type">int</span> x, y;<br>  <span class="hljs-type">int</span> speed;<br>&#125;;<br><br><span class="hljs-comment">// 类外的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Move</span><span class="hljs-params">(Player&amp; player, <span class="hljs-type">int</span> xa, <span class="hljs-type">int</span> ya)</span></span><br><span class="hljs-function"></span>&#123;<br>  player.x += xa * player.speed;<br>  player.y += ya * player.speed;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Player player1;<br><br>  player<span class="hljs-number">1.</span>x = <span class="hljs-number">0</span>;<br>  player<span class="hljs-number">1.</span>y = <span class="hljs-number">0</span>;<br>  player<span class="hljs-number">1.</span>speed = <span class="hljs-number">10</span>;<br><br>  <span class="hljs-built_in">Move</span>(player1, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>  cout &lt;&lt; <span class="hljs-string">&quot; x = &quot;</span> &lt;&lt; player<span class="hljs-number">1.</span>x &lt;&lt; endl;<br>  cout &lt;&lt; <span class="hljs-string">&quot; y = &quot;</span> &lt;&lt; player<span class="hljs-number">1.</span>y &lt;&lt; endl;<br><br>  cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p>为了使得代码更简洁，可以把函数写到类内，作为方法。这样可以使得当我们为特定的类调用Move函数的时候就是调用他自己的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span><br>&#123;<br><span class="hljs-keyword">public</span>: <span class="hljs-comment">// 公有，表示允许在类外访问这些变量</span><br>  <span class="hljs-type">int</span> x, y;<br>  <span class="hljs-type">int</span> speed;<br><br>  <span class="hljs-comment">// 在类内定义函数</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Move</span><span class="hljs-params">(<span class="hljs-type">int</span> xa, <span class="hljs-type">int</span> ya)</span> <span class="hljs-comment">// 类内的函数我们叫它为&quot;方法&quot;（methods）</span></span><br><span class="hljs-function">  </span>&#123;<br>    x += xa * speed;<br>    y += ya * speed;<br>  &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Player player1;<br><br>  player<span class="hljs-number">1.</span>x = <span class="hljs-number">0</span>;<br>  player<span class="hljs-number">1.</span>y = <span class="hljs-number">0</span>;<br>  player<span class="hljs-number">1.</span>speed = <span class="hljs-number">10</span>;<br><br>  player<span class="hljs-number">1.</span><span class="hljs-built_in">Move</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>  cout &lt;&lt; <span class="hljs-string">&quot; x = &quot;</span> &lt;&lt; player<span class="hljs-number">1.</span>x &lt;&lt; endl;<br>  cout &lt;&lt; <span class="hljs-string">&quot; y = &quot;</span> &lt;&lt; player<span class="hljs-number">1.</span>y &lt;&lt; endl;<br><br>  cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>类也是一种语法糖。</p>
<h1 id="19-Classes-vs-Struct-in-C"><a href="#19-Classes-vs-Struct-in-C" class="headerlink" title="19. Classes vs Struct in C++"></a>19. Classes vs Struct in C++</h1><p>C++中Class和Struct有什么区别？</p>
<ul>
<li>基本上没什么区别😅</li>
<li>使用 class 时，类中的成员默认都是 <code>private</code> 属性的，而使用 struct 时，结构体中的成员默认都是 <code>public</code> 属性的.</li>
<li>C++中struct存在的唯一原因是因为它想要维持与C之间的兼容性，因为C中没有类但有结构体。如果把C++中的struct删除之后，C++与C存在兼容性问题。</li>
<li>C++中class与struct的使用，主要还是有个人编程风格决定吧。<ul>
<li>在讨论Plain Old Data(POD)时候，使用struct； 在讨论比较复杂功能的时候，使用class；</li>
<li>在使用继承的时候，使用class；</li>
</ul>
</li>
</ul>
<blockquote>
<p>在 <strong><a target="_blank" rel="noopener" href="https://haicoder.net/c/c-tutorial.html">C 语言</a></strong> 中，**<a target="_blank" rel="noopener" href="https://haicoder.net/c/c-struct.html">结构体</a>** 只能存放一些 <strong><a target="_blank" rel="noopener" href="https://haicoder.net/c/c-variable.html">变量</a></strong> 的集合，并不能有 **<a target="_blank" rel="noopener" href="https://haicoder.net/c/c-function.html">函数</a>**，但 <strong>C++</strong> 中的结构体对 C 语言中的结构体做了扩充，可以有函数，因此 C++ 中的结构体跟 C++ 中的类很类似。C++ 中的 struct 可以包含成员函数，也能继承，也可以实现多态。</p>
<p>但在 C++ 中，使用 class 时，类中的成员默认都是 <strong><a target="_blank" rel="noopener" href="https://haicoder.net/c/c-keywords.html">private</a></strong> 属性的，而使用 struct 时，结构体中的成员默认都是 public 属性的。class 继承默认是 private 继承，而 struct 继承默认是 public 继承。</p>
<p>C++ 中的 class 可以使用模板，而 struct 不能使用模板。</p>
<p><a target="_blank" rel="noopener" href="https://haicoder.net/cpp/cpp-class-struct.html">C++ class和struct区别-C++类与结构体区别-嗨客网 (haicoder.net)</a></p>
</blockquote>
<blockquote>
<p>POD 是 Plain Old Data 的缩写，是 C++ 定义的一类数据结构概念，比如 int、float 等都是 POD 类型的。Plain 代表它是一个普通类型，Old 代表它是旧的，与几十年前的 C 语言兼容，那么就意味着可以使用 memcpy() 这种最原始的函数进行操作。两个系统进行交换数据，如果没有办法对数据进行语义检查和解释，那就只能以非常底层的数据形式进行交互，而拥有 POD 特征的类或者结构体通过二进制拷贝后依然能保持数据结构不变。<strong>也就是说，能用 C 的 memcpy() 等函数进行操作的类、结构体就是 POD 类型的数据</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/45545035">什么是 POD 数据类型？ - 知乎 (zhihu.com)</a></p>
</blockquote>
<h1 id="20-How-to-write-a-C-Class"><a href="#20-How-to-write-a-C-Class" class="headerlink" title="20. How to write a C++ Class"></a>20. How to write a C++ Class</h1><p>Log Class: error, warning and message or trace.</p>
<p>插一个VS使用小技巧，如何让VS和VSCode一样有代码预览窗口。</p>
<div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231119164236488.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="image-20231119164236488"></div><div class="group-image-wrap"><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231119164315161.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="image-20231119164315161"></div><div class="group-image-wrap"><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231119164327659.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="image-20231119164327659"></div></div></div>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Log</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span> LogLevelError = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span> LogLevelWarning = <span class="hljs-number">1</span>;<br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span> LogLevelInfo = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> m_LogLevel = LogLevelInfo;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetLevel</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span></span><br><span class="hljs-function">	</span>&#123;<br>		m_LogLevel = level;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Error</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* message)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">if</span> (m_LogLevel &gt;= LogLevelError)<br>			cout &lt;&lt; <span class="hljs-string">&quot;[ERROR]:&quot;</span> &lt;&lt; message &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Warn</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* message)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">if</span> (m_LogLevel &gt;= LogLevelWarning)<br>			cout &lt;&lt; <span class="hljs-string">&quot;[WARNING]:&quot;</span> &lt;&lt; message &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Info</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* message)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">if</span> (m_LogLevel &gt;= LogLevelInfo)<br>			cout &lt;&lt; <span class="hljs-string">&quot;[INFO]:&quot;</span> &lt;&lt; message &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-comment">// Log类中出现了两个public，只是因为这是一种个人的编程风格。把公共变量放在一部分，把公共方法放在一部分……</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Log log;<br><br>	log.<span class="hljs-built_in">SetLevel</span>(log.LogLevelError);<br><br>	log.<span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Hello error!&quot;</span>);<br>	log.<span class="hljs-built_in">Warn</span>(<span class="hljs-string">&quot;Hello warning!&quot;</span>);<br>	log.<span class="hljs-built_in">Info</span>(<span class="hljs-string">&quot;Hello info!&quot;</span>);<br><br>	cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="21-Static-in-C"><a href="#21-Static-in-C" class="headerlink" title="21. Static in C++"></a>21. Static in C++</h1><p class="note note-info">Static这部分从21~23</p>

<div class="note note-info">
            <p>Static这部分从21~23</p>
          </div>


<ul>
<li>类或结构体内的静态变量</li>
<li>类或结构体外的静态变量</li>
</ul>
<blockquote>
<p>static 是 C&#x2F;C++ 中很常用的修饰符，它被用来控制变量的存储方式和可见性。</p>
<p>static 关键字用来解决全局变量的访问范围问题</p>
<ul>
<li>（1）在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。</li>
<li>（2）static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 <strong>extern</strong> 外部声明也不可以。</li>
<li>（3）static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。</li>
<li>（4）不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。</li>
<li>（5）考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/cpp-static-usage.html">C&#x2F;C++ 中 static 的用法全局变量与局部变量 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<h1 id="22-Static-for-Classes-and-Struct-in-C"><a href="#22-Static-for-Classes-and-Struct-in-C" class="headerlink" title="22. Static for Classes and Struct in C++"></a>22. Static for Classes and Struct in C++</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Entity</span><br>&#123;<br>	<span class="hljs-type">int</span> num;<br><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; num &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Entity e1;<br>	e<span class="hljs-number">1.</span>num = <span class="hljs-number">2</span>;<br><br>	Entity e2;<br>	e<span class="hljs-number">2.</span>num = <span class="hljs-number">5</span>;<br><br>	cout &lt;&lt; e<span class="hljs-number">1.</span>num &lt;&lt; endl; <span class="hljs-comment">// 2</span><br>	cout &lt;&lt; e<span class="hljs-number">2.</span>num &lt;&lt; endl; <span class="hljs-comment">//5</span><br><br>	cout &lt;&lt; &amp;(e<span class="hljs-number">1.</span>num) &lt;&lt; endl; <span class="hljs-comment">// 008FFBC4</span><br>	cout &lt;&lt; &amp;(e<span class="hljs-number">2.</span>num) &lt;&lt; endl; <span class="hljs-comment">// 008FFBB8</span><br><br>	cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面这段代码比较容易理解，e1和e1是结构体Entity的两个不同的实例，不同实例中的num是不同的变量，我们从两个变量的地址也可以看得出来。</p>
<p>如果把结构体Entity的变量变为static类型的话，情况又有什么不一样呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 仅仅把‘int num;’改为‘static int num;’可以吗？</span><br><span class="hljs-comment"># 不可以！在‘ctrl+F7’编译单个代码文件时成功了，但是在允许代码时候会有“链接错误”。</span><br><br>09:36:12:204	1&gt;Main.obj : error LNK2001: unresolved external symbol <span class="hljs-string">&quot;public: static int Entity::num&quot;</span> (?num@Entity@@2HA)<br>09:36:12:250	1&gt;E:\userDoc\ChernoDevCPP\NewProject\bin\Win32\Debug\NewProject.exe : fatal error LNK1120: 1 unresolved externals<br></code></pre></td></tr></table></figure>

<p>要解决这个问题，我们必须在代码中定义这些静态变量，像这样，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> Entity::num;<br></code></pre></td></tr></table></figure>

<p>现在代码能运行了，看一下结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Entity</span><br>&#123;<br>	<span class="hljs-type">static</span> <span class="hljs-type">int</span> num;<br><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; num &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-type">int</span> Entity::num; <span class="hljs-comment">// 定义这些静态变量，让链接器能连接到这些变量</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Entity e1;<br>	e<span class="hljs-number">1.</span>num = <span class="hljs-number">2</span>;<br><br>	Entity e2;<br>	e<span class="hljs-number">2.</span>num = <span class="hljs-number">5</span>;<br><br>	cout &lt;&lt; e<span class="hljs-number">1.</span>num &lt;&lt; endl; <span class="hljs-comment">// 5</span><br>	cout &lt;&lt; e<span class="hljs-number">2.</span>num &lt;&lt; endl; <span class="hljs-comment">// 5</span><br><br>	cout &lt;&lt; &amp;(e<span class="hljs-number">1.</span>num) &lt;&lt; endl; <span class="hljs-comment">// 00BCA138</span><br>	cout &lt;&lt; &amp;(e<span class="hljs-number">2.</span>num) &lt;&lt; endl; <span class="hljs-comment">// 00BCA138</span><br><br>	cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以，<code>e1.num</code>和<code>e2.num</code>本质上都是同一个变量，所以这样的写法是没有意义的。可以写成如下的形式，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Entity</span><br>&#123;<br>	<span class="hljs-type">static</span> <span class="hljs-type">int</span> num;<br><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; num &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-type">int</span> Entity::num;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Entity e1;<br>	Entity::num = <span class="hljs-number">2</span>;<br><br>	Entity e2;<br>	Entity::num = <span class="hljs-number">5</span>;<br><br>	cout &lt;&lt; Entity::num &lt;&lt; endl; <span class="hljs-comment">// 5</span><br>	cout &lt;&lt; Entity::num &lt;&lt; endl; <span class="hljs-comment">// 5</span><br><br>	cout &lt;&lt; &amp;(Entity::num) &lt;&lt; endl; <span class="hljs-comment">// 00BCA138</span><br>	cout &lt;&lt; &amp;(Entity::num) &lt;&lt; endl; <span class="hljs-comment">// 00BCA138</span><br><br>	cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>⭐⭐⭐<a target="_blank" rel="noopener" href="https://blog.csdn.net/oXiaoLingTong/article/details/123472985">深入学习C++——21~23静态_c++ 21_范子琦的博客-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_62953519/article/details/124178721">C++学习笔记：static关键字在类和结构体中的作用【Cherno】<em>结构体加static</em>刘欢明的博客-CSDN博客</a></li>
</ul>
</blockquote>
<h1 id="23-Local-Static-in-C-⭐"><a href="#23-Local-Static-in-C-⭐" class="headerlink" title="23.Local Static in C++⭐"></a>23.Local Static in C++⭐</h1><ul>
<li>生命周期（lifetime）</li>
<li>作用域（scope）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Function</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>	i++;<br>	cout &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">Function</span>();<br>	<span class="hljs-built_in">Function</span>();<br>	<span class="hljs-built_in">Function</span>();<br><br>	<span class="hljs-comment">// cout &lt;&lt; &quot;main: i = &quot; &lt;&lt; i &lt;&lt; endl; // Compilation error</span><br>	cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><span class="hljs-comment">//i = 1</span><br><span class="hljs-comment">//i = 1</span><br><span class="hljs-comment">//i = 1</span><br><br><span class="hljs-comment">// i是定义在函数Function中的变量，其作用域和生存时间都是在函数Function内部，从main函数中就是访问不到变量i了。</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Function</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  i++;<br>  cout &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">Function</span>();<br>  <span class="hljs-built_in">Function</span>();<br>  <span class="hljs-built_in">Function</span>();<br><br>  cout &lt;&lt; <span class="hljs-string">&quot;main: i = &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>  cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><span class="hljs-comment">// i = 1</span><br><span class="hljs-comment">// i = 2</span><br><span class="hljs-comment">// i = 3</span><br><span class="hljs-comment">// main: i = 3</span><br><br><span class="hljs-comment">// i定义在了函数外部，所以是个全局变量，其作用域和生存时间都是在整个程序中，这样就可以在main函数中访问到了i。</span><br></code></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Function</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  i++;<br>  cout &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">Function</span>();<br>  <span class="hljs-built_in">Function</span>();<br>  <span class="hljs-built_in">Function</span>();<br><br>  <span class="hljs-comment">// cout &lt;&lt; &quot;main: i = &quot; &lt;&lt; i &lt;&lt; endl; // Compilation error</span><br>  cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><br><span class="hljs-comment">//i = 1</span><br><span class="hljs-comment">//i = 2</span><br><span class="hljs-comment">//i = 3</span><br><br><span class="hljs-comment">// static声明的i是静态变量，这样的效果和全局变量类似，但是并不能在所有函数中访问到i，i的作用域仅在其所定义的函数内部。</span><br></code></pre></td></tr></table></figure>

<h1 id="24-Enums-in-C"><a href="#24-Enums-in-C" class="headerlink" title="24. Enums in C++"></a>24. Enums in C++</h1><blockquote>
<p>枚举类型的定义：枚举类型(enumeration)是 C++ 中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> &lt;类型名&gt; &#123;&lt;枚举常量表&gt;&#125;;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/cpp-enum-intro.html">C++ 枚举类型详解 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<h1 id="25-Constructors-in-C"><a href="#25-Constructors-in-C" class="headerlink" title="25. Constructors in C++"></a>25. Constructors in C++</h1><p>Constructors是一种特殊的method，它在实例化时被调用。</p>
<blockquote>
<p>类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。</p>
<p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-constructor-destructor.html">C++ 类构造函数 &amp; 析构函数 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<ol>
<li>对于一个类，在实例化之后，如果直接调用类内的变量，会用链接错误，因为类内的变量未被初始化。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">float</span> X, Y;<br><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; X &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; Y &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Entity e;<br>	cout &lt;&lt; e.X &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; e.Y &lt;&lt; endl;  <span class="hljs-comment">// linking error</span><br>	e.<span class="hljs-built_in">Print</span>();<br><br>	cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><span class="hljs-comment">// error C4700: uninitialized local variable &#x27;e&#x27; used</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>手动初始化。在类内定义一个初始化函数，把类内的变量初始化一个值，这样就不会有链接错误了。但这样不够<em>优雅</em>，在类有多个实例化时，需要每次实例化之后都使用这个初始化函数。而C++提供了更优雅有效的方式，就是构造函数（Constructors）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">float</span> X, Y;<br><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; X &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; Y &lt;&lt; endl;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		X = <span class="hljs-number">0.0f</span>;<br>		Y = <span class="hljs-number">0.0f</span>;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Entity e;<br>	e.<span class="hljs-built_in">Init</span>();<br>	cout &lt;&lt; e.X &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; e.Y &lt;&lt; endl;<br>	e.<span class="hljs-built_in">Print</span>();<br><br>	cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>Constructors是一种特殊的method，它在实例化时被调用以初始化实例。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">float</span> X, Y;<br><br>	<span class="hljs-built_in">Entity</span>() <span class="hljs-comment">//Constructor method的名字和类名相同，没有返回值</span><br>	&#123;<br>		X = <span class="hljs-number">0.0f</span>;<br>		Y = <span class="hljs-number">0.0f</span>;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; X &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; Y &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Entity e;<br>	cout &lt;&lt; e.X &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; e.Y &lt;&lt; endl;<br>	e.<span class="hljs-built_in">Print</span>();<br><br>	cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在C++中其实有一个默认的Constructor，但是它本身不做任何事情，方法内部是空的，就像这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Entity</span>() <span class="hljs-comment">//Constructor method的名字和类名相同，没有返回值</span><br>&#123;<br>       <br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此，C++不能自动帮我们初始化内存空间，得自己手动完成这个过程。</p>
<ol start="4">
<li>含参数的构造函数。<code>3</code>中，类中变量的初始化数值是在类中写定的，使用含参数的构造函数能在实例化的时候确定类中变量的初始化数值，如下</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">float</span> X, Y;<br><br>	<span class="hljs-built_in">Entity</span>(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y)<br>	&#123;<br>		X = x;<br>		Y = y;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; X &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; Y &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-function">Entity <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-number">5.0f</span>, <span class="hljs-number">6.0f</span>)</span></span>;<br>	cout &lt;&lt; e.X &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; e.Y &lt;&lt; endl;<br>	e.<span class="hljs-built_in">Print</span>();<br><br>	cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="26-Destructors-in-C"><a href="#26-Destructors-in-C" class="headerlink" title="26. Destructors in C++"></a>26. Destructors in C++</h1><ul>
<li>Constructor:构造函数</li>
<li>Destructors： 析构函数</li>
</ul>
<p>构造函数通常是设置变量的地方启动或执行所需要执行的任何类型的初始化，类似的，析构函数是取消初始化任何内容的地方你可能需要删除或清楚任何已使用的内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">float</span> X, Y;<br><br>	<span class="hljs-built_in">Entity</span>() <span class="hljs-comment">// 构造函数</span><br>	&#123;<br>		X = <span class="hljs-number">0.0f</span>;<br>		Y = <span class="hljs-number">0.0f</span>;<br>		cout &lt;&lt; <span class="hljs-string">&quot;Created Entity!&quot;</span> &lt;&lt; endl;<br>	&#125;<br><br>	~<span class="hljs-built_in">Entity</span>() <span class="hljs-comment">// 析构函数</span><br>	&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;Destroyed Entity!&quot;</span> &lt;&lt; endl;<br>	&#125;<br><br><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; X &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; Y &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Function</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Entity e;<br>	e.<span class="hljs-built_in">Print</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">Function</span>();<br>	cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Created Entity!</span><br><span class="hljs-comment">0, 0</span><br><span class="hljs-comment">Destroyed Entity!</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">E:\userDoc\ChernoDevCPP\NewProject\bin\Win32\Debug\NewProject.exe (process 22128) exited with code 0.</span><br><span class="hljs-comment">Press any key to close this window . . .</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>析构函数在类的实例化是生命周期末期被调用！<br>如上面的代码，“Entity e;”创造了一个实例化e，这时候调用构造函数，函数“Function()”是实例化的作用域，“Function()”函数结束的时候，调用了析构函数。<br>如果不使用析构函数，可能会导致内存泄漏。</p>
<h1 id="27-Inheritance-in-C-⭐"><a href="#27-Inheritance-in-C-⭐" class="headerlink" title="27. Inheritance in C++⭐"></a>27. Inheritance in C++⭐</h1><p>继承提供了一种来实现把多个类之间的公共代码转换为基类的方式，就像是一种模板。</p>
<p>Polymorphic(多态)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">float</span> X, Y;<br><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Move</span><span class="hljs-params">(<span class="hljs-type">float</span> xa, <span class="hljs-type">float</span> ya)</span></span><br><span class="hljs-function">	</span>&#123;<br>		X += xa;<br>		Y += ya;<br>	&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> : <span class="hljs-keyword">public</span> Entity<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">const</span> <span class="hljs-type">char</span>* Name;<br><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintName</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; Name &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Player player;<br><br>	player.Name = <span class="hljs-string">&quot;Tom&quot;</span>;<br><br>	player.X = <span class="hljs-number">0</span>;<br>	player.Y = <span class="hljs-number">0</span>;<br>	player.<span class="hljs-built_in">Move</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);<br><br>	player.<span class="hljs-built_in">PrintName</span>();<br><br>	cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>继承 (inheritance) 就是在一个已存在的类的基础上建立一个新的类.</p>
<ul>
<li>已存在的类: 基类 (base class) 或父类 (father class)</li>
<li>新建立的类: 派生类 (derived class) 或子类 (son class)</li>
<li>一个新类从已有的类获得其已有特性, 称为类的继承.</li>
<li>通过继承, 一个新建的子类从已有的父类那里获得父类的特性</li>
<li>派生类继承了基类的所有数据成员和成员函数, 并可以对成员做必要的增加或调整</li>
</ul>
<p>从已有的类 (父类) 产生一个新的子类, 称为类的派生.</p>
<ul>
<li>类的继承是用已有的类来建立专用新类的编程技术</li>
<li>一个基类可以派生出多个派生类, 每一个派生类又可以作为基类再派生出新的派生类. 因此基类和派生类是相对而言的</li>
<li>派生类是基类的具体化, 而基类则是派生类的抽象</li>
</ul>
<blockquote>
<p>版权声明：本文为CSDN博主「我是小白呀」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46274168/article/details/11659272">https://blog.csdn.net/weixin_46274168/article/details/11659272</a></p>
</blockquote>
</blockquote>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态<em>polymorphism</em>,基本上来说就是使用一个单一的符号来表示多个不同的类型</p>
<h1 id="28-Virtual-functions-in-C-⭐"><a href="#28-Virtual-functions-in-C-⭐" class="headerlink" title="28. Virtual functions in C++⭐"></a>28. Virtual functions in C++⭐</h1><p>Virtual functions(虚函数)</p>
<p>虚函数允许我们覆盖基类中的方法。</p>
<p>虚函数引入了一种动态分配（Dynamic Dispatch）的东西，通常使用VTable（虚函数表）来实现编译。VTable中包含基类中所有虚函数的映射，以便我们能在运行时映射它们向正确的覆写函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function">string <span class="hljs-title">GetName</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Entity&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> : <span class="hljs-keyword">public</span> Entity<br>&#123;<br><span class="hljs-keyword">private</span>:<br>	string m_Name;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Player</span>(<span class="hljs-type">const</span> string&amp; name) : <span class="hljs-built_in">m_Name</span>(name) &#123;&#125;<br><br>	<span class="hljs-function">string <span class="hljs-title">GetName</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> m_Name; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintName</span><span class="hljs-params">(Entity* entity)</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; entity-&gt;<span class="hljs-built_in">GetName</span>() &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Entity* e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Entity</span>();<br>	<span class="hljs-built_in">PrintName</span>(e);<br><br>	Player* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Player</span>(<span class="hljs-string">&quot;Cherno&quot;</span>);<br>	<span class="hljs-built_in">PrintName</span>(p);<br><br>	cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><span class="hljs-comment">// Entity</span><br><span class="hljs-comment">// Entity</span><br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">GetName</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Entity&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> : <span class="hljs-keyword">public</span> Entity<br>&#123;<br><span class="hljs-keyword">private</span>:<br>	string m_Name;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Player</span>(<span class="hljs-type">const</span> string&amp; name) : <span class="hljs-built_in">m_Name</span>(name) &#123;&#125;<br><br>	<span class="hljs-function">string <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> m_Name; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintName</span><span class="hljs-params">(Entity* entity)</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; entity-&gt;<span class="hljs-built_in">GetName</span>() &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Entity* e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Entity</span>();<br>	<span class="hljs-built_in">PrintName</span>(e);<br><br>	Player* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Player</span>(<span class="hljs-string">&quot;Cherno&quot;</span>);<br>	<span class="hljs-built_in">PrintName</span>(p);<br><br>	cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><span class="hljs-comment">// Entity</span><br><span class="hljs-comment">// Cherno</span><br></code></pre></td></tr></table></figure>

<h1 id="29-Interfaces-in-C-Pure-Virtual-Functions-⭐"><a href="#29-Interfaces-in-C-Pure-Virtual-Functions-⭐" class="headerlink" title="29. Interfaces in C++(Pure Virtual Functions)⭐"></a>29. Interfaces in C++(Pure Virtual Functions)⭐</h1><p>Pure Virtual Functions(纯虚函数)，C++中的纯虚函数的本质上犹如Java和C#中的抽象方法和<strong>接口</strong>。<br>原理上来讲，纯虚函数允许我们定义一个在基类中没有实现的函数，然后迫使在子类中实际实现，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Printable</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">GetClassName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// pure virtual function</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span> : <span class="hljs-keyword">public</span> Printable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">GetName</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Entity&quot;</span>; &#125;<br>	<span class="hljs-function">string <span class="hljs-title">GetClassName</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Entity&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> : <span class="hljs-keyword">public</span> Entity<br>&#123;<br><span class="hljs-keyword">private</span>:<br>	string m_Name;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Player</span>(<span class="hljs-type">const</span> string&amp; name) : <span class="hljs-built_in">m_Name</span>(name) &#123;&#125;<br><br>	<span class="hljs-function">string <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> m_Name; &#125;<br>	<span class="hljs-function">string <span class="hljs-title">GetClassName</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Palyer&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintName</span><span class="hljs-params">(Entity* entity)</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; entity-&gt;<span class="hljs-built_in">GetName</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(Printable* obj)</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; obj-&gt;<span class="hljs-built_in">GetClassName</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Entity* e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Entity</span>();<br>	<span class="hljs-comment">// PrintName(e);</span><br><br>	Player* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Player</span>(<span class="hljs-string">&quot;Cherno&quot;</span>);<br>	<span class="hljs-comment">// PrintName(p);</span><br><br>	<span class="hljs-built_in">Print</span>(e);<br>	<span class="hljs-built_in">Print</span>(p);<br><br>	cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="30-Visibility-in-C"><a href="#30-Visibility-in-C" class="headerlink" title="30. Visibility in C++"></a>30. Visibility in C++</h1><p>private, protected, public</p>
<ul>
<li>private<blockquote>
<h2 id="私有（private）成员"><a href="#私有（private）成员" class="headerlink" title="私有（private）成员"></a>私有（private）成员</h2></blockquote>
</li>
</ul>
<blockquote>
<p><strong>私有</strong>成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有<strong>类</strong>和<strong>友元函数</strong>可以访问私有成员。</p>
<p>默认情况下，类的所有成员都是私有的。</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-class-access-modifiers.html">C++ 类访问修饰符 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br>	<span class="hljs-comment">// int X, Y; // 如果类中定义的变量没有指定visibility，则默认就是private。</span><br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> X;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Entity</span>()<br>	&#123;<br>		X = <span class="hljs-number">0</span>; <span class="hljs-comment">// right!</span><br>	&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> : <span class="hljs-keyword">public</span> Entity<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Player</span>()<br>	&#123;<br>		<span class="hljs-comment">// X = 10; // error!</span><br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Entity e;<br>	<span class="hljs-comment">// e.X = 10; // error!</span><br>	cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>protected</li>
</ul>
<blockquote>
<p><strong>protected（受保护）</strong>成员变量或函数与私有成员十分相似，但有一点不同，protected（受保护）成员在派生类（即子类）中是可访问的。</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-class-access-modifiers.html">C++ 类访问修饰符 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br>	<span class="hljs-type">int</span> X;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Entity</span>()<br>	&#123;<br>		X = <span class="hljs-number">0</span>; <span class="hljs-comment">// right!</span><br>		<span class="hljs-built_in">Print</span>(); <span class="hljs-comment">// right!</span><br>	&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> : <span class="hljs-keyword">public</span> Entity<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Player</span>()<br>	&#123;<br>		X = <span class="hljs-number">10</span>; <span class="hljs-comment">// right!</span><br>		<span class="hljs-built_in">Print</span>(); <span class="hljs-comment">// right!</span><br>	&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Entity e;<br>	<span class="hljs-comment">//e.X = 10; // error!</span><br>	cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>public</li>
</ul>
<blockquote>
<p><strong>公有</strong>成员在程序中类的外部是可访问的。</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-class-access-modifiers.html">C++ 类访问修饰符 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">int</span> X;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Entity</span>()<br>	&#123;<br>		X = <span class="hljs-number">0</span>; <span class="hljs-comment">// right!</span><br>		<span class="hljs-built_in">Print</span>(); <span class="hljs-comment">// right!</span><br>	&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> : <span class="hljs-keyword">public</span> Entity<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Player</span>()<br>	&#123;<br>		X = <span class="hljs-number">10</span>; <span class="hljs-comment">// right!</span><br>		<span class="hljs-built_in">Print</span>(); <span class="hljs-comment">// right!</span><br>	&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Entity e;<br>	e.X = <span class="hljs-number">10</span>; <span class="hljs-comment">// right!</span><br>	e.<span class="hljs-built_in">Print</span>(); <span class="hljs-comment">// right!</span><br>	cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="31-Arrays-in-C"><a href="#31-Arrays-in-C" class="headerlink" title="31. Arrays in C++"></a>31. Arrays in C++</h1><h2 id="Array-and-Pointer"><a href="#Array-and-Pointer" class="headerlink" title="Array and Pointer"></a>Array and Pointer</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> example[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span>* ptr = example;<br><br>example[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;example[2] =&quot;</span> &lt;&lt; example[<span class="hljs-number">2</span>] &lt;&lt; endl;<br><br>*(ptr + <span class="hljs-number">2</span>) = <span class="hljs-number">20</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;example[2] =&quot;</span> &lt;&lt; example[<span class="hljs-number">2</span>] &lt;&lt; endl;<br><br>*(<span class="hljs-type">int</span>*)((<span class="hljs-type">char</span>*)ptr + <span class="hljs-number">8</span>) = <span class="hljs-number">30</span>; <span class="hljs-comment">// 两次强制类型转换</span><br>cout &lt;&lt; <span class="hljs-string">&quot;example[2] =&quot;</span> &lt;&lt; example[<span class="hljs-number">2</span>] &lt;&lt; endl;<br># 这三行代码等价！ptr<span class="hljs-number">+2</span>中的“<span class="hljs-number">2</span>”并不是数值<span class="hljs-number">2</span>，指针<span class="hljs-number">+2</span>的时候会自动根据数据类型来计算实际的字节数。<br></code></pre></td></tr></table></figure>

<h2 id="Stack-and-Heap"><a href="#Stack-and-Heap" class="headerlink" title="Stack and Heap"></a>Stack and Heap</h2><blockquote>
<p><strong>Stack:</strong></p>
<ol>
<li>和堆一样存储在计算机 RAM 中。</li>
<li>在栈上创建变量的时候会扩展，并且会自动回收。</li>
<li>相比堆而言在栈上分配要快的多。</li>
<li>用数据结构中的栈实现。</li>
<li>存储局部数据，返回地址，用做参数传递。</li>
<li>当用栈过多时可导致栈溢出（无穷次（大量的）的递归调用，或者大量的内存分配）。</li>
<li>在栈上的数据可以直接访问（不是非要使用指针访问）。</li>
<li>如果你在编译之前精确的知道你需要分配数据的大小并且不是太大的时候，可以使用栈。</li>
<li>当你程序启动时决定栈的容量上限。</li>
</ol>
<p><strong>Heap：</strong></p>
<ol>
<li>和栈一样存储在计算机RAM。</li>
<li>在堆上的变量必须要手动释放，不存在作用域的问题。数据可用 delete, delete[] 或者 free 来释放。</li>
<li>相比在栈上分配内存要慢。</li>
<li>通过程序按需分配。</li>
<li>大量的分配和释放可造成内存碎片。</li>
<li>在 C++ 中，在堆上创建数的据使用指针访问，用 new 或者 malloc 分配内存。</li>
<li>如果申请的缓冲区过大的话，可能申请失败。</li>
<li>在运行期间你不知道会需要多大的数据或者你需要分配大量的内存的时候，建议你使用堆。</li>
<li>可能造成内存泄露。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/101531768">什么是堆? 什么是栈？ - 知乎 (zhihu.com)</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> arr1[<span class="hljs-number">5</span>]; <span class="hljs-comment">// an array created on the stack</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>    arr1[i] = i;<br>&#125;<br><br><span class="hljs-type">int</span>* arr2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">// an array created on the heap</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>    arr2[i] = i;<br>&#125;<br><span class="hljs-keyword">delete</span>[] arr2;<br><br><span class="hljs-comment">// arr1的生命周期结束后，内存空间会被自动回收。</span><br><span class="hljs-comment">// arr2没有生命周期的概念，必须手动来释放。</span><br></code></pre></td></tr></table></figure>

<p>这里发现了一个新且有趣的知识点！在stack上定义的变量，自动初始化为“cccc”，而在heap上定义的变量，是自动初始化为“cdcd”，不知道是为什么会这样？？</p>
<div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231208163944488.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="image-20231208163944488"></div><div class="group-image-wrap"><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231208164302702.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="image-20231208164302702"></div></div></div>

<h2 id="C-11-standard-array"><a href="#C-11-standard-array" class="headerlink" title="C++11 standard array"></a>C++11 standard array</h2><ol>
<li>size of array</li>
</ol>
<p>在原生数组中，计算数组的大小使用<code>sizeof()</code>方法，但是这种方法也仅仅适用于定义在stack上的数组；对于定义在heap上的数组，使用<code>sizeof()</code>后，返回值是指针的大小，下面的例子中，返回值是4，即整型类型的指针的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">int</span> array1[<span class="hljs-number">5</span>];<br>	<span class="hljs-type">int</span>* array2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br><br>	<span class="hljs-built_in">Entity</span>()<br>	&#123;<br>		<span class="hljs-type">int</span> count = <span class="hljs-built_in">sizeof</span>(array1) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>); <span class="hljs-comment">// 4*5 / 4 = 5 </span><br>		cout &lt;&lt; <span class="hljs-string">&quot;count of array1 is &quot;</span> &lt;&lt; count &lt;&lt; endl;<br><br>		count = <span class="hljs-built_in">sizeof</span>(array2) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>); <span class="hljs-comment">// 4 / 4 = 1</span><br>		cout &lt;&lt; <span class="hljs-string">&quot;count of array2 is &quot;</span> &lt;&lt; count &lt;&lt; endl;<br><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>		&#123;<br>			array1[i] = i; <br>			array2[i] = i;<br>		&#125;<br>			<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>需要注意的是，当定义一个stack上的数组的时候，数组的大小必须是在编译时就需要注意的常量！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// error!</span><br><span class="hljs-type">int</span> array1Size = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> array1[array1Size];<br><br><span class="hljs-comment">// error!</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> array1Size = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> array1[array1Size];<br><br><span class="hljs-comment">// 使用static方法！</span><br><span class="hljs-comment">// right!</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> array1Size = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> array1[array1Size];<br><br><span class="hljs-comment">// 使用constexpr方法！</span><br><span class="hljs-comment">// 没搞懂？❓🎯</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>std::array</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	array&lt;<span class="hljs-type">int</span>, 5&gt; array1;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; array<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); i++)<br>	&#123;<br>		array1[i] = i;<br>	&#125;<br><br>	cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="32-How-Strings-Work-in-C"><a href="#32-How-Strings-Work-in-C" class="headerlink" title="32. How Strings Work in C++"></a>32. How Strings Work in C++</h1><h2 id="String-Pointer-Array-Memory-address"><a href="#String-Pointer-Array-Memory-address" class="headerlink" title="String, Pointer, Array, Memory address"></a>String, Pointer, Array, Memory address</h2><p>String is a group of characters</p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/ascii-table.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="ascii-table"></p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231215144322539.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="image-20231215144322539"></p>
<p>字符串结束的标志”\0“，在内存中存储的就是0。</p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231215145247579.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="image-20231215145247579"></p>
<p><strong><code>const char* name = &quot;Cherno&quot;;</code></strong></p>
<p>这声明了一个指向常量字符的指针。这意味着指针<code>name</code>指向的字符串内容是不可修改的。你可以通过<code>name</code>指针读取字符串，但是尝试通过<code>name</code>指针修改字符串的内容将导致编译错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = <span class="hljs-string">&quot;Cherno&quot;</span>;<br><span class="hljs-comment">// 可以读取字符串</span><br><span class="hljs-type">char</span> firstChar = name[<span class="hljs-number">0</span>];<br><span class="hljs-comment">// 但不能修改字符串</span><br><span class="hljs-comment">// name[0] = &#x27;X&#x27;; // 这会导致编译错误</span><br></code></pre></td></tr></table></figure>

<p><strong><code>char* name = &quot;Cherno&quot;;</code></strong></p>
<p>这声明了一个指向字符的指针，但没有使用<code>const</code>。这意味着指针<code>name</code>指向的字符串内容是可修改的。然而，这在 C++ 中是不安全的，因为字符串常量（像 “Cherno”）通常存储在只读的内存区域，尝试修改它们可能导致未定义的行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>* name = <span class="hljs-string">&quot;Cherno&quot;</span>;<br><span class="hljs-comment">// 尽管没有编译错误，但修改字符串是不安全的</span><br><span class="hljs-comment">// name[0] = &#x27;X&#x27;; // 可能导致未定义的行为</span><br></code></pre></td></tr></table></figure>

<p>总的来说，如果你知道字符串不会被修改，最好使用第一个声明，即带有<code>const</code>的版本，以提高代码的安全性。如果你确实需要修改字符串，最好将字符串复制到一个可修改的内存区域，例如使用<code>char[]</code>数组：</p>
<p><code>char name[] = &quot;Cherno&quot;;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> name[] = <span class="hljs-string">&quot;Cherno&quot;</span>; <span class="hljs-comment">// 可以修改</span><br>name[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;X&#x27;</span>; <span class="hljs-comment">// 安全</span><br></code></pre></td></tr></table></figure>

<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231215150357514.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="image-20231215150357514"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 用pointer定义一个字符串，使用const意味着这个字符串不能修改</span><br>	<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = <span class="hljs-string">&quot;Cherno&quot;</span>;<br>	<span class="hljs-comment">// char* name = &quot;Cherno&quot;; // 不要用这种写法，</span><br>	std::cout &lt;&lt; name &lt;&lt; std::endl;<br><br>	<span class="hljs-comment">// char* name1 = &quot;Cherno&quot;; // 不要用这种写法，</span><br>	<span class="hljs-comment">// std::cout &lt;&lt; name1 &lt;&lt; std::endl;</span><br><br>	<span class="hljs-comment">// 用array定义一个字符串，可以修改</span><br>	<span class="hljs-comment">// char name2[6] = &#123; &#x27;C&#x27;, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;r&#x27;, &#x27;n&#x27;,&#x27;o&#x27; &#125;; // error!</span><br>	<span class="hljs-type">char</span> name2[<span class="hljs-number">7</span>] = &#123; <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span> &#125;; <span class="hljs-comment">// &#x27;\0&#x27;: null termination character</span><br><br>	name2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;A&#x27;</span>;<br>	std::cout &lt;&lt; name2 &lt;&lt; std::endl;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="Standard-string-std-string"><a href="#Standard-string-std-string" class="headerlink" title="Standard string (std::string)"></a>Standard string (std::string)</h2><ol>
<li>字符串定义与字符串函数。使用string定义的字符串变量其本质还是const char* name.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::string name = <span class="hljs-string">&quot;Cherno&quot;</span>;<br>cout &lt;&lt; name &lt;&lt; endl;<br><br>std::cout &lt;&lt; name.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 6</span><br>std::cout &lt;&lt; name.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;no&quot;</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 4, 第一次出现“no”时候的索引</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>字符串拼接</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// string name = &quot;Cherno&quot; + &quot; hello&quot;; // wrong!</span><br><br><span class="hljs-comment">// method 1</span><br>std::string name1 = <span class="hljs-string">&quot;Cherno1&quot;</span>;<br>name1 += <span class="hljs-string">&quot; hello&quot;</span>;<br>std::cout &lt;&lt; name1 &lt;&lt; std::endl;<br><br><span class="hljs-comment">// method 2</span><br>std::string name2 = std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Cherno2&quot;</span>) + <span class="hljs-string">&quot; hello&quot;</span>;<br>std::cout &lt;&lt; name2 &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>字符串作为函数参数传递</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintString</span><span class="hljs-params">(std::string onename)</span></span><br><span class="hljs-function"></span>&#123;<br>	onename += <span class="hljs-string">&quot; hello&quot;</span>;<br>	std::cout &lt;&lt; onename &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::string name = <span class="hljs-string">&quot;Cherno&quot;</span>;<br>	<span class="hljs-built_in">PrintString</span>(name);  <span class="hljs-comment">// Cherno hello</span><br>	std::cout &lt;&lt; name &lt;&lt; std::endl; <span class="hljs-comment">// Cherno</span><br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>std::string onename</code>是对<code>std::string name = &quot;Cherno&quot;</code>的复制，在<code>PrintString</code>函数中对onename做出的修改，实际上并不会影响原来name的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintString</span><span class="hljs-params">(std::string&amp; onename)</span> <span class="hljs-comment">// 传引用的话情况就会不一样了</span></span><br><span class="hljs-function"></span>&#123;<br>	onename += <span class="hljs-string">&quot; hello&quot;</span>;<br>	std::cout &lt;&lt; onename &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::string name = <span class="hljs-string">&quot;Cherno&quot;</span>;<br>	<span class="hljs-built_in">PrintString</span>(name);  <span class="hljs-comment">// Cherno hello</span><br>	std::cout &lt;&lt; name &lt;&lt; std::endl; <span class="hljs-comment">// Cherno hello</span><br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; onename)</span> <span class="hljs-comment">// 如果有const的话，又是另外一种情况，这时候，onename即name的值不能改变</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// onename += &quot; hello&quot;;</span><br>	std::cout &lt;&lt; onename &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::string name = <span class="hljs-string">&quot;Cherno&quot;</span>;<br>	<span class="hljs-built_in">PrintString</span>(name);  <span class="hljs-comment">// Cherno</span><br>	std::cout &lt;&lt; name &lt;&lt; std::endl; <span class="hljs-comment">// Cherno</span><br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="33-String-Literals-in-C"><a href="#33-String-Literals-in-C" class="headerlink" title="33. String Literals in C++"></a>33. String Literals in C++</h1><h2 id="1-字符串字面量"><a href="#1-字符串字面量" class="headerlink" title="1. 字符串字面量"></a>1. 字符串字面量</h2><blockquote>
<p>生成自ChatGPT</p>
</blockquote>
<p>字符串字面量（String literals）是在源代码中直接表示字符串值的一种方式。在C++中，字符串字面量通常是由双引号括起来的字符序列。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>上述代码中，<code>&quot;Hello, World!&quot;</code> 就是一个字符串字面量。这个字符串字面量的类型是一个 <code>const char</code> 数组（C++中字符串字面量的类型是一个字符数组），并且它以 null 字符 <code>&#39;\0&#39;</code> 结尾。</p>
<p>字符串字面量可以用于初始化字符数组、字符串指针、以及各种支持字符串操作的标准库类（比如 <code>std::string</code>）。</p>
<p>在C++中，有一些特殊的字符串字面量前缀，用于指定不同的字符集和字符宽度，如前面提到的：</p>
<ul>
<li><code>L</code> 前缀表示宽字符（<code>wchar_t</code>）。</li>
<li><code>u</code> 前缀表示UTF-16字符串（<code>char16_t</code>）。</li>
<li><code>U</code> 前缀表示UTF-32字符串（<code>char32_t</code>）。</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* wideStr = <span class="hljs-string">L&quot;Wide String&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char16_t</span>* utf16Str = <span class="hljs-string">u&quot;UTF-16 String&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char32_t</span>* utf32Str = <span class="hljs-string">U&quot;UTF-32 String&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>字符串字面量是C++中处理字符串的基本元素之一，而且它们的使用非常普遍。在实际编程中，字符串字面量经常用于初始化字符串，作为函数参数传递，或者用于各种字符串操作。</p>
<h2 id="2-字符串长度与数组大小"><a href="#2-字符串长度与数组大小" class="headerlink" title="2. 字符串长度与数组大小"></a>2. 字符串长度与数组大小</h2><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231215172042237.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="image-20231215172042237"></p>
<p>There is a question! 字符串有6个字符，为什么定义中的长度是7呢？</p>
<p>因为要考虑到‘null termination character ’也要占用一个字符长度。</p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231215172636875.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="image-20231215172636875"></p>
<h2 id="3-const-char-name"><a href="#3-const-char-name" class="headerlink" title="3. const char* name"></a>3. const char* name</h2><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231217145412538.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="Cherno在视频中的这两行代码是可以编译的，但是我这个VS的版本编译不了。"></p>
<p>Cherno在视频中提到了，这两行代码能不能编译取决于所使用的编译器。Cherno用的是VS2017可以编译，但在VS2019不能编译，VS2022中也不能编译，要求必须有<code>const</code>关键字。</p>
<h2 id="4-diffierent-‘char’"><a href="#4-diffierent-‘char’" class="headerlink" title="4. diffierent ‘char’"></a>4. diffierent ‘char’</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">	<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = <span class="hljs-string">&quot;Cherno&quot;</span>;<br>	<span class="hljs-comment">// const char* name = u8&quot;Cherno&quot;; // 与上面的写法一样，只是上面省略了‘u8’</span><br>	<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* name2 = <span class="hljs-string">L&quot;Cherno&quot;</span>; <span class="hljs-comment">// wchar_t: Wide char -&gt; 2 bytes</span><br><br><span class="hljs-comment">// C++ 11引入</span><br>	<span class="hljs-type">const</span> <span class="hljs-type">char16_t</span>* name3 = <span class="hljs-string">u&quot;Cherno&quot;</span>; <span class="hljs-comment">// 16 bits = 2 bytes</span><br>	<span class="hljs-type">const</span> <span class="hljs-type">char32_t</span>* name4 = <span class="hljs-string">U&quot;Cherno&quot;</span>; <span class="hljs-comment">// 32 bits = 4 bytes</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>解释来自ChatGPT</p>
</blockquote>
<p>这是 C++ 中用于定义字符串的一些不同方式，涉及到字符集和字符宽度：</p>
<ol>
<li><p>**<code>const char\* name = &quot;Cherno&quot;;</code>**（UTF-8）</p>
<p>这是一个普通的 C 字符串（null-terminated string），使用 <code>const char*</code> 类型的指针来指向以 null 结尾的字符序列。这是常见的字符串表示方式，其中字符的宽度是 1 字节。</p>
</li>
<li><p><strong><code>const wchar_t\* name2 = L&quot;Cherno&quot;;</code></strong></p>
<p>这是使用宽字符集的字符串，<code>L</code> 前缀表示宽字符（wide character）。<code>wchar_t</code> 类型的指针指向以 null 结尾的宽字符序列。宽字符通常是 2 字节，用于支持更广泛的字符集，特别是国际化和多语言环境。</p>
</li>
<li><p>**<code>const char16_t\* name3 = u&quot;Cherno&quot;;</code>**（UTF-16）</p>
<p>这是使用 UTF-16 编码的 Unicode 字符串，<code>u</code> 前缀表示 UTF-16 字符。<code>char16_t</code> 类型的指针指向以 null 结尾的 UTF-16 字符序列。每个字符通常占据 2 字节。</p>
</li>
<li><p>**<code>const char32_t\* name4 = U&quot;Cherno&quot;;</code>**（UTF-32）</p>
<p>这是使用 UTF-32 编码的 Unicode 字符串，<code>U</code> 前缀表示 UTF-32 字符。<code>char32_t</code> 类型的指针指向以 null 结尾的 UTF-32 字符序列。每个字符通常占据 4 字节。</p>
</li>
</ol>
<p>这些不同的字符串表示方式主要用于处理不同的字符集和字符宽度需求。在选择使用哪种类型的字符串时，需要考虑你的应用程序的特定要求，特别是对字符集的支持和国际化的需求。 C++11 引入了这些新的字符串类型和前缀，以更好地支持 Unicode 字符和不同的字符宽度。</p>
<blockquote>
<p>虽然我们一直说 wchar 每个字符都是 2 字节，但实际上是由编译器决定的。（Windows：2 bytes，Linux：4 bytes）。 如果你希望它一直是 2 bytes，你可以用<code>char16_t</code></p>
</blockquote>
<h2 id="5-在字符串上附加一些东西"><a href="#5-在字符串上附加一些东西" class="headerlink" title="5. 在字符串上附加一些东西"></a>5. 在字符串上附加一些东西</h2><ol>
<li>string_literals</li>
</ol>
<p>in <code>C++ 17</code></p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231217155835415.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="string_literals"></p>
<ol start="2">
<li>R method</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// method 1</span><br>	std::string name1 = std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Line1\n&quot;</span>) + <span class="hljs-string">&quot;Line2\n&quot;</span> + <span class="hljs-string">&quot;Line3\n&quot;</span>;<br>	std::cout &lt;&lt; name1 &lt;&lt; std::endl &lt;&lt; std::endl;<br><br>	<span class="hljs-comment">// method 2</span><br>	<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::string_literals;<br>	std::string name2 = <span class="hljs-string">&quot;Line1\n&quot;</span>s + <span class="hljs-string">&quot;Line2\n&quot;</span> + <span class="hljs-string">&quot;Line3\n&quot;</span>;<br>	std::cout &lt;&lt; name2 &lt;&lt; std::endl &lt;&lt; std::endl;<br><br>	<span class="hljs-comment">// method 3</span><br>	<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name3 = <span class="hljs-string">R&quot;(Line1</span><br><span class="hljs-string">Line2</span><br><span class="hljs-string">Line3)&quot;</span>;<br><br>	std::cout &lt;&lt; name3 &lt;&lt; std::endl &lt;&lt; std::endl;<br><br>	<span class="hljs-comment">// method 4</span><br>	<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name4 = <span class="hljs-string">&quot;Line1\n&quot;</span><br>		<span class="hljs-string">&quot;Line2\n&quot;</span><br>		<span class="hljs-string">&quot;Line3\n&quot;</span>;<br><br>	std::cout &lt;&lt; name4 &lt;&lt; std::endl &lt;&lt; std::endl;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="6-the-memory-of-the-string-literals-and-how-it-works"><a href="#6-the-memory-of-the-string-literals-and-how-it-works" class="headerlink" title="6. the memory of the string literals and how it works"></a>6. the memory of the string literals and how it works</h2><p>字符串字面量总是存储在只读内存（read-only memory）中</p>
<h1 id="34-CONST-in-C-⭐"><a href="#34-CONST-in-C-⭐" class="headerlink" title="34. CONST in C++⭐"></a>34. CONST in C++⭐</h1><blockquote>
<p>我比较喜欢把<code>const</code>叫做一个”fake keyword”，因为它实际上在生成代码的时候并没有做什么。 它有点像类和结构体的可见性，是一种针对开发人员写代码的强制规则，为了让代码保持整洁的机制。</p>
<p> 基本上 const 就是你做出承诺，某些东西是不变的，是不会改动的。但是它只是个承诺，而且你可以绕过或不遵守这个承诺，就像在现实生活中一样。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_NUMBER = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure>

<h2 id="1-const-与-pointer"><a href="#1-const-与-pointer" class="headerlink" title="1. const 与 pointer"></a>1. const 与 pointer</h2><p>当使用const处理指针的时候，可以是指针本身，也可以是指针指向的内容，取决于const放在声明处的某处，const是在“星号”的左边还是在“星号”的右边。</p>
<ul>
<li>const correctness</li>
</ul>
<p><code>const</code>类型限定符（type qualifier）是C++语言设计的一大亮点。我们围绕着这个语言特性使用“<code>const</code>正确性” （const correctness）的实践来防止<code>const</code>对象遭到改变。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_NUM = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>*a = <span class="hljs-number">2</span>;<br>a = &amp;MAX_NUM; <span class="hljs-comment">// 这个写法有问题！</span><br></code></pre></td></tr></table></figure>

<p>问题在于，<code>a</code> 是一个指向动态分配内存的指针，而 <code>&amp;MAX_NUM</code> 是一个指向常量的指针。你不能将一个指向常量的指针赋值给一个非常量指针，因为这违反了 const-correctness 规则。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_NUM = <span class="hljs-number">100</span>;<br>	<span class="hljs-type">int</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>	*a = <span class="hljs-number">2</span>;<br>	a = (<span class="hljs-type">int</span>*)&amp;MAX_NUM;<br><br>	std::cout &lt;&lt; *a &lt;&lt; std::endl;<br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><span class="hljs-comment">// 100</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_NUM = <span class="hljs-number">100</span>;<br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;  <br>    <span class="hljs-comment">// int const* a = new int; // 两种写法相同</span><br>	*a = <span class="hljs-number">2</span>; <span class="hljs-comment">// error! const使你不能修改a指针指向的内容</span><br>	a = (<span class="hljs-type">int</span>*)&amp;MAX_NUM;<br><br>	std::cout &lt;&lt; *a &lt;&lt; std::endl;<br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_NUM = <span class="hljs-number">100</span>;<br>	<span class="hljs-type">int</span>* <span class="hljs-type">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>	*a = <span class="hljs-number">2</span>; <br>	a = (<span class="hljs-type">int</span>*)&amp;MAX_NUM; <span class="hljs-comment">// error！可以改变指针指向的内容，但是不能把指针自身重新赋值，让它指向其它东西</span><br><br>	std::cout &lt;&lt; *a &lt;&lt; std::endl;<br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_NUM = <span class="hljs-number">100</span>;<br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><br>   	<span class="hljs-comment">// 既不能改变指针的内容，也不能改变指针本身让它指向别处</span><br>	*a = <span class="hljs-number">2</span>;  <span class="hljs-comment">//error!</span><br>	a = (<span class="hljs-type">int</span>*)&amp;MAX_NUM; <span class="hljs-comment">//error!</span><br><br>	std::cout &lt;&lt; *a &lt;&lt; std::endl;<br>	std::cout &lt;&lt; a &lt;&lt; std::endl;<br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-类与方法中使用const"><a href="#2-类与方法中使用const" class="headerlink" title="2. 类与方法中使用const"></a>2. 类与方法中使用const</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> m_X, m_Y;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetX</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>  <span class="hljs-comment">// （这种方法只在类中有效）</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-comment">// m_X = 1; // error! 因为方法后面加了const关键字，所有该方法不能修改类成员变量 </span><br>		<span class="hljs-keyword">return</span> m_X;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetX</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">	</span>&#123;<br>		m_X = x;<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span>* m_X, m_Y;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> <span class="hljs-title">GetX</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>  <span class="hljs-comment">// 指针m_X指向的内容不能变，指针的内容也不能变</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> m_X;<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><em><strong>ChatGPT</strong></em></p>
<p>这段代码定义了一个名为 <code>Entity</code> 的类，其中包含了一个私有的指针成员 <code>m_X</code> 和一个私有的整数成员 <code>m_Y</code>。以下是对这段代码的详细解释：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">cppCopy codeclass Entity<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* m_X, m_Y;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> <span class="hljs-title">GetX</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> m_X;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>私有成员变量：</strong></p>
<ul>
<li><code>int* m_X</code>: 是一个指向整数的指针。这是一个指针，可以指向一个整数值。但请注意，只有指针本身是私有的，而不是指针指向的内容。</li>
<li><code>int m_Y</code>: 是一个整数。这个成员变量是一个普通的整数。</li>
</ul>
</li>
<li><p><strong>公有成员函数 <code>GetX</code>：</strong></p>
<ul>
<li><p><code>const int* const GetX() const</code>: 是一个公有成员函数，返回一个指向整数的常量指针。</p>
</li>
<li><p><code>const</code>关键字在不同位置的含义：</p>
</li>
</ul>
</li>
<li><p><code>const int*</code>: 表示返回的指针指向的内容是常量，<strong>即不能通过这个指针修改对象的值</strong>。</p>
<ul>
<li><code>const int* const</code>: 表示返回的指针本身也是常量，<strong>即不能通过这个指针修改指针的值</strong>，即不能使它指向其他内存地址。</li>
</ul>
</li>
<li><p><code>const</code> 关键字在函数的末尾表示这是一个常量成员函数，即在<strong>函数内不能修改对象的成员变量</strong>。</p>
</li>
<li><p><strong>GetX 函数的作用：</strong></p>
<ul>
<li><code>GetX</code> 函数返回一个指向整数的常量指针，指向对象内部的 <code>m_X</code> 成员。</li>
</ul>
</li>
<li><p>由于返回的指针是常量指针，外部代码不能通过这个指针修改 <code>m_X</code> 指向的内容。</p>
</li>
<li><p>同时，由于返回的指针本身也是常量指针，外部代码不能通过这个指针修改它指向的内存地址，即不能改变 <code>m_X</code> 的指向。</p>
</li>
</ul>
<p>这种设计可以提供一定程度的数据封装和安全性，限制了外部对 <code>m_X</code> 的直接修改。</p>
</blockquote>
<p><em>需要注意一个很有趣的地方！</em></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> int* m<span class="hljs-emphasis">_X, m_</span>Y;<br><span class="hljs-bullet">	-</span> 这样写的代表着m<span class="hljs-emphasis">_X是int型指针变量，而m_</span>Y仍然是int型变量<br><span class="hljs-bullet">-</span> int* m<span class="hljs-emphasis">_X, *m_</span>Y<br><span class="hljs-bullet">	-</span> 而这样写才能使得两个变量都是int型指针变量<br></code></pre></td></tr></table></figure>



<h1 id="35-The-Mutable-Keyword-in-C"><a href="#35-The-Mutable-Keyword-in-C" class="headerlink" title="35. The Mutable Keyword in C++"></a>35. The Mutable Keyword in C++</h1><p><code>mutable</code> means something can be changed.</p>
<h2 id="1-mutable-and-const"><a href="#1-mutable-and-const" class="headerlink" title="1. mutable and const"></a>1. mutable and const</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>	std::string m_Name;<br>	<span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_DebugCount = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		m_DebugCount++;<br>		<span class="hljs-keyword">return</span> m_Name;<br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">const</span> Entity e;<br>	e.<span class="hljs-built_in">GetName</span>();<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-mutable-and-lambda"><a href="#2-mutable-and-lambda" class="headerlink" title="2. mutable and lambda"></a>2. mutable and lambda</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">auto</span> f = [=]() <span class="hljs-keyword">mutable</span><br>&#123;<br>    x++;<br>    std::cout &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-built_in">f</span>();<br></code></pre></td></tr></table></figure>



<h1 id="36-Member-Initializer-Lists-in-C-Constructor-Initializer-List-⭐"><a href="#36-Member-Initializer-Lists-in-C-Constructor-Initializer-List-⭐" class="headerlink" title="36. Member Initializer Lists in C++ (Constructor Initializer List)⭐"></a>36. Member Initializer Lists in C++ (Constructor Initializer List)⭐</h1><blockquote>
<p>成员初始化列表，在构造函数中初始化类成员（变量）的一种方式</p>
</blockquote>
<h2 id="1-构造函数-初始化成员（变量）"><a href="#1-构造函数-初始化成员（变量）" class="headerlink" title="1. 构造函数-&gt;初始化成员（变量）"></a>1. 构造函数-&gt;初始化成员（变量）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>	std::string m_Name;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Entity</span>()<br>	&#123;<br>		m_Name = <span class="hljs-string">&quot;Unknow&quot;</span>;<br>	&#125;<br>	<span class="hljs-built_in">Entity</span>(<span class="hljs-type">const</span> std::string&amp; name)<br>	&#123;<br>		m_Name = name;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> m_Name;<br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">const</span> Entity e0;<br>	std::cout &lt;&lt; e<span class="hljs-number">0.</span><span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br><br>	<span class="hljs-function"><span class="hljs-type">const</span> Entity <span class="hljs-title">e1</span><span class="hljs-params">(<span class="hljs-string">&quot;Cherno&quot;</span>)</span></span>;<br>	std::cout &lt;&lt; e<span class="hljs-number">1.</span><span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-成员初始化列表"><a href="#2-成员初始化列表" class="headerlink" title="2. 成员初始化列表"></a>2. 成员初始化列表</h2><blockquote>
<p>确保成员初始化列表时，要与成员变量声明时的的<strong>顺序一致</strong>！！</p>
<p>为什么需要成员初始化列表？</p>
<ul>
<li>因为构造函数的功能往往不仅仅是初始化成员变量，为了使得构造函数看起来简洁易读一些，我们可以把杂乱的初始化成员变量的这一部分以成员初始化列表的形式单独写做一行，这样就简化了构造函数。-&gt; 1. 简化构造函数</li>
</ul>
</blockquote>
<ol>
<li>简化构造函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>	std::string m_Name;<br>	<span class="hljs-type">int</span> m_Score;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Entity</span>()<br>		: <span class="hljs-built_in">m_Name</span>(<span class="hljs-string">&quot;Unknown&quot;</span>), <span class="hljs-built_in">m_Score</span>(<span class="hljs-number">0</span>)<br>	&#123;<br>	&#125;<br><br>	<span class="hljs-built_in">Entity</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> <span class="hljs-type">int</span> score)<br>		: <span class="hljs-built_in">m_Name</span>(name), <span class="hljs-built_in">m_Score</span>(score)<br>	&#123;<br>		m_Name = name;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> m_Name;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-title">GetScore</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> m_Score;<br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">const</span> Entity e0;<br>	std::cout &lt;&lt; e<span class="hljs-number">0.</span><span class="hljs-built_in">GetName</span>() &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; e<span class="hljs-number">0.</span><span class="hljs-built_in">GetScore</span>() &lt;&lt; std::endl;<br><br>	<span class="hljs-function"><span class="hljs-type">const</span> Entity <span class="hljs-title">e1</span><span class="hljs-params">(<span class="hljs-string">&quot;Cherno&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br>	std::cout &lt;&lt; e<span class="hljs-number">1.</span><span class="hljs-built_in">GetName</span>() &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; e<span class="hljs-number">1.</span><span class="hljs-built_in">GetScore</span>() &lt;&lt; std::endl;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>避免构造两次</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Example</span>()<br>	&#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;Created Example!&quot;</span> &lt;&lt; std::endl;<br>	&#125;<br>	<br>	<span class="hljs-built_in">Example</span>(<span class="hljs-type">int</span> x)<br>	&#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;Created Example with &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;!&quot;</span> &lt;&lt; std::endl;<br>	&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>	std::string m_Name;<br>	Example m_Example;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Entity</span>()<br>	&#123;<br>		m_Name = std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Unknown&quot;</span>);<br>		m_Example = <span class="hljs-built_in">Example</span>(<span class="hljs-number">100</span>);<br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">const</span> Entity e0;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><span class="hljs-comment">// 输出结果是以下两行</span><br><span class="hljs-comment">// Created Example!</span><br><span class="hljs-comment">// Created Example with 100!</span><br><span class="hljs-comment">// 为什么会分别调用了默认构造函数和有参数的构造函数呢？ 明明在Entity类的构造函数中只使用了m_Example = Example(100);</span><br><span class="hljs-comment">// 这是因为Example m_Example;调用了一次Example的默认构造函数</span><br><span class="hljs-comment">// 因此这就相当于把Example实例化了一次然后又实例化了一次，这就造成了性能的浪费。</span><br><span class="hljs-comment">// 为了解决这个问题，可以使用成员列表的方式来解决。</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Example</span>()<br>	&#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;Created Example!&quot;</span> &lt;&lt; std::endl;<br>	&#125;<br>	<br>	<span class="hljs-built_in">Example</span>(<span class="hljs-type">int</span> x)<br>	&#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;Created Example with &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;!&quot;</span> &lt;&lt; std::endl;<br>	&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>	std::string m_Name;<br>	Example m_Example;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Entity</span>()<br>		: <span class="hljs-built_in">m_Name</span>(<span class="hljs-string">&quot;Unkonwn&quot;</span>), <span class="hljs-built_in">m_Example</span>(<span class="hljs-built_in">Example</span>(<span class="hljs-number">100</span>)) <span class="hljs-comment">// m_Example(100)，写成这样的效果也是一样的。</span><br>	&#123;<br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">const</span> Entity e0;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-comment">// Created Example with 100!</span><br></code></pre></td></tr></table></figure>



<h1 id="37-Ternary-Operator-in-C-Conditional-Assignment"><a href="#37-Ternary-Operator-in-C-Conditional-Assignment" class="headerlink" title="37. Ternary Operator in C++(Conditional Assignment)"></a>37. Ternary Operator in C++(Conditional Assignment)</h1><blockquote>
<p>Ternary Operator: 三元运算符-&gt; 问号和冒号（本质上就是if语句的语法糖）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> s_Level = <span class="hljs-number">1</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> s_Speed = <span class="hljs-number">2</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// method 1</span><br>	<span class="hljs-keyword">if</span> (s_Level &gt; <span class="hljs-number">5</span>)<br>		s_Speed = <span class="hljs-number">10</span>;<br>	<span class="hljs-keyword">else</span><br>		s_Speed = <span class="hljs-number">5</span>;<br><br>	<span class="hljs-comment">// method 2</span><br>	s_Speed = s_Level &gt; <span class="hljs-number">5</span> ? <span class="hljs-number">10</span> : <span class="hljs-number">5</span>;<br>	std::string rank = s_Level &gt; <span class="hljs-number">10</span> ? <span class="hljs-string">&quot;Master&quot;</span> : <span class="hljs-string">&quot;Beginner&quot;</span>;<br><br>	s_Speed = s_Level &gt; <span class="hljs-number">5</span> ? s_Level &gt; <span class="hljs-number">10</span> ? <span class="hljs-number">15</span> : <span class="hljs-number">10</span> : <span class="hljs-number">5</span>;<br>	<span class="hljs-comment">// 尽量不要做三运运算符的嵌套，易读性可能会大大降低</span><br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="38-How-to-create-instantiate-object-C-⭐"><a href="#38-How-to-create-instantiate-object-C-⭐" class="headerlink" title="38. How to create&#x2F;instantiate object C++⭐"></a>38. How to create&#x2F;instantiate object C++⭐</h1><blockquote>
<p>C++创建对象</p>
<p>实例化定义的类</p>
</blockquote>
<h2 id="1-在栈上创建对象（stack）"><a href="#1-在栈上创建对象（stack）" class="headerlink" title="1. 在栈上创建对象（stack）"></a>1. 在栈上创建对象（stack）</h2><ul>
<li>最平常是创建对象的方法</li>
</ul>
<p>几乎所有时候。如果你可以这样创建对象的话，那就这么来创建，这是基本规则。 因为在 C++中这是初始化对象最快的方式和最受管控的方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>	std::string m_Name;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Entity</span>() : <span class="hljs-built_in">m_Name</span>(<span class="hljs-string">&quot;Unkown&quot;</span>) &#123;&#125;<br>	<span class="hljs-built_in">Entity</span>(<span class="hljs-type">const</span> std::string name) : <span class="hljs-built_in">m_Name</span>(name) &#123;&#125;<br><br>	<span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_Name; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Entity entity;<br>	std::cout &lt;&lt; entity.<span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br><br>	<span class="hljs-function">Entity <span class="hljs-title">entity1</span><span class="hljs-params">(<span class="hljs-string">&quot;Cherno&quot;</span>)</span></span>;<br>	<span class="hljs-comment">// Entity entity1 = Entity(&quot;Cherno&quot;); // 类型 实例名 = 构造函数(参数)</span><br>	std::cout &lt;&lt; entity<span class="hljs-number">1.</span><span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>需要使得创建的对象在函数生存期之外依然存在</li>
</ul>
<ol>
<li>定义在函数内的对象在函数结束之后，所占用的内存便会被释放</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>	std::string m_Name;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Entity</span>() : <span class="hljs-built_in">m_Name</span>(<span class="hljs-string">&quot;Unkown&quot;</span>) &#123;&#125;<br>	<span class="hljs-built_in">Entity</span>(<span class="hljs-type">const</span> std::string name) : <span class="hljs-built_in">m_Name</span>(name) &#123;&#125;<br><br>	<span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_Name; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Function</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-function">Entity <span class="hljs-title">entity</span><span class="hljs-params">(<span class="hljs-string">&quot;Cherno&quot;</span>)</span></span>;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>	<span class="hljs-comment">// a和entity的生命周期仅存在函数function之内，函数结束了之后，变量所占用的内存也就被释放了。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">Function</span>();<br>	<span class="hljs-comment">// 但我们调用function的时，就为这个函数创建了一个栈结构</span><br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>2. </p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231227150550541.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="image-20231227150550541"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">console输入的内容如下：<br>1. Cherno<br>2.<br><br>解释一下为什么是这样的输出。<br></code></pre></td></tr></table></figure>

<p>叫做Cherno的entity实例的生命周期仅在大括号之内，跳出大括号后，这个叫 Cherno 的 entity 对象已经不存在了，它已经不存在栈结构里了，所以就没有输出了。</p>
<p>另一个我们不想在栈上分配的原因可能是：如果这个 entity 太大了，同时我们可能有很多的 entity，我们就可能没有足够的空间来进行分配，因为栈通常都很小，一般是一两兆，这取决于你的平台和编译器。 因此你可能不得不在<em>heap</em>上进行分配。</p>
<blockquote>
<p>突然想到的一个内容，和本节内容相关</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Entity* e;<br><br>	&#123;<br>		<span class="hljs-function">Entity <span class="hljs-title">entity</span><span class="hljs-params">(<span class="hljs-string">&quot;Cherno&quot;</span>)</span></span>;<br>		e = &amp;entity;<br>		std::cout &lt;&lt; entity.<span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br>		std::cout &lt;&lt; e-&gt;<span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br>		std::cout &lt;&lt; (*e).<span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br>	&#125;<br>    std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Cherno</span><br><span class="hljs-comment">Cherno</span><br><span class="hljs-comment">Cherno</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<ol>
<li><strong><code>std::cout &lt;&lt; entity.GetName() &lt;&lt; std::endl;</code></strong><ul>
<li>直接通过对象 <code>entity</code> 调用 <code>GetName</code> 函数，输出实体的名称。</li>
<li>这种方式是直接访问对象的成员函数，因为 <code>entity</code> 是 <code>Entity</code> 类的一个实例。</li>
</ul>
</li>
<li><strong><code>std::cout &lt;&lt; e-&gt;GetName() &lt;&lt; std::endl;</code></strong><ul>
<li>通过指针 <code>e</code> 调用 <code>GetName</code> 函数，输出实体的名称。</li>
<li>这种方式使用了指针，<code>e</code> 是一个指向 <code>Entity</code> 对象的指针，通过箭头运算符 <code>-&gt;</code> 访问对象的成员函数。</li>
</ul>
</li>
<li><strong><code>std::cout &lt;&lt; (\*e).GetName() &lt;&lt; std::endl;</code></strong><ul>
<li>同样是通过指针 <code>e</code> 调用 <code>GetName</code> 函数，输出实体的名称。</li>
<li>这种方式使用了解引用操作符 <code>*</code>，先解引用指针，然后再访问对象的成员函数。</li>
</ul>
</li>
</ol>
<p>在这个特定的示例中，这三种方式都会输出相同的结果，即实体的名称。选择使用哪种方式通常取决于代码的上下文和个人偏好。在一般情况下，直接通过对象调用成员函数是最直观和常见的方式。使用指针或引用通常用于处理动态分配的对象或在函数参数中传递对象，但需要小心确保指针有效且指向有效的对象。</p>
</blockquote>
<h2 id="2-在堆上分配-heap"><a href="#2-在堆上分配-heap" class="headerlink" title="2. 在堆上分配(heap)"></a>2. 在堆上分配(heap)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>	std::string m_Name;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Entity</span>() : <span class="hljs-built_in">m_Name</span>(<span class="hljs-string">&quot;Unkown&quot;</span>) &#123;&#125;<br>	<span class="hljs-built_in">Entity</span>(<span class="hljs-type">const</span> std::string name) : <span class="hljs-built_in">m_Name</span>(name) &#123;&#125;<br><br>	<span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_Name; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Entity* e;<br><br>	&#123;<br>		Entity* entity = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Entity</span>(<span class="hljs-string">&quot;Cherno&quot;</span>);<br>		e = entity; <span class="hljs-comment">// 这里只是复制的entity对象的地址</span><br>		std::cout &lt;&lt; <span class="hljs-string">&quot;1. &quot;</span> &lt;&lt; entity-&gt;<span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br>	&#125;<br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;2. &quot;</span> &lt;&lt; e-&gt;<span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>	<span class="hljs-keyword">delete</span> e;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">程序输出内容如下：</span><br><span class="hljs-comment">1. Cherno</span><br><span class="hljs-comment">2. Cherno</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>Attention: 在使用了new关键字之后，不用的内存要注意使用delete关键字释放掉，防止内存泄漏。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>两种创建对象的方法如何选择？</p>
<ul>
<li>如果要创建的对象很大-&gt; heap</li>
<li>显式地控制对象的生存期 -&gt; heap</li>
<li>其他 -&gt; stack</li>
</ul>
<h1 id="39-The-New-keyword-in-C"><a href="#39-The-New-keyword-in-C" class="headerlink" title="39. The New keyword in C++"></a>39. The New keyword in C++</h1> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-comment">// 为变量a在内存中分配4 bytes大小的连续内存</span><br></code></pre></td></tr></table></figure>

<ul>
<li>关于连续内存的问题，计算机并不是搜索出来的这个4 bytes的连续内存，而是存在一种叫做空闲列表(free list)的东西，它会维护那些有空闲字节的地址。</li>
<li>new的作用就是要找到一个足够大的内存块，以满足我们的需求。</li>
<li><code>Entity* e = new Entity();</code>  在这里它不仅分配了空间，还调用了构造函数。</li>
<li>通常，调用<em>new</em>关键字会调用底层的C函数<em>malloc</em>，它是用来分配内存的。 <code>malloc()</code>的实际作用是，传入一个<code>size</code>，也就是我们需要多少个字节，然后返回一个<code>void指针</code></li>
<li><code>new</code>本身实际上是一个operator(操作符)，操作符意味着可以<strong>操作符重载</strong></li>
<li>用完<code>new</code>之后记得使用<code>delete</code></li>
<li>C++中的new和delete对应到C中就是malloc和free</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-keyword">delete</span> a;<br><br><span class="hljs-type">int</span>* b = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">50</span>];<br><span class="hljs-keyword">delete</span>[] b;<br><br>Entity* e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Entity</span>();<br><span class="hljs-keyword">delete</span> e;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>placement new</p>
<ul>
<li><pre><code class="C++">int* b = new int[50];
Entity* e = new(b) Entity();
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><br>  - 这决定了它的内存来自哪里，细节以后再讲，这里只是展示它的语法。<br><br>  - 这里将 `Entity` 对象构造在已分配的内存地址 `b` 上，而不是使用默认的内存分配器。这样可以在指定的内存位置创建对象。这行代码在 `b` 指针指向的内存位置上构造了一个 `Entity` 对象，并返回指向该对象的指针，并将其赋给了 `e` 指针。<br><br># <span class="hljs-number">40.</span> <span class="hljs-keyword">Implicit</span> Conversion and the Explicit keyword <span class="hljs-keyword">in</span> C++<br><br>&gt; - 隐式转换与explicit关键字<br>&gt;<br>&gt; <span class="hljs-keyword">implicit</span>：隐式的<br>&gt; explicit：显式的<br>&gt;<br>&gt; - *<span class="hljs-keyword">implicit</span>*(隐式)的意思是不会明确地告诉你它要做什么，它有点像在某种情况下自动的工作。实际上 C++允许编译器对代码进行一次隐式的转换。<br>&gt;<br>&gt; - 如果我开始使用一种数据类型作为另一种类型来使用，在这两种类型之间就会有类型转换，C++允许隐式地转换，不需要用*cast*等做强制转换。<br><br>## <span class="hljs-number">1.</span> <span class="hljs-keyword">Implicit</span> Conversion<br><br>```C++<br>#<span class="hljs-keyword">include</span> &lt;iostream&gt;<br>#<span class="hljs-keyword">include</span> &lt;string&gt;<br><br><span class="hljs-keyword">class</span> Entity<br>&#123;<br><span class="hljs-keyword">private</span>:<br>	std::string m_Name;<br>	<span class="hljs-built_in">int</span> m_Age;<br><span class="hljs-keyword">public</span>:<br>	Entity(const std::string&amp; <span class="hljs-keyword">name</span>)<br>		: m_Name(<span class="hljs-keyword">name</span>), m_Age(-<span class="hljs-number">1</span>) &#123;&#125;<br>	Entity(<span class="hljs-built_in">int</span> age)<br>		: m_Name(<span class="hljs-string">&quot;Uknown&quot;</span>), m_Age(age) &#123;&#125;<br>&#125;;<br><br><span class="hljs-built_in">int</span> main()<br>&#123;<br>	Entity a(<span class="hljs-string">&quot;Cherno&quot;</span>);<br>	Entity b(<span class="hljs-number">22</span>);<br><br>	Entity c = Entity(<span class="hljs-string">&quot;Cherno&quot;</span>);<br>	Entity d = Entity(<span class="hljs-number">22</span>);<br><br>	Entity e = std::string(<span class="hljs-string">&quot;Cherno&quot;</span>); // 隐式类型转换<br>	Entity f = <span class="hljs-number">22</span>; // 隐式类型转换<br><br>	std::cin.get();<br>&#125;<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="2-explicit-keyword"><a href="#2-explicit-keyword" class="headerlink" title="2. explicit keyword"></a>2. explicit keyword</h2><ul>
<li>如果把explicit关键字放在构造函数之前，这就意味着不能使用隐式构造</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>	std::string m_Name;<br>	<span class="hljs-type">int</span> m_Age;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Entity</span>(<span class="hljs-type">const</span> std::string&amp; name)<br>		: <span class="hljs-built_in">m_Name</span>(name), <span class="hljs-built_in">m_Age</span>(<span class="hljs-number">-1</span>) &#123;&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Entity</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span></span><br><span class="hljs-function">		: m_Name(<span class="hljs-string">&quot;Uknown&quot;</span>), m_Age(age) &#123;</span>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-function">Entity <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;Cherno&quot;</span>)</span></span>;<br>	<span class="hljs-function">Entity <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">22</span>)</span></span>;<br><br>	Entity c = <span class="hljs-built_in">Entity</span>(<span class="hljs-string">&quot;Cherno&quot;</span>);<br>	Entity d = <span class="hljs-built_in">Entity</span>(<span class="hljs-number">22</span>);<br><br>	Entity e = std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Cherno&quot;</span>);<br>	Entity f = (Entity)<span class="hljs-number">22</span>;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="41-Operators-and-Operator-overloading-in-C-⭐"><a href="#41-Operators-and-Operator-overloading-in-C-⭐" class="headerlink" title="41. Operators and Operator overloading in C++⭐"></a>41. Operators and Operator overloading in C++⭐</h1><h2 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1. 运算符"></a>1. 运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs .markdown">operator: <br>- &#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;, &#x27;/&#x27;<br>- &#x27;*(dereference)&#x27;, &#x27;-&gt;&#x27;, &#x27;+=&#x27;, &#x27;&amp;&#x27;, &#x27;&lt;&lt;&#x27;, <br>- &#x27;new&#x27;, &#x27;delete&#x27;, <br>- &#x27;,&#x27;, &#x27;()&#x27;, &#x27;[]&#x27;<br></code></pre></td></tr></table></figure>

<h2 id="2-运算符重载-and"><a href="#2-运算符重载-and" class="headerlink" title="2. 运算符重载 + and -"></a>2. 运算符重载 + and -</h2><ul>
<li><p><em>overload</em>重载这个术语本质就是给运算符重载赋予新的含义，或者添加参数，或者创建 允许在程序中国定义或更改运算符的行为。</p>
</li>
<li><p>不过说到底，运算符就是<em>function</em>，就是函数。 与其写出函数名<code>add</code>，你只用写一个<code>+</code>这样的运算符就行，在很多情况下这真的有助于让你的代码更干净整洁，可读性更好。</p>
</li>
<li><p>运算符重载的使用应该非常少，而且只是在完全有意义的情况下使用。</p>
</li>
</ul>
<ol>
<li>没有运算符重载的时候写的程序如下：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vector2</span><br>&#123;<br>	<span class="hljs-type">float</span> x, y;<br><br>	<span class="hljs-built_in">Vector2</span>(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y)<br>		: <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br><br>	<span class="hljs-function">Vector2 <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Vector2&amp; other)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector2</span>(x + other.x, y + other.y);<br>	&#125;<br><br>	<span class="hljs-function">Vector2 <span class="hljs-title">Multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Vector2&amp; other)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector2</span>(x * other.x, y * other.y);<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-function">Vector2 <span class="hljs-title">position</span><span class="hljs-params">(<span class="hljs-number">4.0f</span>, <span class="hljs-number">4.0f</span>)</span></span>;<br>	<span class="hljs-function">Vector2 <span class="hljs-title">Speed</span><span class="hljs-params">(<span class="hljs-number">0.5f</span>, <span class="hljs-number">1.5f</span>)</span></span>;<br>	<span class="hljs-function">Vector2 <span class="hljs-title">Powerup</span><span class="hljs-params">(<span class="hljs-number">1.1f</span>, <span class="hljs-number">1.1f</span>)</span></span>;<br>	Vector2 result = position.<span class="hljs-built_in">Add</span>(Speed.<span class="hljs-built_in">Multiply</span>(Powerup));<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>有运算符重载的时候代码如下：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vector2</span><br>&#123;<br>	<span class="hljs-type">float</span> x, y;<br><br>	<span class="hljs-built_in">Vector2</span>(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y)<br>		: <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br><br>	<span class="hljs-function">Vector2 <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Vector2&amp; other)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector2</span>(x + other.x, y + other.y);<br>	&#125;<br>	Vector2 <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Vector2&amp; other) <span class="hljs-type">const</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">Add</span>(other);<br>	&#125;<br><br>	<span class="hljs-function">Vector2 <span class="hljs-title">Multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Vector2&amp; other)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector2</span>(x * other.x, y * other.y);<br>	&#125;<br>	Vector2 <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Vector2&amp; other) <span class="hljs-type">const</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">Multiply</span>(other);<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-function">Vector2 <span class="hljs-title">position</span><span class="hljs-params">(<span class="hljs-number">4.0f</span>, <span class="hljs-number">4.0f</span>)</span></span>;<br>	<span class="hljs-function">Vector2 <span class="hljs-title">Speed</span><span class="hljs-params">(<span class="hljs-number">0.5f</span>, <span class="hljs-number">1.5f</span>)</span></span>;<br>	<span class="hljs-function">Vector2 <span class="hljs-title">Powerup</span><span class="hljs-params">(<span class="hljs-number">1.1f</span>, <span class="hljs-number">1.1f</span>)</span></span>;<br><br>	<span class="hljs-comment">// 没有运算符重载</span><br>	Vector2 result1 = position.<span class="hljs-built_in">Add</span>(Speed.<span class="hljs-built_in">Multiply</span>(Powerup));<br>	<span class="hljs-comment">// 有运算符重载</span><br>	Vector2 result2 = position + Speed * Powerup;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-运算符重载"><a href="#3-运算符重载" class="headerlink" title="3. 运算符重载 &lt;&lt;"></a>3. 运算符重载 &lt;&lt;</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vector2</span><br>&#123;<br>	<span class="hljs-type">float</span> x, y;<br><br>	<span class="hljs-built_in">Vector2</span>(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y)<br>		: <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br><br>	<span class="hljs-function">Vector2 <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Vector2&amp; other)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector2</span>(x + other.x, y + other.y);<br>	&#125;<br>	Vector2 <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Vector2&amp; other) <span class="hljs-type">const</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">Add</span>(other);<br>	&#125;<br><br>	<span class="hljs-function">Vector2 <span class="hljs-title">Multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Vector2&amp; other)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector2</span>(x * other.x, y * other.y);<br>	&#125;<br>	Vector2 <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Vector2&amp; other) <span class="hljs-type">const</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">Multiply</span>(other);<br>	&#125;<br>&#125;;<br><br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="hljs-type">const</span> Vector2&amp; other)<br>&#123;<br>	stream &lt;&lt; other.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; other.y;<br>	<span class="hljs-keyword">return</span> stream;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-function">Vector2 <span class="hljs-title">position</span><span class="hljs-params">(<span class="hljs-number">4.0f</span>, <span class="hljs-number">4.0f</span>)</span></span>;<br>	<span class="hljs-function">Vector2 <span class="hljs-title">Speed</span><span class="hljs-params">(<span class="hljs-number">0.5f</span>, <span class="hljs-number">1.5f</span>)</span></span>;<br>	<span class="hljs-function">Vector2 <span class="hljs-title">Powerup</span><span class="hljs-params">(<span class="hljs-number">1.1f</span>, <span class="hljs-number">1.1f</span>)</span></span>;<br><br>	<span class="hljs-comment">// 没有运算符重载</span><br>	Vector2 result1 = position.<span class="hljs-built_in">Add</span>(Speed.<span class="hljs-built_in">Multiply</span>(Powerup));<br>	<span class="hljs-comment">// 有运算符重载</span><br>	Vector2 result2 = position + Speed * Powerup;<br><br>	std::cout &lt;&lt; result2 &lt;&lt; std::endl;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-运算符重载-and"><a href="#4-运算符重载-and" class="headerlink" title="4. 运算符重载 &#x3D;&#x3D; and !&#x3D;"></a>4. 运算符重载 &#x3D;&#x3D; and !&#x3D;</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vector2</span><br>&#123;<br>	<span class="hljs-type">float</span> x, y;<br><br>	<span class="hljs-built_in">Vector2</span>(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y)<br>		: <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br><br>	<span class="hljs-function">Vector2 <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Vector2&amp; other)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector2</span>(x + other.x, y + other.y);<br>	&#125;<br>	Vector2 <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Vector2&amp; other) <span class="hljs-type">const</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">Add</span>(other);<br>	&#125;<br><br>	<span class="hljs-function">Vector2 <span class="hljs-title">Multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Vector2&amp; other)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector2</span>(x * other.x, y * other.y);<br>	&#125;<br>	Vector2 <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Vector2&amp; other) <span class="hljs-type">const</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">Multiply</span>(other);<br>	&#125;<br><br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Vector2&amp; other) <span class="hljs-type">const</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> x == other.x &amp;&amp; y == other.y;<br>	&#125;<br><br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> Vector2&amp; other) <span class="hljs-type">const</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other); <span class="hljs-comment">// this pointer 不太懂，后面会学习</span><br>	&#125;<br>&#125;;<br><br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="hljs-type">const</span> Vector2&amp; other)<br>&#123;<br>	stream &lt;&lt; other.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; other.y;<br>	<span class="hljs-keyword">return</span> stream;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-function">Vector2 <span class="hljs-title">position</span><span class="hljs-params">(<span class="hljs-number">4.0f</span>, <span class="hljs-number">4.0f</span>)</span></span>;<br>	<span class="hljs-function">Vector2 <span class="hljs-title">Speed</span><span class="hljs-params">(<span class="hljs-number">0.5f</span>, <span class="hljs-number">1.5f</span>)</span></span>;<br>	<span class="hljs-function">Vector2 <span class="hljs-title">Powerup</span><span class="hljs-params">(<span class="hljs-number">1.1f</span>, <span class="hljs-number">1.1f</span>)</span></span>;<br><br>	<span class="hljs-comment">// 没有运算符重载</span><br>	Vector2 result1 = position.<span class="hljs-built_in">Add</span>(Speed.<span class="hljs-built_in">Multiply</span>(Powerup));<br>	<span class="hljs-comment">// 有运算符重载</span><br>	Vector2 result2 = position + Speed * Powerup;<br><br>	std::cout &lt;&lt; result1 &lt;&lt; std::endl;<br>	std::cout &lt;&lt; result2 &lt;&lt; std::endl;<br><br>	<span class="hljs-keyword">if</span> (result1 == result2)<br>	&#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;equality&quot;</span> &lt;&lt; std::endl;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (result1 != result2)<br>	&#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;not equality&quot;</span> &lt;&lt; std::endl;<br>	&#125;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="42-The-“this”-keyword-in-C-⭐"><a href="#42-The-“this”-keyword-in-C-⭐" class="headerlink" title="42. The “this” keyword in C++ ⭐"></a>42. The “this” keyword in C++ ⭐</h1><p>C++中有这样一个关键字<em>this</em>，通过它可以访问成员函数。 <code>this</code>是一个指向当前对象实例的指针，该<em>method</em>(方法)属于这个对象实例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintEntity</span><span class="hljs-params">(Entity* e)</span></span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> x, y;<br><br>    <span class="hljs-built_in">Entity</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;x = x;<br>        <span class="hljs-keyword">this</span>-&gt;y = y;<br>        <span class="hljs-built_in">PrintEntity</span>(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetX</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// this-&gt;x = 5;</span><br>        <span class="hljs-type">const</span> Entity* e = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;x;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintEntity</span><span class="hljs-params">(Entity* e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Print</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="43-Obeject-lifetime-in-C-Stack-Scope-lifetimes-⭐"><a href="#43-Obeject-lifetime-in-C-Stack-Scope-lifetimes-⭐" class="headerlink" title="43. Obeject lifetime in C++ (Stack&#x2F;Scope lifetimes)⭐"></a>43. Obeject lifetime in C++ (Stack&#x2F;Scope lifetimes)⭐</h1><blockquote>
<p>scope: 作用域</p>
</blockquote>
<h2 id="1-基于stack和基于heap的变量在对象生存期上的区别"><a href="#1-基于stack和基于heap的变量在对象生存期上的区别" class="headerlink" title="1. 基于stack和基于heap的变量在对象生存期上的区别"></a>1. 基于stack和基于heap的变量在对象生存期上的区别</h2><blockquote>
<ul>
<li>基于stack的变量在一出作用域，该变量所占用的内存空间便被释放了；</li>
<li>基于heap的变量只要不手动释放内存空间，则该内存空间便不会被释放，知道程序的结束。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Entity</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Entity</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Destoryed Entity!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        Entity e; <span class="hljs-comment">// 定义来栈上的对象</span><br>    &#125;<span class="hljs-comment">// e的作用域就在这个大括号之中，执行完大括号之后，就调用了析构函数。</span><br><br>    std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><span class="hljs-comment">// 输入如下：</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Created Entity!</span><br><span class="hljs-comment">Destoryed Entity!</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Entity</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Entity</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Destoryed Entity!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        Entity* e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Entity</span>(); <br>    &#125;<span class="hljs-comment">//定义在heap上的对象，如果不使用delete手动释放内存空间则该内存空间就不会被释放，因此没有调用析构函数。</span><br><br>    std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><span class="hljs-comment">// 输入如下：</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Created Entity!</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>举个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//一段有问题的代码！！！</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">CreatedArray</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> array[<span class="hljs-number">50</span>];<br>    <span class="hljs-keyword">return</span> array; <span class="hljs-comment">//array的生存期仅在这个大括号之内，跳出大括号之后，array所定义的内存空间都被释放掉了，所以返回的地址也没有什么用了。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>* a = <span class="hljs-built_in">CreatedArray</span>();<br><br>    std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>改正方法</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//一段有问题的代码！！！</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">CreatedArray</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>* array = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">50</span>]; <span class="hljs-comment">// 将array定义在heap上</span><br>    <span class="hljs-keyword">return</span> array; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>* a = <span class="hljs-built_in">CreatedArray</span>();<br><br>    std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-scope-pointer"><a href="#2-scope-pointer" class="headerlink" title="2. scope pointer"></a>2. scope pointer</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Entity</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Entity</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Destoryed Entity!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopePtr</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    Entity* m_Ptr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ScopePtr</span>(Entity* ptr)<br>        : <span class="hljs-built_in">m_Ptr</span>(ptr) &#123;&#125;<br><br>    ~<span class="hljs-built_in">ScopePtr</span>()<br>    &#123;<br>        <span class="hljs-keyword">delete</span> m_Ptr;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        ScopePtr e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Entity</span>();<br>    &#125;<br><br>    std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><span class="hljs-comment">// 输入如下：</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Created Entity!</span><br><span class="hljs-comment">Destoryed Entity!</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 对象定义在heap上,但是我们通过ScopePtr来实现了new-delete, 在跳出大括号的时候,自动调用delete了．</span><br></code></pre></td></tr></table></figure>



<h1 id="44-SMART-POINTERS-in-C-std-unique-ptr-std-shared-ptr-std-weak-ptr"><a href="#44-SMART-POINTERS-in-C-std-unique-ptr-std-shared-ptr-std-weak-ptr" class="headerlink" title="44. SMART POINTERS in C++ (std::unique_ptr, std::shared_ptr, std::weak_ptr)"></a>44. SMART POINTERS in C++ (std::unique_ptr, std::shared_ptr, std::weak_ptr)</h1><blockquote>
<p>smart pointers使得new-delete的过程自动化</p>
</blockquote>
<h2 id="1-unique-ptr—scope-pointer"><a href="#1-unique-ptr—scope-pointer" class="headerlink" title="1. unique_ptr—scope pointer"></a>1. unique_ptr—scope pointer</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Entity</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Entity</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Destoryed Entity!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Hello world!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-comment">// method 1: 不可以！！！</span><br>        <span class="hljs-comment">// std::unique_ptr&lt;Entity&gt; entity = new Entity(); // 这种写法不可以，因为unique_ptr的构造函数有explicit关键词，只能接受显式构造</span><br><br>        <span class="hljs-comment">// method 2: 可以，但是因为异常安全问题，不采用这种方法！！</span><br>        <span class="hljs-comment">// std::unique_ptr&lt;Entity&gt; entity(new Entity());</span><br><br>        <span class="hljs-comment">// method 3: 最好的方法，因为这样做安全。</span><br>        std::unique_ptr&lt;Entity&gt; entity = std::<span class="hljs-built_in">make_unique</span>&lt;Entity&gt;();<br>        entity-&gt;<span class="hljs-built_in">Print</span>();<br>    &#125;<br><br>    std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><span class="hljs-comment">// 程序输入如下</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Created Entity!</span><br><span class="hljs-comment">Hello world!</span><br><span class="hljs-comment">Destoryed Entity!</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>一个<strong>更好</strong>的做法是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unique_ptr&lt;Entity&gt; entity = std::<span class="hljs-built_in">make_unique</span>&lt;Entity&gt;();<br></code></pre></td></tr></table></figure>

<p>这对于<code>unique_ptr</code>来说很重要，主要原因是出于<em>exception safety</em> （异常安全），如果构造函数碰巧抛出异常，它会稍微安全一些。你不会最终得到一个没有引用的<em>dangling pointer</em>（悬空指针）而造成过内泄漏。</p>
</blockquote>
<ul>
<li>前面提到了<code>unique_ptr</code>不能被复制。如果你去看它的定义，你会发现它的拷贝构造函数和拷贝构造操作符实际上被删除了，这就是为什么你运行如下代码时会编译错误。</li>
</ul>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231229103852279.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="image-20231229103852279"></p>
<h2 id="2-shared-ptr"><a href="#2-shared-ptr" class="headerlink" title="2. shared_ptr"></a>2. shared_ptr</h2><ul>
<li>shared_ptr使用的是<em>reference counting</em>（引用计数）.</li>
</ul>
<p>举个例子，我刚创建了一个共享指针，又创建了另一个共享指针来复制它，此时我的引用计数是 2。第一个指针失效时，我的引用计数器减少 1，然后最后一个失效时，我的引用计数回到 0，就真的“dead”了，因此内存被释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Entity</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Entity</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Destoryed Entity!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Hello world!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-comment">// method 1: 不可以！因为shared_ptr需要分配控制块来存储引用计数。</span><br>        <span class="hljs-comment">// std::shared_ptr&lt;Entity&gt; sharedEntity(new Entity());</span><br><br>        <span class="hljs-comment">// method 2: 使用这样方法！</span><br>        std::shared_ptr&lt;Entity&gt; sharedEntity = std::<span class="hljs-built_in">make_shared</span>&lt;Entity&gt;();<br>        std::shared_ptr&lt;Entity&gt; e0 = sharedEntity;<br>    &#125;<br><br>    std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>关于shared_ptr的复制问题</li>
</ul>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231229110054206.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="image-20231229110054206"></p>
<p>有了共享指针，你当然可以进行复制。 下图代码中有两个作用域，可以看到里面这个作用域死亡时，这个 sharedEntity 失效了，然而并没有对 Entity 析构并删除，因为 e0 仍然是有效的，并且持有对该 Entity 的引用。再按一下 F10，当所有引用都没了，当所有追踪<code>shared_ptr</code>的栈分配对象都死亡后，底层的 Entity 才会从内存中释放并删除。</p>
<h2 id="3-weak-ptr"><a href="#3-weak-ptr" class="headerlink" title="3. weak_ptr"></a>3. weak_ptr</h2><ul>
<li><p>当你将一个<code>shared_ptr</code>赋值给另外一个<code>shared_ptr</code>，引用计数会增加。</p>
</li>
<li><p>当你把一个<code>shared_ptr</code>赋值给一个<code>weak_ptr</code>时，它不会增加引用计数。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Entity</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Entity</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Destoryed Entity!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Hello world!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        std::weak_ptr&lt;Entity&gt; e0;<br>        &#123;<br>            std::shared_ptr&lt;Entity&gt; sharedEntiy = std::<span class="hljs-built_in">make_shared</span>&lt;Entity&gt;();<br>            e0 = sharedEntiy;<br>        &#125;<br>    &#125;<br><br>    std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-smart-pointer-and-new-delete"><a href="#4-smart-pointer-and-new-delete" class="headerlink" title="4. smart pointer and new-delete"></a>4. smart pointer and new-delete</h2><p>这就是很有用的智能指针，但它们绝对没有完全取代<code>new</code>和<code>delete</code>关键字。只是当你要声明一个堆分配的对象而且不希望由自己来清理，这时候你就应该使用智能指针，尽量使用<code>unique_ptr</code>，因为它有较低的开销。但如果你需要在对象之间共享，不能使用<code>unique_ptr</code>的时候，就用<code>shared_ptr</code></p>
<h1 id="45-Copying-and-Copy-constructors-in-C"><a href="#45-Copying-and-Copy-constructors-in-C" class="headerlink" title="45. Copying and Copy constructors in C++"></a>45. Copying and Copy constructors in C++</h1><p>copy means: copy data and copy memory.</p>
<ol>
<li>创建一个String类</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 注释来自ChatGPT</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span> <span class="hljs-comment">// 包含 C 字符串处理函数所需的头文件</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* m_Buffer;         <span class="hljs-comment">// 存储字符串的字符数组</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> m_Size;    <span class="hljs-comment">// 字符串的长度（不包括 null 终止符）</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数，接受一个 C 风格字符串作为参数</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* string)<br>    &#123;<br>        m_Size = <span class="hljs-built_in">strlen</span>(string);                     <span class="hljs-comment">// 计算字符串的长度</span><br>        m_Buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m_Size + <span class="hljs-number">1</span>];             <span class="hljs-comment">// 为字符串分配内存，包括 null 终止符</span><br>        <span class="hljs-built_in">memcpy</span>(m_Buffer, string, m_Size + <span class="hljs-number">1</span>);        <span class="hljs-comment">// 将传入的字符串复制到 m_Buffer</span><br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数，释放动态分配的内存</span><br>    ~<span class="hljs-built_in">String</span>()<br>    &#123;<br>        <span class="hljs-keyword">delete</span>[] m_Buffer;<br>    &#125;<br><br>    <span class="hljs-comment">// 声明友元，使得重载的输出运算符能够访问类的私有成员</span><br>    <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="hljs-type">const</span> String&amp; string);<br>&#125;;<br><br><span class="hljs-comment">// 重载输出运算符</span><br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="hljs-type">const</span> String&amp; string)<br>&#123;<br>    stream &lt;&lt; string.m_Buffer;    <span class="hljs-comment">// 将字符串输出到流</span><br>    <span class="hljs-keyword">return</span> stream;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建 String 对象并初始化为 &quot;Cherno&quot;</span><br>    String string = <span class="hljs-string">&quot;Cherno&quot;</span>;<br><br>    <span class="hljs-comment">// 使用重载的输出运算符输出 String 对象的内容</span><br>    std::cout &lt;&lt; string &lt;&lt; std::endl;<br><br>    std::cin.<span class="hljs-built_in">get</span>();  <span class="hljs-comment">// 等待用户输入</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="1-shallow-copy"><a href="#1-shallow-copy" class="headerlink" title="1. shallow copy"></a>1. shallow copy</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">char</span>* m_Buffer;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> m_Size;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* string)<br>	&#123;<br>		m_Size = <span class="hljs-built_in">strlen</span>(string);<br>		m_Buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m_Size + <span class="hljs-number">1</span>];<br>		<span class="hljs-built_in">memcpy</span>(m_Buffer, string, m_Size + <span class="hljs-number">1</span>);<br>	&#125;<br><br>	~<span class="hljs-built_in">String</span>()<br>	&#123;<br>		<span class="hljs-keyword">delete</span>[] m_Buffer;<br>	&#125;<br><br>	<span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="hljs-type">const</span> String&amp; string);<br>&#125;;<br><br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="hljs-type">const</span> String&amp; string)<br>&#123;<br>	stream &lt;&lt; string.m_Buffer;<br>	<span class="hljs-keyword">return</span> stream;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	String string = <span class="hljs-string">&quot;Cherno&quot;</span>;<br>	String second = string; <span class="hljs-comment">// 浅拷贝</span><br><br>	std::cout &lt;&lt; string &lt;&lt; std::endl;<br>	std::cout &lt;&lt; second &lt;&lt; std::endl;<br>	<span class="hljs-comment">// 程序崩溃！</span><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在问题来了，内存中有两个 String，因为它们直接进行了复制，这种复制被称为<em>shallow copy</em>（浅拷贝）。它所做的是复制这个 char<em>，内存中的两个 String 对象有相同的 char</em>的值，换句话说就是有相同的内存地址。这个 m_Buffer 的内存地址，对于这两个 String 对象来说是相同的，所以程序会崩溃的原因是当我们到达作用域的尽头时，这两个 String 都被销毁了，析构函数会被调用，然后执行<code>delete[] m_Buffer</code>两次，程序试图两次释放同一个内存块。这就是为什么程序会崩溃——因为内存已经释放了，不再是我们的了，我们无法再次释放它。</p>
<h2 id="2-deep-copy-—-copy-constructor"><a href="#2-deep-copy-—-copy-constructor" class="headerlink" title="2. deep copy — copy constructor"></a>2. deep copy — copy constructor</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">char</span>* m_Buffer;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> m_Size;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* string)<br>	&#123;<br>		m_Size = <span class="hljs-built_in">strlen</span>(string);<br>		m_Buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m_Size + <span class="hljs-number">1</span>];<br>		<span class="hljs-built_in">memcpy</span>(m_Buffer, string, m_Size + <span class="hljs-number">1</span>);<br>	&#125;<br><br>	~<span class="hljs-built_in">String</span>()<br>	&#123;<br>		<span class="hljs-keyword">delete</span>[] m_Buffer;<br>	&#125;<br>	<br>	<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; other) <span class="hljs-comment">// copy constructor</span><br>		: <span class="hljs-built_in">m_Size</span>(other.m_Size)<br>	&#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;Copied String!&quot;</span> &lt;&lt; std::endl;<br>		m_Buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m_Size + <span class="hljs-number">1</span>];<br>		<span class="hljs-built_in">memcpy</span>(m_Buffer, other.m_Buffer, m_Size + <span class="hljs-number">1</span>);<br>	&#125;<br><br>	<span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index)<br>	&#123;<br>		<span class="hljs-keyword">return</span> m_Buffer[index];<br>	&#125;<br><br>	<span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="hljs-type">const</span> String&amp; string);<br>&#125;;<br><br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="hljs-type">const</span> String&amp; string)<br>&#123;<br>	stream &lt;&lt; string.m_Buffer;<br>	<span class="hljs-keyword">return</span> stream;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintString</span><span class="hljs-params">(<span class="hljs-type">const</span> String&amp; string)</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; string &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	String string = <span class="hljs-string">&quot;Cherno&quot;</span>;<br>	String second = string;<br><br>	second[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;a&#x27;</span>;<br><br>	<span class="hljs-built_in">PrintString</span>(string);<br>	<span class="hljs-built_in">PrintString</span>(second);<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="46-The-Arrow-Operator-in-C"><a href="#46-The-Arrow-Operator-in-C" class="headerlink" title="46. The Arrow Operator in C++"></a>46. The Arrow Operator in C++</h1><h2 id="1-pointer-reference-arrow"><a href="#1-pointer-reference-arrow" class="headerlink" title="1. pointer, reference, arrow"></a>1. pointer, reference, arrow</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello!&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Entity e;<br>	e.<span class="hljs-built_in">Print</span>();<br><br>	Entity* ptr = &amp;e;<br>	(*ptr).<span class="hljs-built_in">Print</span>(); <span class="hljs-comment">// 考虑运算符优先级</span><br><br>	Entity* ptr1 = &amp;e;<br>	Entity&amp; entity = *ptr1;<br>	entity.<span class="hljs-built_in">Print</span>();<br><br>	Entity* ptr2 = &amp;e;<br>	ptr2-&gt;<span class="hljs-built_in">Print</span>();<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-overloading"><a href="#2-overloading" class="headerlink" title="2. overloading"></a>2. overloading</h2><p>箭头作为一种运算符，C++可以重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello!&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopedPtr</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>	Entity* m_Obj;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">ScopedPtr</span>(Entity* entity)<br>		:<span class="hljs-built_in">m_Obj</span>(entity)<br>	&#123;<br><br>	&#125;<br><br>	~<span class="hljs-built_in">ScopedPtr</span>()<br>	&#123;<br>		<span class="hljs-keyword">delete</span> m_Obj;<br>	&#125;<br><br>	Entity* <span class="hljs-keyword">operator</span>-&gt;()<br>	&#123;<br>		<span class="hljs-keyword">return</span> m_Obj;<br>	&#125;<br>	<br>	<span class="hljs-type">const</span> Entity* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> m_Obj;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	ScopedPtr entity = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Entity</span>();<br>	entity-&gt;<span class="hljs-built_in">Print</span>();<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-offset"><a href="#3-offset" class="headerlink" title="3. offset"></a>3. offset</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vector3</span><br>&#123;<br>	<span class="hljs-type">float</span> x, y, z;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> offsetx = (<span class="hljs-type">int</span>)&amp;((Vector3*)<span class="hljs-literal">nullptr</span>)-&gt;x;<br>	std::cout &lt;&lt; offsetx &lt;&lt; std::endl;<br><br>	<span class="hljs-type">int</span> offsety = (<span class="hljs-type">int</span>)&amp;((Vector3*)<span class="hljs-literal">nullptr</span>)-&gt;y;<br>	std::cout &lt;&lt; offsety &lt;&lt; std::endl;<br><br>	<span class="hljs-type">int</span> offsetz = (<span class="hljs-type">int</span>)&amp;((Vector3*)<span class="hljs-literal">nullptr</span>)-&gt;z;<br>	std::cout &lt;&lt; offsetz &lt;&lt; std::endl;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">8</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>







<h1 id="附：编程习惯"><a href="#附：编程习惯" class="headerlink" title="附：编程习惯"></a>附：编程习惯</h1><h2 id="A-m"><a href="#A-m" class="headerlink" title="A. m_"></a>A. m_</h2><p><a target="_blank" rel="noopener" href="https://21xrx.com/Articles/read_article/217704">C++中m_的含义是什么？ |21xrx.com</a></p>
<blockquote>
<p>在C++中，m_是一种命名约定，通常被用于表示一个类的成员变量。m_的含义是”member variable”或者”成员变量”，是为了区分成员变量和其他类型的变量而引入的。</p>
<p>使用m_的好处是可以方便地区分成员变量和其他变量，使代码变得更加可读和易于理解。此外，m_还可以避免与全局变量、局部变量或其他变量混淆，从而避免出现代码错误。</p>
<p>在使用m_时，需要注意以下几点：</p>
<p>\1. m_只是一种命名约定，不是C++的关键字或保留字，因此在使用时不要将其与其他变量名混淆。</p>
<p>\2. 使用m_时应该遵循统一的规范，例如将所有成员变量都以m_为前缀命名。</p>
<p>\3. 在构造函数和析构函数中，应该将所有成员变量的初始值或释放操作放在一起，以方便管理。</p>
<p>\4. 注意，在使用m_时应该尽可能使用访问器（getter和setter）而不是直接访问成员变量，这样可以使代码更加可维护和易于修改。</p>
<p>总的来说，m_是一种很好的命名约定，可以使代码更加清晰和易于理解。在编写C++代码时，使用m_能够提高代码的可读性和可维护性，值得开发者们好好利用。</p>
</blockquote>
<h2 id="B-命名规则"><a href="#B-命名规则" class="headerlink" title="B. 命名规则"></a>B. 命名规则</h2><h3 id="1-驼峰"><a href="#1-驼峰" class="headerlink" title="1. 驼峰"></a>1. 驼峰</h3><p>原始：<code>user login count</code></p>
<p>驼峰：<code>userLoginCount</code></p>
<h3 id="2-帕斯卡"><a href="#2-帕斯卡" class="headerlink" title="2. 帕斯卡"></a>2. 帕斯卡</h3><p>原始：<code>user login count</code></p>
<p>帕斯卡：<code>UserLoginCount</code></p>
<h3 id="3-蛇形"><a href="#3-蛇形" class="headerlink" title="3. 蛇形"></a>3. 蛇形</h3><p>原始：<code>user login count</code></p>
<p>蛇形：<code>user_login_count</code></p>
<h3 id="4-匈牙利"><a href="#4-匈牙利" class="headerlink" title="4. 匈牙利"></a>4. 匈牙利</h3><p><code>int g_i32tempuratureValue</code>:全局 32位有符号整型变量</p>
<p><code>float l_f32tempuratureValue</code>:局部 32位有符号整型变量</p>
<p><code>unsigned char s_u8tempuratureValue</code>:静态 无符号字符型变量</p>
<p>参考：<a target="_blank" rel="noopener" href="https://zh-google-styleguide.readthedocs.io/en/latest/contents/#">内容目录 — Google 开源项目风格指南 (zh-google-styleguide.readthedocs.io)</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/" class="category-chain-item">知识积累</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/CPP/" class="print-no-link">#CPP</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>ChernoCPP-1</div>
      <div>https://cosmicdusty.cc/post/Knowledge/ChernoCPP_1/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Murphy</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月13日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/post/Tools/WorkingWithLabPC/" title="瞧瞧我对教研室的电脑干了些什么！">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">瞧瞧我对教研室的电脑干了些什么！</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/post/Tools/WorkingWithGPUServer/" title="瞧瞧我对服务器干了些什么！">
                        <span class="hidden-mobile">瞧瞧我对服务器干了些什么！</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"JijHNKemeVNog4wF7g9I5TR3-gzGzoHsz","appKey":"FvsKdxHOP2aG5rHrHby5aV0b","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a rel="nofollow noopener"><span>Powered by</span></a> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span><b>Hexo</b></span></a> <i class="iconfont icon-love"></i> <a rel="nofollow noopener"><span>Themed by</span></a> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span><b>Fluid</b></span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量
        <span id="busuanzi_value_site_pv"></span>
        次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数
        <span id="busuanzi_value_site_uv"></span>
        人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
