

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="https://murphyimg.oss-cn-beijing.aliyuncs.com/img/202505301726222.png">
  <link rel="icon" href="https://murphyimg.oss-cn-beijing.aliyuncs.com/img/202505301728148.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Murphy">
  <meta name="keywords" content="Murphy,CosmicDusty,murphy,cosmicdusty,cn">
  
    <meta name="description" content="第一次学习C++还是在2020疫情在家上网课的时候，那时候因为上学期没学习C，只是寒假在家刷了一下C的教程，再加上是在家上网课的授课形式，所以C++学的一塌糊涂，C++一直成为自己的一块儿“心病”。之前也有过学习C++的打算的，但是没有看到很合适的教程，能找到的教程都在教很基础的东西，我听起来也觉得有些无趣。因为前段时间一直都在学习深度学习的东西，学得有点烦，就想学些别的东西换换脑子，也相当于给自">
<meta property="og:type" content="article">
<meta property="og:title" content="ChernoCPP-2">
<meta property="og:url" content="https://blog.cosmicdusty.cc/post/Knowledge/ChernoCPP_2/index.html">
<meta property="og:site_name" content="Murphy Hou - Blog">
<meta property="og:description" content="第一次学习C++还是在2020疫情在家上网课的时候，那时候因为上学期没学习C，只是寒假在家刷了一下C的教程，再加上是在家上网课的授课形式，所以C++学的一塌糊涂，C++一直成为自己的一块儿“心病”。之前也有过学习C++的打算的，但是没有看到很合适的教程，能找到的教程都在教很基础的东西，我听起来也觉得有些无趣。因为前段时间一直都在学习深度学习的东西，学得有点烦，就想学些别的东西换换脑子，也相当于给自">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231225120947890.png">
<meta property="article:published_time" content="2023-12-29T03:33:08.000Z">
<meta property="article:modified_time" content="2024-04-21T14:01:13.000Z">
<meta property="article:author" content="Murphy">
<meta property="article:tag" content="CPP">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231225120947890.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>ChernoCPP-2 - Murphy Hou - Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"blog.cosmicdusty.cc","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"16d93d5abbd7ea15ec53daed5459ebf7","google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"JijHNKemeVNog4wF7g9I5TR3","app_key":"FvsKdxHOP2aG5rHrHby5aV0b","server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?16d93d5abbd7ea15ec53daed5459ebf7";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>CosmicDusty</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20231225120947890.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="ChernoCPP-2"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Murphy
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-12-29 11:33" pubdate>
          2023年12月29日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          134 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">ChernoCPP-2</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Back-to-Top"><a href="#Back-to-Top" class="headerlink" title="Back to Top"></a>Back to Top</h1><h2 id="Video-Links"><a href="#Video-Links" class="headerlink" title="Video Links"></a>Video Links</h2><div align = center>
  <iframe width="560" height="315" src="https://www.youtube.com/embed/18c3MTX0PK0?si=bLufMIg-rIzpv17Y" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
</div>

<h2 id="Notebook-Links"><a href="#Notebook-Links" class="headerlink" title="Notebook Links"></a>Notebook Links</h2><ul>
<li><a target="_blank" rel="noopener" href="https://thecherno.com/">Cherno (thecherno.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/">📘 The Cherno’s C++ Course Notes 📘</a></li>
<li><a target="_blank" rel="noopener" href="https://space.bilibili.com/364152971/channel/collectiondetail?sid=13909">神经元猫的个人空间-神经元猫个人主页-哔哩哔哩视频 (bilibili.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cppreference.com</a></li>
<li><a target="_blank" rel="noopener" href="https://atomlab.org/posts/code/learn-cpp/learn-cpp/">如何在两周内学会C++并构建优质的项目 | Atomlab</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/h3upVc/">Bilibili ｜ C++ 工程师｜面经汇总｜2020.12｜ - 力扣（LeetCode）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhangjiee.com/blog/2012/how-to-learn-cpp.html">如何学习C++ (zhangjiee.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://cppguide.cn/">CppGuide社区</a></li>
</ul>
<h1 id="47-Dynamic-Arrays-in-C"><a href="#47-Dynamic-Arrays-in-C" class="headerlink" title="47. Dynamic Arrays in C++"></a>47. Dynamic Arrays in C++</h1><blockquote>
<p>所以C++提供给我们一个叫做<code>Vector</code>的类，这个Vector在<em>std namespace</em>（std命名空间中）。</p>
<p>为什么叫Vector？可以在<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/581426/why-is-a-c-vector-called-a-vector">链接</a>中了解到背后的故事： 它被称为向量是因为标准模板库的设计者 Alex Stepanov 在寻找一个名称以区分它与内置数组时采用了这个名字。他现在承认这是一个错误，因为数学已经使用术语 “向量” 来表示一组固定长度的数字序列。而 C++11 则进一步加重了这个错误，引入了一个名为 ‘array’ 的类，它的行为类似于数学上的向量。 Alex 给我们的教训是：在给事物命名时要非常小心谨慎。</p>
<p>所以它其实不应该被叫做<em>Vector</em>（向量），而是应该被称为类似<em><strong>ArrayList</strong></em>，这样更有意义，因为它本质上是一个<strong>动态数组</strong>。它有点像一个集合，一个不强制其实际元素具有唯一性的集合。 换句话说，它基本上就是一个<em>array</em>（数组），不过与C++普通数组类型（原始数组或标准数组类[31 Arrays in C++](<a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/1-50/31">https://nagi.fun/Cherno-CPP-Notes/1-50/31</a> Arrays in C%2B%2B&#x2F;)）不同的是，它可<strong>以调整数组大小</strong>，这意味着当你创建这个vector的时候，这个动态数组的时候，它并<strong>没有固定大小</strong>。你可以给它一个固定大小，如果你想用一个特定的大小初始化它。但一般情况下我们不给它设置一个size。 你只需要创建这个Vector然后把元素放进去，每次你往里面放一个元素，数组大小会增长。 </p>
<p><strong>原理：当你超过分配的内存大小时，它会在内存中创建一个比第一个大的新数组，把所有东西都复制到这里，然后删除旧的那个，这样你就拥有了更多存储空间的新数组。</strong>（所以可以猜测Alex当时是觉得动态数组可以像向量一样无限延长……）</p>
<p>[47 C++的动态数组(std::vector) - cherno-cpp-notes (nagi.fun)](<a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/1-50/47">https://nagi.fun/Cherno-CPP-Notes/1-50/47</a> Dynamic Arrays in C%2B%2B (std - -vector)&#x2F;)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vertex</span><br>&#123;<br>	<span class="hljs-type">float</span> x, y, z;<br>&#125;;<br><br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="hljs-type">const</span> Vertex&amp; vertex)<br>&#123;<br>	stream &lt;&lt; vertex.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; vertex.y &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; vertex.z;<br>	<span class="hljs-keyword">return</span> stream;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::vector&lt;Vertex&gt; vertices;<br>	vertices.<span class="hljs-built_in">push_back</span>(&#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;);<br>	vertices.<span class="hljs-built_in">push_back</span>(&#123; <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;);<br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;first&quot;</span> &lt;&lt; std::endl;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vertices.<span class="hljs-built_in">size</span>(); i++)<br>		std::cout &lt;&lt; vertices[i] &lt;&lt; std::endl;<br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;second&quot;</span> &lt;&lt; std::endl;<br>	<span class="hljs-keyword">for</span> (Vertex&amp; v: vertices) <br>		std::cout &lt;&lt; v &lt;&lt; std::endl;<br>	<span class="hljs-comment">// 这是一种新的写法！！</span><br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;third&quot;</span> &lt;&lt; std::endl;<br>	vertices.<span class="hljs-built_in">erase</span>(vertices.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>);<br><br>	<span class="hljs-keyword">for</span> (Vertex&amp; v : vertices)<br>		std::cout &lt;&lt; v &lt;&lt; std::endl;<br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;forth&quot;</span> &lt;&lt; std::endl;<br>	vertices.<span class="hljs-built_in">clear</span>();<br>	<span class="hljs-comment">//for (vertex&amp; v : vertices)</span><br>	<span class="hljs-comment">//	std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="48-Optimizing-the-usage-of-std-vector-in-C"><a href="#48-Optimizing-the-usage-of-std-vector-in-C" class="headerlink" title="48. Optimizing the usage of std::vector in C++"></a>48. Optimizing the usage of std::vector in C++</h1><blockquote>
<p><code>std::vector class</code>基本上是这样工作的： 你创建一个 vector，然后你开始<code>push_back</code>元素，也就是向数组中添加元素。如果 vector 的容量不够大，不能容纳你想要的新元素。vector 需要分配新的内存，至少足够容纳这些想要加入的新元素和当前已有的内容，从内存中的旧位置复制到内存中的新位置，然后删除旧位置的内存。 所以当我们尝试<code>push_back</code>一个元素的时候，如果容量用完，它就会调整大小，重新进行分配——这就是将代码拖慢的原因之一。事实上，我们需要不断地重新分配，which is a 缓慢的操作，我们需要重新分配当我们要复制所有的现有元素的时候，这是我们要避免的。 事实上，这就是我们现在对于复制的优化策略：我们如何避免复制对象，如果我们处理的是 vector，特别是基于 vector 的对象<strong>（我们没有存储 vector 指针，我们存储的是 vector 对象）</strong>。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vertex</span><br>&#123;<br>	<span class="hljs-type">float</span> x, y, z;<br><br>	<span class="hljs-built_in">Vertex</span>(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y, <span class="hljs-type">float</span> z)<br>		:<span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y), <span class="hljs-built_in">z</span>(z) &#123;&#125;<br>	<br>	<span class="hljs-built_in">Vertex</span>(<span class="hljs-type">const</span> Vertex&amp; vertex)<br>		:<span class="hljs-built_in">x</span>(vertex.x), <span class="hljs-built_in">y</span>(vertex.y), <span class="hljs-built_in">z</span>(vertex.z)<br>	&#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;Copied!&quot;</span> &lt;&lt; std::endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::vector&lt;Vertex&gt; vertices;<br>	vertices.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Vertex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br>	vertices.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Vertex</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>));<br>	vertices.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Vertex</span>(<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>));<br><br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Copied!</span><br><span class="hljs-comment">Copied!</span><br><span class="hljs-comment">Copied!</span><br><span class="hljs-comment">Copied!</span><br><span class="hljs-comment">Copied!</span><br><span class="hljs-comment">Copied!</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>


<ul>
<li>如果我们了解自己的“环境”，就是如果我们知道本身计划要放进 3 个 vertex 对象，为什么不让 vector 一开始就留下足够 3 个元素的内存，这样就不用调整两次大小了。 -&gt; <code>vertices.reserve(3);</code>这就是第二种优化策略。</li>
<li>我们所做的就是将 vertex 从 main 函数复制到 vector 类中,如果我们可以再适当的位置构造那个 vertex，在 vector 实际分配的内存中，这就是优化策略一号。在这种情况下，不是传递我们已经构建的 vertex 对象，而是只是传递了构造函数的参数列表，它告诉我们的 vector：在我们是的 vector 内存中，使用以下参数来构造一个 vertex 对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vertex</span><br>&#123;<br>	<span class="hljs-type">float</span> x, y, z;<br><br>	<span class="hljs-built_in">Vertex</span>(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y, <span class="hljs-type">float</span> z)<br>		:<span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y), <span class="hljs-built_in">z</span>(z) &#123;&#125;<br>	<br>	<span class="hljs-built_in">Vertex</span>(<span class="hljs-type">const</span> Vertex&amp; vertex)<br>		:<span class="hljs-built_in">x</span>(vertex.x), <span class="hljs-built_in">y</span>(vertex.y), <span class="hljs-built_in">z</span>(vertex.z)<br>	&#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;Copied!&quot;</span> &lt;&lt; std::endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::vector&lt;Vertex&gt; vertices;<br>	vertices.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">3</span>);<br>	vertices.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>	vertices.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>	vertices.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">No any copies!</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>



<h1 id="49-Using-Libraries-in-C-Static-Linking"><a href="#49-Using-Libraries-in-C-Static-Linking" class="headerlink" title="49. Using Libraries in C++(Static Linking)"></a>49. Using Libraries in C++(Static Linking)</h1><p><a target="_blank" rel="noopener" href="https://www.glfw.org/">An OpenGL library | GLFW</a></p>
<p>[49 C++中使用库（静态链接） - cherno-cpp-notes (nagi.fun)](<a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/1-50/49">https://nagi.fun/Cherno-CPP-Notes/1-50/49</a> Using Libraries in C%2B%2B (Static Linking)&#x2F;)</p>
<h2 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h2><ul>
<li><p>静态链接</p>
<ul>
<li><strong>静态链接意味着这个库会被放到你的可执行文件中</strong>（它在你的 exe 文件内部，或者其它操作系统下的可执行文件内）。</li>
</ul>
</li>
<li><p>动态链接</p>
<ul>
<li>动态链接库是在运行时被链接的额，所以你仍有一些链接，你可以选择在程序运行时装载动态链接库，有一个叫<em>loadLibrary</em>的函数，你可以在 WindowsAPI 中使用它作为例子。它会载入你的动态库，可以从中拉出函数然后开始调用。你也可以在应用程序启动时加载你的 dll 文件，这就是你的<em>Dynamic Link Library</em>（动态链接库）。</li>
<li><strong>所以主要的区别就是：库文件是否被编译到 exe 文件中，或链接到 exe 文件中，还是一个在运行时单独的文件，你需要把它放在你的 exe 文件旁边或某个地方，然后你的 exe 文件可以加载它。因为这种依赖性，你需要把 exe 文件和 dll 文件弄在一起。</strong></li>
<li>所以通常喜欢用静态的。静态链接在技术上更快，因为编译器或链接器实际上可以执行链接时优化之类的。静态链接在技术上可以产生更快的应用程序，因为有几种优化方法可以应用，因为我们知道在链接时要链接的函数。而对于动态库，我们不知道会发生什么而必须保持它的完整，当动态链接库被运行时的程序装载时，程序的部分将被补充完整。</li>
</ul>
</li>
</ul>
<p>所以通常情况下，<strong>静态链接是更好的选择</strong>。</p>
<h2 id="静态链接实例"><a href="#静态链接实例" class="headerlink" title="静态链接实例"></a>静态链接实例</h2><p>在Visual Studio中，需要对Solution Property进行修改。参考：[49 C++中使用库（静态链接） - cherno-cpp-notes (nagi.fun)](<a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/1-50/49">https://nagi.fun/Cherno-CPP-Notes/1-50/49</a> Using Libraries in C%2B%2B (Static Linking)&#x2F;)</p>
<h1 id="50-Using-Dynamic-Libraries-in-C"><a href="#50-Using-Dynamic-Libraries-in-C" class="headerlink" title="50. Using Dynamic Libraries in C++"></a>50. Using Dynamic Libraries in C++</h1><p>动态链接发生在<em>runtime</em>（运行时），而静态链接是在编译时发生的。 当你编译一个静态库的时候，将其链接到可执行文件，也就是应用程序，或者链接到一个动态库。就像你取出了那个静态库的内容，然后你把那些内容放入到其它的二进制数据中，实际在你的动态库中或者在你的可执行文件中。</p>
<p>有很多地方可以优化，因为编译器和链接器现在完全知道静态链接时实际进入应用程序的代码（静态链接允许更多的优化发生）。 而动态链接发生在运行时，所以只有你真正启动你的可执行文件时，你的动态链接库才会被加在，所以它实际上不是可执行文件的一部分（运行时将一个额外的文件加载到内存中）。</p>
<p>现在可执行文件在实际运行前就需要具备某些库、某些动态库、某些外部文件，这就是为什么你在Windows上启动一个应用程序时，可能看到一个错误消息弹出：需要dll、没有找到dll……. 这是动态链接的一种形式，可执行文件知道动态链接库的存在，把动态库作为一项需要，虽然动态库仍然是一个单独的文件，一个单独的模块，并在运行时加载。你也可以完全动态地加载动态库，这样可执行文件就与动态库完全没有任何关系了，但是在你的可执行文件中，你可以查找并在运行时加载某些动态库，然后获得某些函数指针或者动态库里你想要的东西，然后使用那个动态库。</p>
<p>对于动态库，请记住两个版本。 第一个是“静态的”动态库的版本，我的应用程序现场需要这个动态链接库，我已经知道里面有什么函数，我可以用什么。 第二个版本是我想任意加载这个动态库，我甚至不需要知道里面有什么，但我想取出一些东西或者做很多事。 这两种动态库都有很好的用途，先专注看第一种：我知道我的应用程序需要这个库，但我要动态地链接它。</p>
<p>如果你要对比静态和动态链接的话，对于函数之类的声明，动态链接时实际有些不同。但GLFW像大多数库一样，同时支持静态和动态链接，使用相同的头文件。</p>
<p>见上节课，<code>.dll</code>和<code>dll.lib</code>同时编译是非常重要的，因为如果你尝试使用不同的静态库，在运行时链接到dll，你可能会得到不匹配的函数和错误类型的内存地址，函数指针不会正常工作。</p>
<h1 id="51-Making-and-Working-with-Libraries-in-C-Multiple-Projects-in-Visual-Studio"><a href="#51-Making-and-Working-with-Libraries-in-C-Multiple-Projects-in-Visual-Studio" class="headerlink" title="51. Making and Working with Libraries in C++(Multiple Projects in Visual Studio)"></a>51. Making and Working with Libraries in C++(Multiple Projects in Visual Studio)</h1><p>[51 C++中创建与使用库 - cherno-cpp-notes (nagi.fun)](<a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/51-100/51">https://nagi.fun/Cherno-CPP-Notes/51-100/51</a> Making and Working with Libraries in C%2B%2B (Multiple Projects in VS)&#x2F;)</p>
<h1 id="52-How-to-Deal-with-Multiple-Return-Values-in-C"><a href="#52-How-to-Deal-with-Multiple-Return-Values-in-C" class="headerlink" title="52. How to Deal with Multiple Return Values in C++"></a>52. How to Deal with Multiple Return Values in C++</h1><p>[52 C++中如何处理多返回值 - cherno-cpp-notes (nagi.fun)](<a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/51-100/52">https://nagi.fun/Cherno-CPP-Notes/51-100/52</a> How to Deal with Multiple Return Values in C%2B%2B&#x2F;)</p>
<h2 id="1-指针和引用"><a href="#1-指针和引用" class="headerlink" title="1. 指针和引用"></a>1. 指针和引用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">returnWithReference</span><span class="hljs-params">(std::string&amp; str, <span class="hljs-type">int</span>&amp; num)</span></span><br><span class="hljs-function"></span>&#123;<br>	str = <span class="hljs-string">&quot;Hello&quot;</span>;<br>	num = <span class="hljs-number">42</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::string str;<br>	<span class="hljs-type">int</span> num;<br>	<span class="hljs-built_in">returnWithReference</span>(str, num);<br><br>	std::cout &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; num &lt;&lt; std::endl;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>




<h2 id="2-array和vector"><a href="#2-array和vector" class="headerlink" title="2. array和vector"></a>2. array和vector</h2><blockquote>
<p>Array和vector的区别：array会在栈上创建，而vector会把它的底层存储在堆上，所以从技术上讲返回<code>std::array</code>会更快。</p>
<p>注意：多返回值需要是同类型</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function">std::array&lt;<span class="hljs-type">int</span>, 2&gt; <span class="hljs-title">returnWithArray</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::array&lt;<span class="hljs-type">int</span>, 2&gt; result;<br><br>	result[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span>;<br>	result[<span class="hljs-number">1</span>] = <span class="hljs-number">56</span>;<br><br>	<span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">returnWithVector</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::vector&lt;<span class="hljs-type">int</span>&gt; result;<br><br>	result.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">42</span>);<br>	result.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">56</span>);<br><br>	<span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::array&lt;<span class="hljs-type">int</span>, 2&gt; arrResult = <span class="hljs-built_in">returnWithArray</span>();<br>	std::cout &lt;&lt; arrResult[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; arrResult[<span class="hljs-number">1</span>] &lt;&lt; std::endl;<br><br>	std::vector&lt;<span class="hljs-type">int</span>&gt; vecResult = <span class="hljs-built_in">returnWithVector</span>();<br>	std::cout &lt;&lt; vecResult[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; vecResult[<span class="hljs-number">1</span>] &lt;&lt; std::endl;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="3-tuple和pair"><a href="#3-tuple和pair" class="headerlink" title="3. tuple和pair"></a>3. tuple和pair</h2><blockquote>
<p>tuple基本上是一个类，它可以包含x个变量，但不关心类型，</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><br><span class="hljs-function">std::tuple&lt;std::string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">returnWithTuple</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">42</span>);<br>&#125;<br><br><span class="hljs-function">std::pair&lt;std::string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">returnWithPair</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">42</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::tuple&lt;std::string, <span class="hljs-type">int</span>&gt; tupleResult = <span class="hljs-built_in">returnWithTuple</span>();<br>	std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(tupleResult) &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(tupleResult) &lt;&lt; std::endl;<br><br>	std::pair&lt;std::string, <span class="hljs-type">int</span>&gt; pairResult = <span class="hljs-built_in">returnWithPair</span>();<br>	std::cout &lt;&lt; pairResult.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; pairResult.second &lt;&lt; std::endl;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-Struct⭐-Cherno推荐使用的方法"><a href="#4-Struct⭐-Cherno推荐使用的方法" class="headerlink" title="4. Struct⭐ (Cherno推荐使用的方法)"></a>4. Struct⭐ (Cherno推荐使用的方法)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Result</span><br>&#123;<br>	std::string str;<br>	<span class="hljs-type">int</span> num;<br>&#125;;<br><br><span class="hljs-function">Result <span class="hljs-title">returnWithStruct</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Result result;<br>	result.str = <span class="hljs-string">&quot;Hello&quot;</span>;<br>	result.num = <span class="hljs-number">42</span>;<br><br>	<span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Result structResult = <span class="hljs-built_in">returnWithStruct</span>();<br>	std::cout &lt;&lt; structResult.str &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; structResult.num &lt;&lt; std::endl;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="53-Templates-in-C"><a href="#53-Templates-in-C" class="headerlink" title="53. Templates in C++"></a>53. Templates in C++</h1><h2 id="1-函数重载"><a href="#1-函数重载" class="headerlink" title="1. 函数重载"></a>1. 函数重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(std::string value)</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-type">float</span> value)</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">Print</span>(<span class="hljs-number">5</span>);<br>	<span class="hljs-built_in">Print</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>	<span class="hljs-built_in">Print</span>(<span class="hljs-number">5.5f</span>);<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-模板"><a href="#2-模板" class="headerlink" title="2. 模板"></a>2. 模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(T value)</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">Print</span>(<span class="hljs-number">5</span>);<br>	<span class="hljs-built_in">Print</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>	<span class="hljs-built_in">Print</span>(<span class="hljs-number">5.5f</span>);<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>模板只有在它被调用时才会创建，否则它根本就不存在。你甚至在里面有语法错误，只要不调用都不会影响编译。<strong>（视频中的VS2017是这样的，但目前VS2022中的错误就算不调用也会影响编译。）</strong></p>
</blockquote>
<h2 id="3-用在类上的模板"><a href="#3-用在类上的模板" class="headerlink" title="3. 用在类上的模板"></a>3. 用在类上的模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>	T m_Array[N];<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> N; &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">5</span>&gt; array1;<br>	std::cout &lt;&lt; array<span class="hljs-number">1.</span><span class="hljs-built_in">GetSize</span>() &lt;&lt; std::endl;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-哪里用模板？哪里不用"><a href="#4-哪里用模板？哪里不用" class="headerlink" title="4. 哪里用模板？哪里不用"></a>4. 哪里用模板？哪里不用</h2><p>本部分完全是主观的，仅供参考。 <strong>很多游戏工作室或软件公司实际上禁止使用模板</strong>，但模板非常有用，比如在日志系统或者其它的使用场景下，你想记录每一种可能的类型，难道你真的要为每个函数都进行重载吗？你可以用模板自动完成，也就是你可以让编译器基于一些规则为你写代码。 这是说，你可以深入使用模板来做一些很好的事，但如果你的模板变得非常复杂，你开始让它为你生成一个完整的元语言就有点过头了。因为这里有一个平衡点，当模板变得越来越复杂时，没人能搞懂它是做什么的了，你得花大量时间弄清楚哪些代码已经被编译了以及你的模板到底发生了什么而不能工作。这种情况说明你做的过头了。</p>
<p>Cherno 的观点是：手动做一些事，自己写代码实际上会让你和你的团队受益更多，而不是试图创建庞大的模板魔法般地为你做所有事。所以模板不应该被完全禁止，但也不应该滥用。比如游戏引擎的<strong>日志系统</strong>和<strong>材质系统</strong>肯定会用到模板，当你有一个可以包含各种不同类型的统一缓冲区时，模板在一定程序上是非常有用的。</p>
<h1 id="54-Stack-vs-Heap-Memory-in-C"><a href="#54-Stack-vs-Heap-Memory-in-C" class="headerlink" title="54. Stack vs Heap Memory in C++"></a>54. Stack vs Heap Memory in C++</h1><h2 id="1-什么是栈和堆？"><a href="#1-什么是栈和堆？" class="headerlink" title="1. 什么是栈和堆？"></a>1. 什么是栈和堆？</h2><p>应用程序启动后，操作系统要做的就是将整个程序加载到内存，并分配一大堆物理 RAM（<em>随机存取存储器：Random Access Memory</em>）以便我们的实际应用程序可以运行。 栈和堆是 RAM 中实际存在的两个区域： 栈<em>stack</em>通常是一个预定义大小的内存区域，通常约为 2 兆字节（2MB）左右； 堆<em>heap</em>也是一个预定义了默认值的区域，但是它可以增长，并随着应用程序的进行而改变。 重要的是要知道这两个内存区域的实际物理位置都是在 RAM 中，很多人倾向于认为栈存储在 CPU 缓存中或类似的位置，它确实因为我们不停访问而在缓存中活跃，但不是所有的栈内存都会存储在这里，这并不是它的工作方式。只要记住这两个内存区域的实际位置都在我们的内存中，这就是为什么内存中有两个不同区域的原因。</p>
<h2 id="2-栈与堆的内存分配"><a href="#2-栈与堆的内存分配" class="headerlink" title="2. 栈与堆的内存分配"></a>2. 栈与堆的内存分配</h2><p>我们的程序中，内存是用来存储运行程序所需的数据的，不管是从局部变量还是从文件中读取的东西。而栈和堆就是我们可以存储数据的地方。 它们的工作原理非常不同，但本质上做的事情是一样的：我们可以要求 C++从栈或者堆中给我们一些内存，顺利的话它会给我们一个要求大小的内存块。而不同之处在于，它会<strong>如何分配内存</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vector3</span><br>&#123;<br>	<span class="hljs-type">float</span> x, y, z;<br><br>	<span class="hljs-built_in">Vector3</span>()<br>		:<span class="hljs-built_in">x</span>(<span class="hljs-number">10.0f</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">11.0f</span>), <span class="hljs-built_in">z</span>(<span class="hljs-number">12.0f</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> value = <span class="hljs-number">5</span>;<br>	<span class="hljs-type">int</span> array[<span class="hljs-number">5</span>];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>	&#123;<br>		array[i] = i;<br>	&#125;<br>	Vector3 vector;<br><br>	<span class="hljs-type">int</span>* hvalue = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>	*hvalue = <span class="hljs-number">5</span>;<br>	<span class="hljs-type">int</span>* harray = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>	&#123;<br>		harray[i] = i;<br>	&#125;<br>	Vector3* hvector = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Vector3</span>();<br><br>	<span class="hljs-keyword">delete</span> hvalue;<br>	<span class="hljs-keyword">delete</span>[] harray;<br>	<span class="hljs-keyword">delete</span> hvector;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="栈分配"><a href="#栈分配" class="headerlink" title="栈分配"></a>栈分配</h3><p>因为 debug 模式下在变量周围添加了<em>safety guards</em>，以确保我们不会溢出所有变量，在错误的内存中访问它们等问题。所以在内存中这些变量的<strong>存储位置都很接近</strong>，因为实际发生的是：<strong>当我们在栈中分配变量时，栈顶部的指针就移动这个变量大小的字节。分配一个 4 个字节的整数，栈顶指针就移动 4 个字节。内存实际上是像栈一样相互叠加存储的，现在在大多数栈的实现中，栈是倒着来的。</strong>这就是为什么你看图中会发现：第一个 int value 存储在更高的内存地址，后续的 array 和 vector 在旁边存储在较低的内存地址，因为它是反向生长的。</p>
<p>栈的做法就是把东西叠在一起，这就是为什么<em>stack allocation</em>（栈分配）非常快，它就像一条 CPU 指令，我们所做的就是移动栈指针，然后返回栈指针的地址。我如果要分配一个整数，我要反向移动栈指针 4 个字节，然后返回那个内存地址，因为这是 4 个字节块的开始。</p>
<p>栈中分配内存时，一旦这个作用域结束，你在栈中分配的所有内存都会被弹出，内存被释放。</p>
<h3 id="堆分配"><a href="#堆分配" class="headerlink" title="堆分配"></a>堆分配</h3><p>堆分配的内存不会紧挨着，在堆中分配<code>new</code>后要调用<code>delete</code>关键字来释放内存，用[智能指针](<a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/51-100/54">https://nagi.fun/Cherno-CPP-Notes/51-100/54</a> Stack vs Heap Memory in C%2B%2B&#x2F;44 SMART POINTERS in C++.md)的<code>make</code>也一样会帮你调用关键字，所以我们需要手动去释放内存。</p>
<h2 id="3-new关键字实际上做了什么？"><a href="#3-new关键字实际上做了什么？" class="headerlink" title="3. new关键字实际上做了什么？"></a>3. new关键字实际上做了什么？</h2><p><code>new</code>关键字实际上调用了一个叫做<code>malloc</code>的函数（memory allocate）的缩写，这样做通常会调用底层操作系统或平台的特定函数，这将在堆上为你分配内存。当你启动应用时，你会被分配到一定数量的物理 RAM，而你的程序会维护一个叫<em>free list</em>（空闲列表）的东西，它的作用是跟踪哪些内存块是空闲的并储存它们的位置。当你使用<code>malloc</code>请求堆内存时，它可以浏览空闲列表，找到一块符合大小要求的内存块，然后返回你一个它的指针，并记录分配的大小和它现在是否被分配的情况（这样你就不能使用这块内存了）。</p>
<p>这里想说的重点是，在堆上分配内存是一大坨事情，而在栈上分配内存就像一条 CPU 指令。这两种主要内存的区别就是分配方式的区别，可以从汇编指令中看到，声明变量时栈分配的指令就一两行，而堆分配就是一大段指令了，之后还要调用<code>delete</code>，这又是大段指令。</p>
<p>所以事实上，如果可能的话你应该<strong>尽量在栈上分配内存</strong>。在堆上分配的唯一原因是如果你不能在栈上分配，比如你需要让它的声明周期比你在处理的作用域更长，或者你特别需要更多的数据，比如我想加载一个 50MB 的纹理材质，这就不适合在栈上分配，因此你不得不在堆上分配。</p>
<p>性能的不同是因为分配方式，所以理论上如果你在运行你的程序前在堆上预先分配一个内存块，然后从这个预先分配的内存块中进行堆分配，那栈、堆分配就基本一样了，你唯一可能要处理的就是<em>cpu cache miss</em>的问题（缓存不命中），但 miss 的数量可能不够造成麻烦。所以当你调用<code>new</code>时，你需要检查 free list，请求内存再记录所有内容，这就是堆相比于栈慢的地方，而实际的访问（CPU、缓存）通常可以忽略不计</p>
<h1 id="55-Macros-in-C"><a href="#55-Macros-in-C" class="headerlink" title="55. Macros in C++"></a>55. Macros in C++</h1><ul>
<li>预处理</li>
</ul>
<p>带有<code>#</code>的为<em>preprocessor statement</em>，即预处理指令。 该类指令发生在真正的编译之前，当编译器收到一个源文件时，做的第一件事情就是预处理所有预处理指令。</p>
<p>预处理阶段基本上是一个文本编辑阶段，在这个阶段我们可以控制给编译器什么代码，这就是<em>macro</em>（宏）的用武之地了。 我们能做的就是写一些宏，它将代码中的文本替换为其它东西，这基本就像遍历我们的代码然后执行查找和替换。 （所以模板会比宏评估得更晚一些)</p>
<p>你使用宏的方式取决于你的个人爱好，如果你用了很多宏，代码可能会比较难理解。不要用太多的 C++特性，尤其是当我们进入更高级的特性时，你不需要向所有人炫耀你知道所有的 C++特性，用更多的特性也不是写好代码的方式。</p>
<ul>
<li>“宏”举例</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WAIT std::cin.get()</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	WAIT;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="1-使用宏区分Debug和Release"><a href="#1-使用宏区分Debug和Release" class="headerlink" title="1. 使用宏区分Debug和Release"></a>1. 使用宏区分Debug和Release</h2><p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20240107130814058.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="image-20240107130814058"></p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20240107130718965.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="image-20240107130718965"></p>
<p><img src="https://murhyimgur.oss-cn-beijing.aliyuncs.com/img/image-20240107130735354.png" srcset="https://murhyimgur.oss-cn-beijing.aliyuncs.com/website/loading.gif" lazyload alt="image-20240107130735354"></p>
<h2 id="2-多行宏定义"><a href="#2-多行宏定义" class="headerlink" title="2. 多行宏定义"></a>2. 多行宏定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAIN int mian()\</span><br><span class="hljs-meta">&#123;\</span><br><span class="hljs-meta">	std::cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; std::endl;\</span><br><span class="hljs-meta">	std::cin.get();\</span><br><span class="hljs-meta">&#125;</span><br><br>MAIN<br></code></pre></td></tr></table></figure>

<h1 id="56-The-AUTO-keyword-in-C"><a href="#56-The-AUTO-keyword-in-C" class="headerlink" title="56. The AUTO keyword in C++"></a>56. The AUTO keyword in C++</h1><p>有一种方法可以让 C++自动推导出数据的类型，不管是在创建、初始化变量数据时，还是在将一个变量对另一个变量进行赋值时。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">auto</span> b = a;<br><br>std::string name1 = <span class="hljs-string">&quot;Cherno&quot;</span>;<br><span class="hljs-keyword">auto</span> name2 = name1;<br><br><span class="hljs-function">std::string <span class="hljs-title">GetName</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cherno&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">auto</span> name = <span class="hljs-built_in">GetName</span>();<br></code></pre></td></tr></table></figure>

<p>这样如果<em>api</em>发生改变时，比如 GetName 的返回类型改为了<code>char*</code>，客户端不需要任何改动。但是坏处是我也不知道 api 已经改变了，它可能会破坏依赖于特定类型的代码。</p>
<h2 id="什么时候适合用-auto？"><a href="#什么时候适合用-auto？" class="headerlink" title="什么时候适合用 auto？"></a>什么时候适合用 auto？</h2><ul>
<li>迭代器</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::vector &lt;std::string&gt; strings;<br>	strings.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Apple&quot;</span>);<br>	strings.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Orange&quot;</span>);<br><br>	<span class="hljs-comment">// for (std::vector&lt;std::string&gt;::iterator it = strings.begin(); it != strings.end(); it++)</span><br>    <span class="hljs-comment">// 代码中iterator（迭代器）的类型太长了，可以直接用auto替换以获得更好的可读性：</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = strings.<span class="hljs-built_in">begin</span>(); it != strings.<span class="hljs-built_in">end</span>(); it++)     <br>	&#123;<br>		std::cout &lt;&lt; *it &lt;&lt; std::endl;<br>	&#125;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>类型相当大</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Device</span> &#123;&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeviceManager</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>	std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt; m_Devices;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">const</span> std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt;&amp; <span class="hljs-built_in">GetDevice</span>() <span class="hljs-type">const</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> m_Devices;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	DeviceManager dm;<br><br>	<span class="hljs-comment">// const std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt;&amp; devices = dm.GetDevice();</span><br>    <br>    <span class="hljs-comment">// 使用alias</span><br>    <span class="hljs-keyword">using</span> DeviceMap = std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt;;<br>    <span class="hljs-keyword">typedef</span> std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt; DeviceMap;<br>    <span class="hljs-type">const</span> DeviceMap&amp; devices = dm.<span class="hljs-built_in">GetDevice</span>();<br>    <br>    <span class="hljs-comment">// 使用auto</span><br>	<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; devices = dm.<span class="hljs-built_in">GetDevice</span>();<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="57-Static-Array-in-C-std-array"><a href="#57-Static-Array-in-C-std-array" class="headerlink" title="57.  Static Array in C++(std::array)"></a>57.  Static Array in C++(std::array)</h1><h2 id="1-静态数组"><a href="#1-静态数组" class="headerlink" title="1. 静态数组"></a>1. 静态数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><br><span class="hljs-comment">// 用模板传入std::array的size，避免显式调用</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintArray</span><span class="hljs-params">(std::array&lt;<span class="hljs-type">int</span>, T&gt;&amp; array)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; T; i++)<br>    &#123;<br>        std::cout &lt;&lt; array[i] &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::array&lt;<span class="hljs-type">int</span>, 5&gt; data;<br><br>    <span class="hljs-keyword">for</span> (std::array&lt;<span class="hljs-type">int</span>, data.<span class="hljs-built_in">size</span>()&gt;::iterator it = data.<span class="hljs-built_in">begin</span>(); it != data.<span class="hljs-built_in">end</span>(); it++)<br>    &#123;<br>        *it = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">PrintArray</span>(data);<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="2-静态数组和普通数组异同"><a href="#2-静态数组和普通数组异同" class="headerlink" title="2. 静态数组和普通数组异同"></a>2. 静态数组和普通数组异同</h2><p><code>std::array</code>和普通数组在内存上形式是一样的，都在栈上分配，不像<code>std::vector</code>类是在堆上分配的。</p>
<p>但是<code>std::array</code>有边界检查（仅在 Debug 模式下），在最优化的情况下和普通数组性能是一样的。</p>
<p><code>std::array</code>实际上不存储自己的 size，size 是你给它的一个模板参数，这意味着调用 size function 直接返回 5 而不是返回一个存储在内存中的 size 变量</p>
<p>可以看到边界检查是在一个宏中的，这意味着只有在那个调试级别才会发生，如果等级为 0 则返回跟 C 语言数组工作方式一样的。</p>
<p>你应该开始选择使用<code>std::array</code>而不是 C 语言风格数组，因为它增加了一层调试（在你期望对代码保护时），而且也没有性能成本，还可以让你记录数组的大小。</p>
<h1 id="58-Function-Pointers-in-C"><a href="#58-Function-Pointers-in-C" class="headerlink" title="58. Function Pointers in C++"></a>58. Function Pointers in C++</h1><p>把函数传给变量；将函数作为参数传递给其他函数</p>
<ul>
<li>函数指针举例1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HelloWorld</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;Hello world&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">auto</span> fun1 = HelloWorld;<br>	<span class="hljs-built_in">fun1</span>();<br><br>	<span class="hljs-built_in">void</span>(*fun2)() = HelloWorld;<br>	<span class="hljs-built_in">fun2</span>();<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>函数指针举例2</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ForEach</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; values, <span class="hljs-type">void</span>(*func)(<span class="hljs-type">int</span>))</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : values)<br>		<span class="hljs-built_in">func</span>(value);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::vector&lt;<span class="hljs-type">int</span>&gt; values = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>,<span class="hljs-number">3</span> &#125;;<br>	<span class="hljs-built_in">ForEach</span>(values, PrintValue);  <span class="hljs-comment">// 函数指针作为函数的参数</span><br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ForEach</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; values, <span class="hljs-type">void</span>(*func)(<span class="hljs-type">int</span>))</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : values)<br>		<span class="hljs-built_in">func</span>(value);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::vector&lt;<span class="hljs-type">int</span>&gt; values = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>,<span class="hljs-number">3</span> &#125;;<br>	<span class="hljs-built_in">ForEach</span>(values, [](<span class="hljs-type">int</span> value) &#123;std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl; &#125;); <span class="hljs-comment">// lambda匿名函数</span><br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的<code>[]</code>叫做<em>capture method</em>（捕获方式），也就是如何传入传出参数，后面会介绍更多。</p>
<h1 id="59-lambda-in-C"><a href="#59-lambda-in-C" class="headerlink" title="59. lambda in C++"></a>59. lambda in C++</h1><p><em>lambda</em>本质上是我们定义一种叫做匿名函数的方式，用这种方法不需要实际创建一个函数，就像是一个快速的一次性函数，我们更想将它视作一个变量而不是像一个正式的函数那样，在我们编译的代码中作为一个符号存在。</p>
<p>只要你有一个<strong>函数指针</strong>，你都可以在C++中使用lambda，这就是它的工作原理，所以lambda是我们不需要通过函数定义就可以定义一个函数的方法。 <strong>lambda的用法是，在我们会设置函数指针指向函数的任何地方，我们都可以将它设置为lambda。</strong></p>
<p>lambda是一个指定一个函数未来想要运行的代码的很好的方法。</p>
<h2 id="1-capture"><a href="#1-capture" class="headerlink" title="1. capture"></a>1. capture</h2><p>如果我们想把外部变量放到lambda函数内部的指令中呢？ 和我们创建自己的函数其实一样，都是有两个方法：<strong>值传递和引用传递</strong>，这也就是捕获这一块的东西，<code>[]</code>就是我们打算如何传递变量。（<code>[=]</code>,传递所有变量，通过值传递；<code>[&amp;]</code>传递所有变量，通过引用传递） 还可以只传入单独的变量，<code>[a]</code>通过值传递传入a,<code>[&amp;a]</code>通过引用传递。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ForEach</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; values, <span class="hljs-type">const</span> std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt;&amp; func)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : values)<br>		<span class="hljs-built_in">func</span>(value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::vector&lt;<span class="hljs-type">int</span>&gt; values = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span> &#125;;<br>	<span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">find_if</span>(values.<span class="hljs-built_in">begin</span>(), values.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> value) &#123;<span class="hljs-keyword">return</span> value &gt; <span class="hljs-number">2</span>; &#125;);<br>	std::cout &lt;&lt; *it &lt;&lt; std::endl;<br><br>	<span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><br>	<span class="hljs-keyword">auto</span> lambda = [=](<span class="hljs-type">int</span> value) &#123;std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl; &#125;;<br><br>	<span class="hljs-built_in">ForEach</span>(values, lambda);<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="60-Why-I-don’t-use-“using-namespace-std”"><a href="#60-Why-I-don’t-use-“using-namespace-std”" class="headerlink" title="60. Why I don’t use “using namespace std”"></a>60. Why I don’t use “using namespace std”</h1><h2 id="1-什么是-using-namespace"><a href="#1-什么是-using-namespace" class="headerlink" title="1. 什么是 using namespace?"></a>1. 什么是 using namespace?</h2><p>就像上文中的代码用了很多标准库的内容，如果在代码前面加上</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure>

<p>就可以直接写 vector，find_if 了，看上去代码更干净一点。 还可以把它限制在作用域中，比如写到 main 函数的第一行，这样 main 函数中调用标准库就不用写”std::“了。</p>
<p>所以<code>using namespace</code>可以非常有用，如果你在处理很长的命名空间，或是你有自己的命名空间，自己的项目文件中的符号都在这个命名空间中，你可以使用这个。</p>
<p>但是<strong>我个人</strong>不喜欢<code>using namespace std</code></p>
<h2 id="2-为什么不喜欢"><a href="#2-为什么不喜欢" class="headerlink" title="2. 为什么不喜欢"></a>2. 为什么不喜欢</h2><p>第一眼看上去代码是干净了，但是如果看原始代码，可以发现你很容易就能指出代码中使用的是 C++标准模板库（带有 std 前缀的）。如果用了<code>using namespace std</code>，就相对而言有点难分辨了。如果你也用标准库喜欢用的<em>snake case</em>（蛇形命名法，如 find_if），就很难区分到底是不是 std 中的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> apple &#123;<br>    <br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; text)</span></span><br><span class="hljs-function">	</span>&#123;<br>		std::cout &lt;&lt; text &lt;&lt; std::endl;<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> orange &#123;<br>    <br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* text)</span></span><br><span class="hljs-function">	</span>&#123;<br>		std::string temp = text;<br>		std::<span class="hljs-built_in">reverse</span>(temp.<span class="hljs-built_in">begin</span>(), temp.<span class="hljs-built_in">end</span>());<br>		std::cout &lt;&lt; temp &lt;&lt; std::endl;<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> apple;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> orange;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">olleH</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>这并不是 orange 在 apple 后导致的，而是因为其它原因。“Hello”其实是一个 const char[]数组，而不是一个 string，如果只有 apple 命名空间，会在 apple::print()中做一个[隐式转换](<a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/51-100/60">https://nagi.fun/Cherno-CPP-Notes/51-100/60</a> Why I don’t using namespace std&#x2F;40 Implicit Conversion and the Explicit Keyword in C++.md#^cde452)，将 const char 数组转换为 string 对象。但是引入 orange 命名空间后，orange::print()匹配度更高，因为它的参数本来就是一个 const char*，不需要隐式转换。</p>
<p>如果我们不用<code>using namespace</code>，而是简单地引入另一个库<code>apple::print()</code>就不会有这样的运行时错误。</p>
<p>另一个要<strong>百分百避免的就是在头文件中使用 using namespace</strong>，永远不要这样做，把这些命名空间用在了你原本没有打算用的地方，谁知道它会 include 什么呢？任何大型项目中追踪起来都是很困难的，所以<strong>绝对不要在头文件中使用 using namespace！</strong></p>
<h1 id="61-Namespaces-in-C"><a href="#61-Namespaces-in-C" class="headerlink" title="61. Namespaces in C++"></a>61. Namespaces in C++</h1><p>[61 C++的名称空间 - cherno-cpp-notes (nagi.fun)](<a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/51-100/61">https://nagi.fun/Cherno-CPP-Notes/51-100/61</a> Namespaces in C%2B%2B&#x2F;)</p>
<h1 id="62-Threads-in-C"><a href="#62-Threads-in-C" class="headerlink" title="62. Threads in C++"></a>62. Threads in C++</h1><p>本节课讲的是<em>threads</em>（线程），也就是讲我们如何进行<em>parallelization</em>（并行化）。现在大多数计算机或处理器等设备都有不止一个逻辑处理线程，当我们进入更复杂的项目时，将某些工作移动到两个不同的执行线程会对我们非常有益。不仅仅是为了提高性能，也是我们还能用它做些什么事。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">bool</span> s_Finished = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoWork</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals::chrono_literals;<br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;Started thread id = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; std::endl;<br><br>	<span class="hljs-keyword">while</span> (!s_Finished)<br>	&#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;Working...\n&quot;</span>;<br>		std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">1</span>s);<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-function">std::thread <span class="hljs-title">worker</span><span class="hljs-params">(DoWork)</span></span>;<br>	<br>	std::cin.<span class="hljs-built_in">get</span>();<br>	s_Finished = <span class="hljs-literal">true</span>;<br><br>	worker.<span class="hljs-built_in">join</span>();<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;Finished.&quot;</span> &lt;&lt; std::endl;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;Started thread id = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; std::endl;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这就是一个简单的 C++多线程例子。代码的主要工作流程如下：</p>
<ol>
<li>全局的<code>s_Finish</code>标记声明为<code>static</code>，以限制其在当前源文件中的作用范围。</li>
<li><code>DoWork</code>函数是一个线程例程。它进入一个无限循环，每秒打印一次”Working…”，直到<code>s_Finish</code>标志被设置为<code>true</code>。</li>
<li>在<code>main</code>函数中，创建了一个名为<code>worker</code>的新线程。<code>DoWork</code>函数被作为参数传递给线程的构造函数，表示应在新创建的线程中运行此函数。</li>
<li><code>std::cin.get();</code>语句是一个阻塞调用，它等待用户按回车键。</li>
<li>一旦按下回车键，<code>s_Finish</code>标志被设置为<code>true</code>，这导致<code>DoWork</code>函数跳出其循环并返回。</li>
<li><code>worker.join();</code>语句用于等待线程完成其执行，然后程序才能继续。确保线程在主线程（在这种情况下，是程序）结束之前完成执行是至关重要的。如果程序在<code>worker</code>线程仍在运行时结束，那么它将被突然终止，这可能导致各种问题，如资源未被正确释放。</li>
</ol>
<p>线程很重要，它们对于加速程序非常有用，主要目的是优化，还可以做例如上面例子中这些事情。</p>
<h1 id="63-Timing-in-C"><a href="#63-Timing-in-C" class="headerlink" title="63. Timing in C++"></a>63. Timing in C++</h1><p>我们如何计算完成某个操作或者执行某个代码所需要的时间呢？</p>
<p>计时对很多事情都很有用，不论你是希望某些事情在特定时间发生，还是只是评估性能或做基准测试，看你的代码运行得有多快，你需要知道应用程序实际运行的时间。</p>
<p>有几种方法可以实现这一点，C++11 之后我们有了“chrono”，它是 C++库的一部分，不需要去使用操作系统库。但在有 chrono 之前，如果你想要高分辨率的时间，你想要一个非常精确的计时器，那你就需要用到操作系统库了。例如在 Windows 中有一个叫做“QueryPerformanceCounter”的东西，我们仍然可以使用那些东西。事实上如果你想要更多地控制即使，控制 CPU 的计时能力，那么你可能会使用平台特定的库。不过本节只会看一看和平台无关的 C++标准库方法（chrono 库的一部分），它可以计算出执行代码时，代码之间经过了多长时间。</p>
<h2 id="1-计时1s"><a href="#1-计时1s" class="headerlink" title="1. 计时1s"></a>1. 计时1s</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals::chrono_literals;<br><br>    <span class="hljs-keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">1</span>s);<br>    <span class="hljs-keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br><br>    std::chrono::duration&lt;<span class="hljs-type">float</span>&gt; duration = end - start;<br>    std::cout &lt;&lt; duration.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot;s &quot;</span> &lt;&lt; std::endl;<br><br>    std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>chrono 库非常好，可以高精度计时，几乎适用于所有平台，所以非常建议使用这个方法来满足你所有的计时需求，除非你在做一些特定的底层的事情。</p>
<h2 id="2-计算时间"><a href="#2-计算时间" class="headerlink" title="2. 计算时间"></a>2. 计算时间</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Timer</span><br>&#123;<br>	std::chrono::time_point&lt;std::chrono::steady_clock&gt; start, end;<br>	std::chrono::duration&lt;<span class="hljs-type">float</span>&gt; duration;<br><br>	<span class="hljs-built_in">Timer</span>()<br>	&#123;<br>		start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>	&#125;<br><br>	~<span class="hljs-built_in">Timer</span>()<br>	&#123;<br>		end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br><br>		duration = end - start;<br><br>		<span class="hljs-type">float</span> ms = duration.<span class="hljs-built_in">count</span>() * <span class="hljs-number">1000.0f</span>;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;Timer took &quot;</span> &lt;&lt; ms &lt;&lt; <span class="hljs-string">&quot;ms&quot;</span> &lt;&lt; std::endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Function</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Timer timer;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>        <span class="hljs-comment">// std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl;</span><br>		std::cout &lt;&lt; <span class="hljs-string">&quot;Hello\n&quot;</span>; <span class="hljs-comment">// 可以将 endl 换为“\n”优化性能。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">Function</span>();<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>





<h1 id="64-Multidimensional-Arrays-in-C-2D-arrays"><a href="#64-Multidimensional-Arrays-in-C-2D-arrays" class="headerlink" title="64. Multidimensional Arrays in C++(2D arrays)"></a>64. Multidimensional Arrays in C++(2D arrays)</h1><p>从二维数组开始作为一个例子，实际上它只是<strong>数组的数组</strong>（三维数组就是数组的数组的数组…..），就是数组的集合。 我们考虑处理数组的一种策略就是使用<strong>指针</strong>，我们有一个指针，指向数组在内存中的开头位置。可以想象一下有一个指针的数组，最终你会得到一个内存块，里面包含的是连续的指针，每个指针都指向内存中的某个数组，所以得到的是指向数组的指针的集合，也就是数组的数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 1-d array</span><br>	<span class="hljs-type">int</span>* array = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">50</span>];<br><br>	<span class="hljs-keyword">delete</span>[] array;<br><br><br>	<span class="hljs-comment">// 2-d array (50*10)</span><br>	<span class="hljs-type">int</span>** a2d = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>* [<span class="hljs-number">50</span>];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++)<br>		a2d[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++)<br>		<span class="hljs-keyword">delete</span>[] a2d[i];<br>	<span class="hljs-keyword">delete</span>[] a2d;<br><br>	<span class="hljs-comment">// 3-d array (50*10*3)</span><br>	<span class="hljs-type">int</span>*** a3d = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>** [<span class="hljs-number">50</span>];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++)<br>	&#123;<br>		a3d[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>* [<span class="hljs-number">10</span>];<br><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>		&#123;<br>			a3d[i][j] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">3</span>];<br>		&#125;<br>	&#125;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里只是分配了一个可以存储200字节指针的内存块，并没有初始化。 然后我们可以遍历并设置每个指针指向一个数组，这样就能得到一个包含50个数组的内存位置的数组</p>
<h1 id="65-Sorting-in-C"><a href="#65-Sorting-in-C" class="headerlink" title="65. Sorting in C++"></a>65. Sorting in C++</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::vector&lt;<span class="hljs-type">int</span>&gt; values = &#123; <span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span> &#125;;<br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;first&quot;</span> &lt;&lt; std::endl;<br>	std::<span class="hljs-built_in">sort</span>(values.<span class="hljs-built_in">begin</span>(), values.<span class="hljs-built_in">end</span>());<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : values)<br>		std::cout &lt;&lt; value &lt;&lt; std::endl;<br>	<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;second&quot;</span> &lt;&lt; std::endl;<br>	std::<span class="hljs-built_in">sort</span>(values.<span class="hljs-built_in">begin</span>(), values.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : values)<br>		std::cout &lt;&lt; value &lt;&lt; std::endl;<br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;third&quot;</span> &lt;&lt; std::endl;<br>	std::<span class="hljs-built_in">sort</span>(values.<span class="hljs-built_in">begin</span>(), values.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>		&#123;<br>			<span class="hljs-keyword">return</span> a &gt; b;<br>		&#125;);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : values)<br>		std::cout &lt;&lt; value &lt;&lt; std::endl;<br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;forth&quot;</span> &lt;&lt; std::endl;<br>	std::<span class="hljs-built_in">sort</span>(values.<span class="hljs-built_in">begin</span>(), values.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>		&#123;<br>			<span class="hljs-keyword">if</span> (a == <span class="hljs-number">1</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br>			<span class="hljs-keyword">if</span> (b == <span class="hljs-number">1</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br><br>			<span class="hljs-keyword">return</span> a &lt; b;<br>		&#125;);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : values)<br>		std::cout &lt;&lt; value &lt;&lt; std::endl;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="66-Type-Punning-in-C"><a href="#66-Type-Punning-in-C" class="headerlink" title="66. Type Punning in C++"></a>66. Type Punning in C++</h1><p><em>Type punning</em>（类型双关）只是一个花哨的术语，<strong>用来在 C++中绕过类型系统</strong>。<strong>C++是强类型语言</strong>，也就是说它有一个类型系统，不像 JavaScript 那样创建变量不需要声明变量类型，但 C++中你创建变量时必须声明整数、双精度数、结构体等等类型。然而这种类型系统并不像 Java 中那么“强制”，C++中虽然类型是由编译器强制执行的，但你可以直接访问内存，所以<strong>可以很容易地绕过类型系统</strong>，你是否要这么做取决于你的实际需求。在某些情况下，你绝对不应该规避类型系统，因为类型系统存在是有原因的，除非你有充分的理由，否则你不会想过多地使用它。</p>
<ul>
<li>隐式类型转换</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">50</span>; <span class="hljs-comment">// a:32 00 00 00 (十六进制)</span><br>	<span class="hljs-type">double</span> value = a; <span class="hljs-comment">// value:00 00 00 00 00 00 49 40 (十六进制)  //隐式类型转换</span><br><br>	std::cout &lt;&lt; value &lt;&lt; std::endl;  <span class="hljs-comment">// 50</span><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>显式类型转换(与上面的隐式类型转换其实是一样的)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">50</span>; <span class="hljs-comment">// a:32 00 00 00</span><br>	<span class="hljs-type">double</span> value = (<span class="hljs-type">double</span>)a; <span class="hljs-comment">// value:00 00 00 00 00 00 49 40  //隐式类型转换</span><br><br>	std::cout &lt;&lt; value &lt;&lt; std::endl;  <span class="hljs-comment">// 50</span><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>取a的地址，转换为double类型的指针再解引用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">50</span>; <span class="hljs-comment">// a:32 00 00 00</span><br>	<span class="hljs-type">double</span> value = *(<span class="hljs-type">double</span>*)&amp;a; <span class="hljs-comment">// value:32 00 00 00 cc cc cc cc</span><br><br>	std::cout &lt;&lt; value &lt;&lt; std::endl; <span class="hljs-comment">// -9.25596e+61</span><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>struct</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Entity</span><br>&#123;<br>	<span class="hljs-type">int</span> x, y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Entity e = &#123; <span class="hljs-number">5</span>,<span class="hljs-number">8</span> &#125;;<br><br>	<span class="hljs-type">int</span>* position = (<span class="hljs-type">int</span>*)&amp;e;<br>	std::cout &lt;&lt; position[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; position[<span class="hljs-number">1</span>] &lt;&lt; std::endl; <span class="hljs-comment">// 5, 8</span><br><br>	<span class="hljs-type">int</span> y = *(<span class="hljs-type">int</span>*)((<span class="hljs-type">char</span>*)&amp;e + <span class="hljs-number">4</span>);<br>	std::cout &lt;&lt; y &lt;&lt; std::endl; <span class="hljs-comment">// 8</span><br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="67-Unions-in-C"><a href="#67-Unions-in-C" class="headerlink" title="67. Unions in C++"></a>67. Unions in C++</h1><p><em>Union</em> （联合体）有点像 class 类型或者 struct 类型，只不过它一次只能占用一个成员的内存。 通常如果我们有一个结构体，我们在里面声明 4 个浮点数，就可以有 4x4 个字节在这个结构体中，总共是 16 个字节。 但一个联合体只能有一个成员，所以如果我要声明 4 个浮点数，比如 abcd，联合体的大小仍然是 4 个字节，当我尝试去处理它们，比如将 a 设为 5，它们的内存是一样的，d 的值也会是 5，这就是联合体的工作方式。</p>
<p>你可以像使用结构体或类一样使用它们，也可以给它添加静态函数或者普通函数、方法等。然而你不能使用虚方法，还有一些其它限制，但通常人们用联合体来做的事，是和[类型双关](<a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/51-100/66">https://nagi.fun/Cherno-CPP-Notes/51-100/66</a> Type Punning in C%2B%2B&#x2F;)紧密相关的。当你想给同一个变量取两个不同的名字时，它真的很好用。</p>
<p>通常<code>union</code>是匿名使用的，但匿名 union 不能含有成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Union</span><br>	&#123;<br>		<span class="hljs-keyword">union</span><br>		&#123;<br>			<span class="hljs-type">float</span> a;<br>			<span class="hljs-type">int</span> b;<br>		&#125;;<br>	&#125;;<br><br>	Union u;<br>	u.a = <span class="hljs-number">2.0f</span>;<br><br>	std::cout &lt;&lt; u.a &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; u.b &lt;&lt; std::endl; <span class="hljs-comment">// 2, 1073741824</span><br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vector2</span><br>&#123;<br>	<span class="hljs-type">float</span> x, y;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vector4</span><br>&#123;<br>	<span class="hljs-keyword">union</span><br>	&#123;<br>		<span class="hljs-keyword">struct</span><br>		&#123;<br>			<span class="hljs-type">float</span> x, y, z, w;<br>		&#125;;<br>		<span class="hljs-keyword">struct</span><br>		&#123;<br>			Vector2 a, b;<br>		&#125;;<br>	&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintVector2</span><span class="hljs-params">(<span class="hljs-type">const</span> Vector2&amp; vector)</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; vector.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; vector.y &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Vector4 vector = &#123; <span class="hljs-number">1.0f</span>,<span class="hljs-number">2.0f</span>,<span class="hljs-number">3.0f</span>,<span class="hljs-number">4.0f</span> &#125;;<br>	<span class="hljs-built_in">PrintVector2</span>(vector.a);<br>	<span class="hljs-built_in">PrintVector2</span>(vector.b);<br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;====================&quot;</span> &lt;&lt; std::endl;<br>	vector.z = <span class="hljs-number">500.0f</span>;<br>	<span class="hljs-built_in">PrintVector2</span>(vector.a);<br>	<span class="hljs-built_in">PrintVector2</span>(vector.b);<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1, 2</span><br><span class="hljs-comment">3, 4</span><br><span class="hljs-comment">====================</span><br><span class="hljs-comment">1, 2</span><br><span class="hljs-comment">500, 4</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<h1 id="68-Virtual-Destructors-in-C"><a href="#68-Virtual-Destructors-in-C" class="headerlink" title="68. Virtual Destructors in C++"></a>68. Virtual Destructors in C++</h1><p>虚析构函数可以想象为虚函数和析构函数的组合。 </p>
<p><strong>虚析构函数对于处理多态非常重要</strong>，换句话说，如果我有一系列的子类和所有的继承：有一个类 A，然后一个类 B 派生于 A，你想把类 B 引用为类 A，但它实际上是类 B，然后你决定删除 A 或者它以某种方式删除了，然后你还是希望运行 B 的析构函数，而不是运行 A 的析构函数，这就是所谓的虚析构函数以及它的作用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base Constructor\n&quot;</span>; &#125;<br>	~<span class="hljs-built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base Destructor\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> :<span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Derived Constructor\n&quot;</span>; &#125;<br>	~<span class="hljs-built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Derived Destructor\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;-----First:Base&quot;</span> &lt;&lt; std::endl;<br>	Base* base = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Base</span>();<br>	<span class="hljs-keyword">delete</span> base;<br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;-----Second:Derived Inherited from Base&quot;</span> &lt;&lt; std::endl;<br>	Derived* derived = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>	<span class="hljs-keyword">delete</span> derived;<br>	<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;-----Third:Polymorphic&quot;</span> &lt;&lt; std::endl;<br>	Base* poly = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>	<span class="hljs-keyword">delete</span> poly;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">-----First:Base</span><br><span class="hljs-comment">Base Constructor</span><br><span class="hljs-comment">Base Destructor</span><br><span class="hljs-comment">-----Second:Derived Inherited from Base</span><br><span class="hljs-comment">Base Constructor</span><br><span class="hljs-comment">Derived Constructor</span><br><span class="hljs-comment">Derived Destructor</span><br><span class="hljs-comment">Base Destructor</span><br><span class="hljs-comment">-----Third:Polymorphic</span><br><span class="hljs-comment">Base Constructor</span><br><span class="hljs-comment">Derived Constructor</span><br><span class="hljs-comment">Base Destructor</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>在第三种情况下，Derived只调用了构造函数，没有调用析构函数，这是有可能会造成内存泄露了！！</p>
<p>这里只有基类的析构函数被调用了，而派生类的析构函数没有被调用。 这点很重要，因为这会造成内存泄漏。 <code>delete</code> poly 时，它不知道这个调用的析构函数可能有另一个析构函数，因为它（~Base）没有被标记为虚函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base Constructor\n&quot;</span>; &#125;<br>	<span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base Destructor\n&quot;</span>; &#125; <span class="hljs-comment">// 标价为virtual</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> :<span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span>* m_Array;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Derived</span>() &#123; m_Array = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>]; std::cout &lt;&lt; <span class="hljs-string">&quot;Derived Constructor\n&quot;</span>; &#125; <span class="hljs-comment">// 只调用构造函数，不调用析构函数的话，就会导致内存泄露</span><br>	~<span class="hljs-built_in">Derived</span>() &#123; <span class="hljs-keyword">delete</span>[] m_Array; std::cout &lt;&lt; <span class="hljs-string">&quot;Derived Destructor\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;-----First:Base&quot;</span> &lt;&lt; std::endl;<br>	Base* base = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Base</span>();<br>	<span class="hljs-keyword">delete</span> base;<br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;-----Second:Derived Inherited from Base&quot;</span> &lt;&lt; std::endl;<br>	Derived* derived = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>	<span class="hljs-keyword">delete</span> derived;<br>	<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;-----Third:Polymorphic&quot;</span> &lt;&lt; std::endl;<br>	Base* poly = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>	<span class="hljs-keyword">delete</span> poly;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">-----First:Base</span><br><span class="hljs-comment">Base Constructor</span><br><span class="hljs-comment">Base Destructor</span><br><span class="hljs-comment">-----Second:Derived Inherited from Base</span><br><span class="hljs-comment">Base Constructor</span><br><span class="hljs-comment">Derived Constructor</span><br><span class="hljs-comment">Derived Destructor</span><br><span class="hljs-comment">Base Destructor</span><br><span class="hljs-comment">-----Third:Polymorphic</span><br><span class="hljs-comment">Base Constructor</span><br><span class="hljs-comment">Derived Constructor</span><br><span class="hljs-comment">Derived Destructor</span><br><span class="hljs-comment">Base Destructor</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>标记为<em>virtual</em>，意味着 C++知道在层次结构下可能有某种重写的方法，这个方法就可以被覆写。 而<em>virtual destructor</em>（虚析构函数）的意思不是覆写析构函数，而是<strong>加上一个</strong>析构函数。换句话说如果我把积累的析构函数改为虚函数，它实际会先调用派生类析构函数，然后在层次结构中向上，调用基类析构函数。</p>
<h1 id="69-Casting-in-C"><a href="#69-Casting-in-C" class="headerlink" title="69. Casting in C++"></a>69. Casting in C++</h1><h2 id="1-什么是-casting"><a href="#1-什么是-casting" class="headerlink" title="1. 什么是 casting"></a>1. 什么是 casting</h2><p>这里的<em>casting</em>（转换）是指类型转换，或者说是必须在 C++可用类型系统中进行的类型转换。</p>
<p>C++是一门强类型语言，意味着存在一个类型系统，而且类型是强制的。（见[66 课：类型双关](<a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/51-100/66">https://nagi.fun/Cherno-CPP-Notes/51-100/66</a> Type Punning in C%2B%2B&#x2F;#^4d9dfe)） 如果我把某物设为 int，那就不能突然把它当做 double 或者 float，反过来也一样。我必须坚持原有的类型，除非有一个简单的<strong>隐式转换</strong>（[见 40 课：隐式和显式](<a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/51-100/69">https://nagi.fun/Cherno-CPP-Notes/51-100/69</a> Casting in C%2B%2B&#x2F;40 Implicit Conversion and the Explicit Keyword in C++.md#^cde452)），这意味着 C++知道如何在这两种类型之间转换，并且没有数据损失，这就是隐式转换；或者是有一个<strong>显示转换</strong>（[见 66 课：类型双关](<a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/51-100/66">https://nagi.fun/Cherno-CPP-Notes/51-100/66</a> Type Punning in C%2B%2B&#x2F;#^f3904d)），告诉 C++你需要把这个类型转换成目标类型，本章将正是介绍<strong>强制转换</strong>的含义，并了解如何使用它。</p>
<h2 id="2-casting"><a href="#2-casting" class="headerlink" title="2. casting"></a>2. casting</h2><h3 id="C-风格"><a href="#C-风格" class="headerlink" title="C 风格"></a>C 风格</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 隐式类型转换，很容易做到且没有数据丢失</span><br>	<span class="hljs-type">int</span> a1 = <span class="hljs-number">5</span>;<br>	<span class="hljs-type">double</span> b1 = a1;<br>	std::cout &lt;&lt; a1 &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; b1 &lt;&lt; std::endl;<br><br>	<span class="hljs-comment">// 隐式类型转换，因为不需要具体说明要把这个类型转换成哪个类型</span><br>	<span class="hljs-type">double</span> a2 = <span class="hljs-number">5.3</span>;<br>	<span class="hljs-type">int</span> b2 = a2;<br>	std::cout &lt;&lt; a2 &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; b2 &lt;&lt; std::endl;<br><br>	<span class="hljs-comment">// 显示类型转换</span><br>	<span class="hljs-type">double</span> a3 = <span class="hljs-number">5.3</span>;<br>	<span class="hljs-type">int</span> b3 = (<span class="hljs-type">int</span>)a3;<br>	std::cout &lt;&lt; a3 &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; b3 &lt;&lt; std::endl;<br><br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">5, 5</span><br><span class="hljs-comment">5.3, 5</span><br><span class="hljs-comment">5.3, 5</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<h3 id="C-风格-1"><a href="#C-风格-1" class="headerlink" title="C++ 风格"></a>C++ 风格</h3><p>C++风格的转换有多种，一个是<code>static_cast</code>，还有<code>reinterpret_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>，共这四种主要的 cast。它们并不能做任何 C 风格类型转换做不到的事情，这并不是添加新功能，只是添加了一些<em><strong>syntax sugar</strong></em>。</p>
<ul>
<li><p><code>dynamic_cast</code>，它会实际执行一个检查，如果转换不成功返回 NULL，所以这做了额外的事情，会降低运行速度。但在大多数情况下，C++风格类型转换并不做额外的事情，它们只是一些代码中的英文单词。 </p>
</li>
<li><p><code>static_cast</code>，意思是静态类型转换，在静态类型转换的情况下，还会做一些其它的编译时检查，检查这种转换是否可能。 </p>
</li>
<li><p><code>reinterpret_cast</code>也是一样，就像是把我们说过的<strong>类型双关</strong>用英语表达出来一样，意思就是我要把这段内存重新解释成其它东西.</p>
</li>
<li><p><code>const_cast</code>，移除或者添加变量的 const 限定。</p>
</li>
</ul>
<p>所以为什么要搞这么多 CAST ？因为除了可能收到上面说的那些编译时的检查外，还可以方便我们从代码库中搜索它们。如果我想看到我的类型转换都在哪儿，也许我有性能问题而不想用<code>dynamic_cast</code>，我可以直接搜索这个词，如果用的是 C 语言风格的 cast，就很难去搜索它，所以它对程序员的阅读和编写代码都有帮助。 而且它也能帮助我们减少在尝试强制转换时，可能意外犯下的错误，比如类型不兼容。</p>
<h1 id="70-Conditional-and-Action-Breakpoints-in-C"><a href="#70-Conditional-and-Action-Breakpoints-in-C" class="headerlink" title="70. Conditional and Action Breakpoints in C++"></a>70. Conditional and Action Breakpoints in C++</h1><p>[70 条件与操作断点 - cherno-cpp-notes (nagi.fun)](<a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/51-100/70">https://nagi.fun/Cherno-CPP-Notes/51-100/70</a> Conditional and Action Breakpoints in C%2B%2B&#x2F;)</p>
<p>本讲内容是一个简单的 VS 开发和调试的技巧，不过不仅仅是断点，而是关于条件与操作应用在断点上。</p>
<h2 id="1-条件断点-Condition"><a href="#1-条件断点-Condition" class="headerlink" title="1. 条件断点 Condition"></a>1. 条件断点 Condition</h2><p>通过条件或条件断点，我们可以告诉调试器想在这里放置一个断点，但我希望断点在特定条件下触发，比如内存中的某些东西满足了条件就触发这个断点。</p>
<h2 id="2-操作断点-Action"><a href="#2-操作断点-Action" class="headerlink" title="2. 操作断点 Action"></a>2. 操作断点 Action</h2><p>操作断点是允许我们采取某种动作，一般是在碰到断点时打印一些东西到控制台。</p>
<p>这里有两种类型的操作断点：</p>
<ul>
<li>一是让你在打印你想要的东西时继续执行，比如你想记录鼠标位置，每次鼠标移动，移动事件（打印鼠标位置）就会发生，可以让那个断点打印一些东西到控制台但保持程序运行；</li>
<li>二是打印一些东西，但仍然中断程序，暂停程序的执行，这样我们就可以检查内存中的其它东西。</li>
</ul>
<h1 id="71-Safety-in-modern-C-and-how-to-teach-it"><a href="#71-Safety-in-modern-C-and-how-to-teach-it" class="headerlink" title="71. Safety in modern C++ and how to teach it"></a>71. Safety in modern C++ and how to teach it</h1><p>本节将讨论C++中“安全”意味着什么。</p>
<p>安全编程，就是在编程中，我们希望降低崩溃、内存泄漏、非法访问等问题。 随着C++11的到来，Cherno想说的是应该转向智能指针这样的概念，而不是原始指针。这主要是因为存在内存泄漏以及不知道实际分配或者释放了哪些内存的问题。本节也重点围绕指针和内存，而不是异常或者是其它与安全编程有关的比如错误检查之类的东西。</p>
<p>当我们开始倾向于[智能指针](<a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/51-100/71">https://nagi.fun/Cherno-CPP-Notes/51-100/71</a> Safety in modern C%2B%2B and how to teach it&#x2F;44 SMART POINTERS in C++.md)之类的东西时，这一切都可以归结为我想要分配<strong>堆内存</strong>，智能指针和自动内存管理系统的存在使程序员的生活更容易，且更有力，这意味着你不再需要处理某些事情，就算忘记处理了它也会自动为你处理。</p>
<p>分配内存这件事很简单，你想在堆上分配一块内存，如果你分配成功会得到一个指向那块内存开始部分的有效的指针，它将一直存在，直到你明确地删除它，这就是整个基本概念了。</p>
<p>那问题就来自几方面了：</p>
<ul>
<li>如果我***忘记释放***我的内存会发生什么问题，可能是无害的甚至注意不到，也有内存耗尽灾难性地导致程序崩溃。而“细心一点、做一个好程序员”显然不是一个真正的解决方案，你还是需要考虑更复杂的结构来删除由你自己明确分配的内存。</li>
<li>还有<em>ownership</em>（所有权问题），即谁会拥有分配的内存呢？如果我有一个原始指针，指向那块内存，我把它从一个函数传递给另一个函数，从一个类传递给另一个类，谁会<strong>负责管理和清理这些内存</strong>就是***所有权问题***。你不确定A、B这两个管理那个原始指针的函数哪个最后结束，但是要保证两个函数都能访问那个指针，除非你指明这两个函数运行完后再执行一个清理步骤，但这显然会极大复杂化整个程序，也是我们绝对想避免的。我想要重新分配数据，但我不想要显式地建立一些东西，比如管理所有权或者转义所有权，which会使事情变得非常复杂，你将不得不手动跟踪它。这是另一种所有权问题。</li>
</ul>
<p>这两大问题就是我们需要自动删除内存的原因，当我们讨论C++的安全问题时，特别是智能指针时，我们只需要自动化一行简单的代码就搞定了内存删除与释放问题，所以你百分之百不应该拒绝使用智能指针，自己构建、修改智能指针也是正常的。</p>
<p>当然如果只是做一个一百来行的小型sandbox应用，可能用原始指针可读性更好，因为你不关心是否释放了内存，也不关心所有权，你只用写一个<code>*</code>就能让代码会更干净。</p>
<p>Cherno认为大家应该停止关于“Smart or Raw”的争论，在一个真正的框架环境、真正的应用中，生产代码应该使用智能指针，不这么做是非常愚蠢的举动，大部分典型的问题都可以通过这样解决（可能线程方面有点问题，因为<code>shared_ptr</code>不是线程安全的，使用智能指针还有很多其它约束，所以智能指针不是通用的内存解决方案）。更严肃的代码中完全应该使用智能指针，只是初学C++是需要了解原始指针和内存是如何工作的，因为[智能指针只是原始指针上的包装](<a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/51-100/71">https://nagi.fun/Cherno-CPP-Notes/51-100/71</a> Safety in modern C%2B%2B and how to teach it&#x2F;44 SMART POINTERS in C++.md#^a6997e)，它们围绕原始指针做了额外的辅助代码，以便自动化所有事情，但本质上只是删除和释放了内存。你必须得知道这一切是如何工作的，这也是为什么Cherno有几课是讲编译器和链接是如何工作的([06 How the C++ Compiler Works](<a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/51-100/71">https://nagi.fun/Cherno-CPP-Notes/51-100/71</a> Safety in modern C%2B%2B and how to teach it&#x2F;06 How the C++ Compiler Works.md)、[07 How the C++ Linker Works](<a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/51-100/71">https://nagi.fun/Cherno-CPP-Notes/51-100/71</a> Safety in modern C%2B%2B and how to teach it&#x2F;07 How the C++ Linker Works.md))</p>
<h1 id="72-Precompiled-Headers-in-C"><a href="#72-Precompiled-Headers-in-C" class="headerlink" title="72. Precompiled Headers in C++"></a>72. Precompiled Headers in C++</h1><h2 id="1-什么是预编译头文件"><a href="#1-什么是预编译头文件" class="headerlink" title="1. 什么是预编译头文件"></a>1. 什么是预编译头文件</h2><p>预编译的头文件实际上是让你抓取一堆头文件，并将它们转换成编译器可以使用的格式，而不必一遍又一遍地读取这些头文件。 举个例子，每次在 C++文件中<code>#include &lt;vector&gt;</code>的时候，它需要读取整个 Vector 头文件并编译它，而且 Vector 还包含一堆其它的包含文件，这些文件也一样需要读取，预处理器必须把这些复制到这个 Vector 文件，这就有 10w+行代码了，它们需要被解析并以某种形式标记并编译，在你想要编译 main 文件之前，因为你的 main 文件包含 Vector 文件的话，Vector 必须复制并粘贴到 main 文件中，然后所有代码每次都需要被解析和编译。重点是每次你对 C++文件进行修改，哪怕只是加了个空格，整个文件都要重新编译，所以 Vector 文件必须被复制并粘贴到你的 C++文件中，从头开始重新解析并编译。不仅如此，你的项目中有多个文件它们又都包含了 Vector，你不得不持续一遍遍地解析同样的代码，这需要大量时间。</p>
<p>所以你可以用一个叫做<strong>预编译头文件</strong>的东西来代替，它的作用是接受一堆你告诉它要接收的头文件（基本上是一堆代码）它只编译一次，以二进制格式存储，这对编译器来说比单纯的文本处理要快得多。这样就不需要解析整个 Vector 文件，每次它只需要看预编译的头文件，which 此时已经是非常快速且容易使用的、对编译器来说很容易使用的二进制格式。这意味着它会大幅加快编译时间，特别是你的项目越来越大，你会有越来越多的 C++文件。越来越多的头文件，诸如此类，你可以在预编译头文件中添加更多内容，你也有更多使用了共同头文件的源文件需要编译，它会指数级地加速，好的多得多。</p>
<p>所以如果你关心编译时间，你一定要使用预编译头文件。</p>
<p>不过，还有些你不应该用预编译头文件做的事： 到目前为止提到的预编译头文件，其本质还是头文件，which 包含了一堆其它头文件。因此你可能会想把项目中所有的东西都放在预编译头文件中，如果这样做的话是不是构建速度飞快。</p>
<p>是这样，但是如果你把东西放到预编译头文件中，而这些东西会发生变化，在实际的项目中我们在处理项目所以它很有可能会变化，显然必须重新构建预编译的头文件，而这要花费时间，这也可能会导致编译速度变慢。所以不要把会频繁更改的文件放入预编译头文件中。</p>
<p>尽管预编译头文件很有用，而且把你自己的项目文件当进去也没问题，比如把一个不会需要修改的 Log.h 文件放进去就很好，因为这个文件很常用，也方便使用，你不需要再手动地将 Log 包含到项目中的每个 C++文件中。但只要这个 Log 会修改，就不适合放入预编译头文件中，否则每次都要重新编译。</p>
<p>预编译头文件真正有用的是外部依赖，本质上它主要用于不是你写的那些代码，比如 STL、Windows api 等，如果你要<code>#include &lt;windows.h&gt;</code>，which is a 巨大的的头文件，包含了非常多的其它头文件，你不回去修改 windows.h 或者 STL，所以它没有理由不被你放在预编译头文件中，因为它们的代码可能比你的实际项目代码多很多倍，每个 C++文件每次都要编译它们可想是一件多么恐怖的事情，你可能永远也不会去修改它们。因此直接把它们放入到预编译头文件中就不用管了。</p>
<h2 id="2-依赖关系"><a href="#2-依赖关系" class="headerlink" title="2. 依赖关系"></a>2. 依赖关系</h2><p>PCH（就是预编译头文件）实际上做的事是把所有东西都塞进来，它可能会隐藏现在实际正在使用的东西，会影响可读性。比如只有个别文件需要使用一个窗口库 GLFW，那就没必要把所有的依赖项都放在 PCH 中，如果你只看一个单独的 cpp 文件你并不知道它需要什么依赖，再把它导入其它文件时就不好理解它依赖的东西了。但如果你通过实际的<code>include</code>包含它们就很清晰了，可以看到每个文件需要什么文件。但是如果你只包含 PCH，然后 PCH 中放很多包含文件，就会比较麻烦了。</p>
<p>所以<strong>不要把所有依赖都放在 PCH 中</strong>，因为包含实际的依赖会更容易阅读。应该放进 PCH 的东西是像 STL 这样的，因为 string、vectors、std::cout 是许多地方都要用到的，你不希望每次都编译它们，而 GLFW 可能就只需要编译一次。</p>
<h1 id="73-Dynamic-Casting-in-C"><a href="#73-Dynamic-Casting-in-C" class="headerlink" title="73. Dynamic Casting in C++"></a>73. Dynamic Casting in C++</h1><p><code>dynamic_cast</code>是专门用于<strong>沿继承层次结构</strong>进行的强制类型转换，比如我的一个游戏里有一个实体类，它派生出了玩家类和敌人类，如果我想将玩家转换为实体是很简单的，因为玩家本身就是实体对象，可以隐式转换。但如果我想将一个实体类型转换为玩家，编译器会相信我们，如果它并不是一个玩家的话我们就相当于在尝试玩家独有的数据，程序可能会崩溃。因为这个原因，<code>dynamic_cast</code>常被用来做验证，如果我们尝试使用它将一个敌人转化为玩家，这个转化会失败，<code>dynamic_cast</code>会返回一个 NULL 指针，也就是 0。</p>
<h1 id="74-BENCHMARKING-in-C-how-to-measure-performance"><a href="#74-BENCHMARKING-in-C-how-to-measure-performance" class="headerlink" title="74. BENCHMARKING in C++ (how to measure performance)"></a>74. BENCHMARKING in C++ (how to measure performance)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span>	</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>	std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; m_StartTimepoint;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Timer</span>()<br>	&#123;<br>		m_StartTimepoint = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>	&#125;<br><br>	~<span class="hljs-built_in">Timer</span>()<br>	&#123;<br>		<span class="hljs-built_in">Stop</span>();<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stop</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">auto</span> EndTimepoint = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>		<span class="hljs-keyword">auto</span> start = std::chrono::<span class="hljs-built_in">time_point_cast</span>&lt;std::chrono::microseconds&gt;(m_StartTimepoint).<span class="hljs-built_in">time_since_epoch</span>().<span class="hljs-built_in">count</span>();<br>		<span class="hljs-keyword">auto</span> end = std::chrono::<span class="hljs-built_in">time_point_cast</span>&lt;std::chrono::microseconds&gt;(EndTimepoint).<span class="hljs-built_in">time_since_epoch</span>().<span class="hljs-built_in">count</span>();<br><br>		<span class="hljs-keyword">auto</span> duration = end - start;<br>		<span class="hljs-type">double</span> ms = duration * <span class="hljs-number">0.001</span>;<br><br>		std::cout &lt;&lt; duration &lt;&lt; <span class="hljs-string">&quot;us (&quot;</span> &lt;&lt; ms &lt;&lt; <span class="hljs-string">&quot;ms)\n&quot;</span>;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> value = <span class="hljs-number">0</span>;<br>	&#123;<br>		Timer timer;<br><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++)<br>		&#123;<br>			value += <span class="hljs-number">2</span>;<br>		&#125;<br>	&#125;<br>	std::cout &lt;&lt; value &lt;&lt; std::endl;<br><br>	__debugbreak();<span class="hljs-comment">// VS打断点专用语法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="智能指针的性能对比"><a href="#智能指针的性能对比" class="headerlink" title="智能指针的性能对比"></a>智能指针的性能对比</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>	std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; m_StartTimepoint;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Timer</span>()<br>	&#123;<br>		m_StartTimepoint = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>	&#125;<br><br>	~<span class="hljs-built_in">Timer</span>()<br>	&#123;<br>		<span class="hljs-built_in">Stop</span>();<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stop</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">auto</span> EndTimepoint = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>		<span class="hljs-keyword">auto</span> start = std::chrono::<span class="hljs-built_in">time_point_cast</span>&lt;std::chrono::microseconds&gt;(m_StartTimepoint).<span class="hljs-built_in">time_since_epoch</span>().<span class="hljs-built_in">count</span>();<br>		<span class="hljs-keyword">auto</span> end = std::chrono::<span class="hljs-built_in">time_point_cast</span>&lt;std::chrono::microseconds&gt;(EndTimepoint).<span class="hljs-built_in">time_since_epoch</span>().<span class="hljs-built_in">count</span>();<br><br>		<span class="hljs-keyword">auto</span> duration = end - start;<br>		<span class="hljs-type">double</span> ms = duration * <span class="hljs-number">0.001</span>;<br><br>		std::cout &lt;&lt; duration &lt;&lt; <span class="hljs-string">&quot;us (&quot;</span> &lt;&lt; ms &lt;&lt; <span class="hljs-string">&quot;ms)\n&quot;</span>;<br><br>	&#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vector2</span><br>	&#123;<br>		<span class="hljs-type">float</span> x, y;<br>	&#125;;<br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;Make shared!&quot;</span> &lt;&lt; std::endl;<br>	&#123;<br>		std::array&lt;std::shared_ptr&lt;Vector2&gt;, <span class="hljs-number">1000</span>&gt; sharedPtrs;<br>		Timer timer;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sharedPtrs.<span class="hljs-built_in">size</span>(); i++)<br>			sharedPtrs[i] = std::<span class="hljs-built_in">make_shared</span>&lt;Vector2&gt;();<br>	&#125;<br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;New shared!&quot;</span> &lt;&lt; std::endl;<br>	&#123;<br>		std::array&lt;std::shared_ptr&lt;Vector2&gt;, <span class="hljs-number">1000</span>&gt; sharedPtrs;<br>		Timer timer;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sharedPtrs.<span class="hljs-built_in">size</span>(); i++)<br>			sharedPtrs[i] = std::<span class="hljs-built_in">shared_ptr</span>&lt;Vector2&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Vector2</span>());<br>	&#125;<br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;Make unique!&quot;</span> &lt;&lt; std::endl;<br>	&#123;<br>		std::array&lt;std::unique_ptr&lt;Vector2&gt;, <span class="hljs-number">1000</span>&gt; sharedPtrs;<br>		Timer timer;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sharedPtrs.<span class="hljs-built_in">size</span>(); i++)<br>			sharedPtrs[i] = std::<span class="hljs-built_in">make_unique</span>&lt;Vector2&gt;();<br>	&#125;<br>	<br> 	__debugbreak();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>切换到 Release 模式，可以发现<code>make_shared</code>明显比<code>new</code>快，所以一定要确保你所分析的代码，是在 Release 时真正有意义的，因为你不会在 Debug 时发布代码。</p>
<h1 id="75-Structed-bindings-in-C-C-17"><a href="#75-Structed-bindings-in-C-C-17" class="headerlink" title="75. Structed bindings in C++(C++17)"></a>75. Structed bindings in C++(C++17)</h1><ul>
<li><strong>结构化绑定（只针对 C++17）</strong></li>
</ul>
<p><em>Structured binding</em>（结构化绑定）是一个新特性，让我们更好地处理多返回值（多返回值可参考[52 C++处理多返回值](<a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/51-100/52">https://nagi.fun/Cherno-CPP-Notes/51-100/52</a> How to Deal with Multiple Return Values in C%2B%2B&#x2F;)），这是在 52 课方法基础上拓展的一种处理多返回值的新方法，特别是如何处理 <em>tuple</em>（元组）和 <em>pairs</em> (对组）以及返回诸如此类的东西。因为结构化绑定简化了我们的代码，让它比以前的做法更简洁。</p>
<ul>
<li>没有结构化绑定这个新特性时，最好使用sturct来处理多返回值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C+">#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;tuple&gt;<br><br>std::tuple&lt;std::string, int&gt; CreatePerson()<br>&#123;<br>	return&#123; &quot;Cherno&quot;, 24 &#125;;<br>&#125;<br><br><br>struct Person<br>&#123;<br>	std::string Name;<br>	int Age;<br>&#125;;<br><br>int main()<br>&#123;<br>	// method 1:tuple<br>	auto person = CreatePerson();<br>	std::string&amp; name = std::get&lt;0&gt;(person);<br>	int age = std::get&lt;1&gt;(person);<br>	<br>	// method 2:tie<br>	std::string name;<br>	int age;<br>	std::tie(name, age) = CreatePerson();<br><br>	// method 3: struct<br>	Person person1;<br>	person1.Name = &quot;Cherno&quot;;<br>	person1.Age = 24;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>结构化绑定</li>
</ul>
<p>需要确保项目属性设置为C++17才行，C++11和C++14不支持此属性，编译通过不了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><br><span class="hljs-function">std::tuple&lt;std::string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">CreatePerson</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span>&#123; <span class="hljs-string">&quot;Cherno&quot;</span>, <span class="hljs-number">24</span> &#125;;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">auto</span> [name, age] = <span class="hljs-built_in">CreatePerson</span>();<br>	std::cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; age &lt;&lt; std::endl;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="76-How-to-deal-with-OPTIONAL-Data-in-C-C-17"><a href="#76-How-to-deal-with-OPTIONAL-Data-in-C-C-17" class="headerlink" title="76. How to deal with OPTIONAL Data in C++(C++17)"></a>76. How to deal with OPTIONAL Data in C++(C++17)</h1><p>很多时候，我们有一个返回数据的函数，比方说我们正在读取一个文件，但是如果这个文件不能被读取会发生什么？它可能不存在，或者是数据不是我们期望的格式，我们仍然需要从函数中返回一些东西。在这个特定的情况下，可能只会返回一个空字符串，但这没有多大意义。意思是，如果读取文件是空的， 我们应该有办法看到数据是否存在。</p>
<p>这就是要用到<code>std::optional</code>的地方了，这是 C++17 标准的新东西。</p>
<ul>
<li>不使用optional</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-function">std::string <span class="hljs-title">ReadFileAsString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filepath, <span class="hljs-type">bool</span>&amp; outSuccess)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-function">std::ifstream <span class="hljs-title">stream</span><span class="hljs-params">(filepath)</span></span>;<br>	<span class="hljs-keyword">if</span> (stream)<br>	&#123;<br>		std::string result;<br>		<span class="hljs-comment">// read file</span><br>		stream.<span class="hljs-built_in">close</span>();<br>		outSuccess = <span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br><br>	outSuccess = <span class="hljs-literal">false</span>;<br>	<span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">bool</span> fileOpenedSuccessfully;<br>	std::string data = <span class="hljs-built_in">ReadFileAsString</span>(<span class="hljs-string">&quot;data.txt&quot;</span>, fileOpenedSuccessfully);<br>	<span class="hljs-keyword">if</span> (fileOpenedSuccessfully) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>使用optional的情况</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br><br>std::optional &lt;std::string&gt; <span class="hljs-built_in">ReadFileAsString</span>(<span class="hljs-type">const</span> std::string&amp; filepath)<br>&#123;<br>	<span class="hljs-function">std::ifstream <span class="hljs-title">stream</span><span class="hljs-params">(filepath)</span></span>;<br>	<span class="hljs-keyword">if</span> (stream)<br>	&#123;<br>		std::string result;<br>		<span class="hljs-comment">// Read file</span><br>		stream.<span class="hljs-built_in">close</span>();<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br>	<span class="hljs-keyword">return</span> &#123;&#125;;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::optional&lt;std::string&gt; data = <span class="hljs-built_in">ReadFileAsString</span>(<span class="hljs-string">&quot;data.txt&quot;</span>); <span class="hljs-comment">// 可以auto</span><br>	<span class="hljs-keyword">if</span> (data)<span class="hljs-comment">// 本来可以写data.has_value()，但是data对象有一个bool运算符，所以这样写更简洁</span><br>	&#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;file read successfully\n&quot;</span>;<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;file could not read\n&quot;</span>;<br>	&#125;<br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>





<h1 id="77-Multiple-TYPES-of-Data-in-a-SINGLE-VARIABLE-in-C"><a href="#77-Multiple-TYPES-of-Data-in-a-SINGLE-VARIABLE-in-C" class="headerlink" title="77. Multiple TYPES of Data in a SINGLE VARIABLE in C++"></a>77. Multiple TYPES of Data in a SINGLE VARIABLE in C++</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::variant&lt;std::string, <span class="hljs-type">int</span>&gt; data;<br>	data = <span class="hljs-string">&quot;Cherno&quot;</span>;<br>	std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;std::string&gt;(data) &lt;&lt; std::endl;<br>	data = <span class="hljs-number">2</span>;<br>	std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int</span>&gt;(data) &lt;&lt; std::endl;<br>	std::cin.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个和<code>std::optional</code>很像，它的作用是让我们不用担心处理的确切数据类型， 只有一个变量放在那儿，我们之后再去考虑它的具体类型。它允许你列出所有可能的类型，然后你可以决定它将是什么，如果你想的话可以把它重新赋值给任意类型，这也是你创建可能有多个类型的变量的一种方式。</p>
<h1 id="78-How-to-store-ANY-data-in-C-C-17"><a href="#78-How-to-store-ANY-data-in-C-C-17" class="headerlink" title="78. How to store ANY data in C++(C++17)"></a>78. How to store ANY data in C++(C++17)</h1><p>[78 如何存储任意类型的数据 - cherno-cpp-notes (nagi.fun)](<a target="_blank" rel="noopener" href="https://nagi.fun/Cherno-CPP-Notes/51-100/78">https://nagi.fun/Cherno-CPP-Notes/51-100/78</a> How to store ANY data in C%2B%2B&#x2F;)</p>
<h1 id="79-How-to-make-C-run-FASTER-with-std-async"><a href="#79-How-to-make-C-run-FASTER-with-std-async" class="headerlink" title="79. How to make C++ run FASTER (with std::async)"></a>79. How to make C++ run FASTER (with std::async)</h1><p>通过多线程来提高性能！</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/" class="category-chain-item">知识积累</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/CPP/" class="print-no-link">#CPP</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>ChernoCPP-2</div>
      <div>https://blog.cosmicdusty.cc/post/Knowledge/ChernoCPP_2/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Murphy</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年12月29日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/post/MyLife/BookMovieMusic2024/" title="书影音2024">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">书影音2024</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/post/MyLife/MYYEAR2023/" title="MY YEAR 2023">
                        <span class="hidden-mobile">MY YEAR 2023</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"JijHNKemeVNog4wF7g9I5TR3-gzGzoHsz","appKey":"FvsKdxHOP2aG5rHrHby5aV0b","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a rel="nofollow noopener"><span>Powered by</span></a> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span><b>Hexo</b></span></a> <i class="iconfont icon-love"></i> <a rel="nofollow noopener"><span>Themed by</span></a> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span><b>Fluid</b></span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量
        <span id="busuanzi_value_site_pv"></span>
        次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数
        <span id="busuanzi_value_site_uv"></span>
        人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
